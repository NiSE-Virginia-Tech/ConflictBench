Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/org/ansj/util/MyStaticValue.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/org/ansj/util/MyStaticValue.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/org/ansj/util/MyStaticValue.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/org/ansj/util/MyStaticValue.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/org/ansj/util/MyStaticValue.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/org/ansj/util/MyStaticValue.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> ansj : Folder]
						[NT -> util : Folder]
							[NT -> MyStaticValue.java : Java-File]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> ansj : Folder]
						[NT -> util : Folder]
							[NT -> MyStaticValue.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package org.ansj.util;" compose:Replacement merge: Default]
									[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
									[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
									[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
									[T -> java.io.ObjectInputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectInputStream;" compose:Replacement merge: Default]
									[T -> java.io.UnsupportedEncodingException{ImportPackage} : ImportDeclaration "import java.io.UnsupportedEncodingException;" compose:Replacement merge: Default]
									[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
									[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
									[T -> java.util.PropertyResourceBundle{ImportPackage} : ImportDeclaration "import java.util.PropertyResourceBundle;" compose:Replacement merge: Default]
									[T -> java.util.ResourceBundle{ImportPackage} : ImportDeclaration "import java.util.ResourceBundle;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.locks.Lock{ImportPackage} : ImportDeclaration "import java.util.concurrent.locks.Lock;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.locks.ReentrantLock{ImportPackage} : ImportDeclaration "import java.util.concurrent.locks.ReentrantLock;" compose:Replacement merge: Default]
									[T -> java.util.logging.Logger{ImportPackage} : ImportDeclaration "import java.util.logging.Logger;" compose:Replacement merge: Default]
									[T -> org.ansj.app.crf.Model{ImportPackage} : ImportDeclaration "import org.ansj.app.crf.Model;" compose:Replacement merge: Default]
									[T -> org.ansj.app.crf.SplitWord{ImportPackage} : ImportDeclaration "import org.ansj.app.crf.SplitWord;" compose:Replacement merge: Default]
									[T -> org.ansj.dic.DicReader{ImportPackage} : ImportDeclaration "import org.ansj.dic.DicReader;" compose:Replacement merge: Default]
									[T -> org.ansj.domain.AnsjItem{ImportPackage} : ImportDeclaration "import org.ansj.domain.AnsjItem;" compose:Replacement merge: Default]
									[T -> org.ansj.library.DATDictionary{ImportPackage} : ImportDeclaration "import org.ansj.library.DATDictionary;" compose:Replacement merge: Default]
									[T -> org.nlpcn.commons.lang.util.FileFinder{ImportPackage} : ImportDeclaration "import org.nlpcn.commons.lang.util.FileFinder;" compose:Replacement merge: Default]
									[T -> org.nlpcn.commons.lang.util.IOUtil{ImportPackage} : ImportDeclaration "import org.nlpcn.commons.lang.util.IOUtil;" compose:Replacement merge: Default]
									[T -> org.nlpcn.commons.lang.util.StringUtil{ImportPackage} : ImportDeclaration "import org.nlpcn.commons.lang.util.StringUtil;" compose:Replacement merge: Default]
									[NT -> MyStaticValue : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> MyStaticValue : Id "MyStaticValue" compose:Replacement merge: Default]
										[T -> LIBRARYLOG : FieldDecl "public static final Logger LIBRARYLOG = Logger.getLogger("DICLOG");" compose:Replacement merge: SemanticConflict]
										[T -> isNameRecognition : FieldDecl "public static boolean isNameRecognition = true;" compose:Replacement merge: SemanticConflict]
										[T -> LOCK : FieldDecl "private static final Lock LOCK = new ReentrantLock();" compose:Replacement merge: SemanticConflict]
										[T -> isNumRecognition : FieldDecl "public static boolean isNumRecognition = true;" compose:Replacement merge: SemanticConflict]
										[T -> isQuantifierRecognition : FieldDecl "public static boolean isQuantifierRecognition = true;" compose:Replacement merge: SemanticConflict]
										[T -> crfSplitWord : FieldDecl "private static SplitWord crfSplitWord = null;" compose:Replacement merge: SemanticConflict]
										[T -> isRealName : FieldDecl "public static boolean isRealName = false;" compose:Replacement merge: SemanticConflict]
										[T -> userLibrary : FieldDecl "public static String userLibrary = "library/default.dic";" compose:Replacement merge: SemanticConflict]
										[T -> ambiguityLibrary : FieldDecl "public static String ambiguityLibrary = "library/ambiguity.dic";" compose:Replacement merge: SemanticConflict]
										[T -> isSkipUserDefine : FieldDecl "public static boolean isSkipUserDefine = false;" compose:Replacement merge: SemanticConflict]
										[T -> auto2 : InitializerDecl "static {          /**           * 配置文件变量           */          ResourceBundle rb = null;          try {              rb = ResourceBundle.getBundle("library");          } catch (Exception e) {              try {                  File find = FileFinder.find("library.properties");                  if (find != null) {                      rb = new PropertyResourceBundle(IOUtil.getReader(find.getAbsolutePath(), System.getProperty("file.encoding")));                      LIBRARYLOG.info("load library not find in classPath ! i find it in " + find.getAbsolutePath() + " make sure it is your config!");                  }              } catch (Exception e1) {                  LIBRARYLOG.warning("not find library.properties. and err " + e.getMessage() + " i think it is a bug!");              }          }            if (rb == null) {              LIBRARYLOG.warning("not find library.properties in classpath use it by default !");          }            if (rb.containsKey("userLibrary"))              userLibrary = rb.getString("userLibrary");          if (rb.containsKey("ambiguityLibrary"))              ambiguityLibrary = rb.getString("ambiguityLibrary");          if (rb.containsKey("isSkipUserDefine"))              isSkipUserDefine = Boolean.valueOf(rb.getString("isSkipUserDefine"));          if (rb.containsKey("isRealName"))              isRealName = Boolean.valueOf(rb.getString("isRealName"));      }" compose:Replacement merge: Default]
										[T -> getPersonReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getPersonReader() {          return DicReader.getReader("person/person.dic");      }" compose:Replacement merge: LineBased]
										[T -> getCompanReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getCompanReader() {          return DicReader.getReader("company/company.data");      }" compose:Replacement merge: LineBased]
										[T -> getNewWordReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNewWordReader() {          return DicReader.getReader("newWord/new_word_freq.dic");      }" compose:Replacement merge: LineBased]
										[T -> getArraysReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getArraysReader() {          return DicReader.getReader("arrays.dic");      }" compose:Replacement merge: LineBased]
										[T -> getNumberReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNumberReader() {          return DicReader.getReader("numberLibrary.dic");      }" compose:Replacement merge: LineBased]
										[T -> getEnglishReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getEnglishReader() {          return DicReader.getReader("englishLibrary.dic");      }" compose:Replacement merge: LineBased]
										[T -> getNatureMapReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNatureMapReader() {          return DicReader.getReader("nature/nature.map");      }" compose:Replacement merge: LineBased]
										[T -> getNatureTableReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNatureTableReader() {          return DicReader.getReader("nature/nature.table");      }" compose:Replacement merge: LineBased]
										[T -> getPersonFreqReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getPersonFreqReader() {          return DicReader.getReader("person/name_freq.dic");      }" compose:Replacement merge: LineBased]
										[T -> getPersonFreqMap({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")      public static Map<String, int[][]> getPersonFreqMap() {          InputStream inputStream = null;          ObjectInputStream objectInputStream = null;          Map<String, int[][]> map = new HashMap<String, int[][]>(0);          try {              inputStream = DicReader.getInputStream("person/asian_name_freq.data");              objectInputStream = new ObjectInputStream(inputStream);              map = (Map<String, int[][]>) objectInputStream.readObject();            } catch (IOException e) {              e.printStackTrace();          } catch (ClassNotFoundException e) {              e.printStackTrace();          } finally {              try {                  if (objectInputStream != null)                      objectInputStream.close();                  if (inputStream != null)                      inputStream.close();              } catch (IOException e) {                  e.printStackTrace();              }          }          return map;      }" compose:Replacement merge: LineBased]
										[T -> initBigramTables({FormalParametersInternal}) : MethodDecl "public static void initBigramTables() {          BufferedReader reader = null;          try {              reader = IOUtil.getReader(DicReader.getInputStream("bigramdict.dic"), "UTF-8");              String temp = null;              String[] strs = null;              int freq = 0;              while ((temp = reader.readLine()) != null) {                  if (StringUtil.isBlank(temp)) {                      continue;                  }                  strs = temp.split("\t");                  freq = Integer.parseInt(strs[1]);                  strs = strs[0].split("@");                  AnsjItem fromItem = DATDictionary.getItem(strs[0]);                    AnsjItem toItem = DATDictionary.getItem(strs[1]);                    if (fromItem == AnsjItem.NULL && strs[0].contains("#")) {                      fromItem = AnsjItem.BEGIN;                  }                    if (toItem == AnsjItem.NULL && strs[1].contains("#")) {                      toItem = AnsjItem.END;                  }                    if (fromItem == AnsjItem.NULL || toItem == AnsjItem.NULL) {                      continue;                  }                    if (fromItem.bigramEntryMap == null) {                      fromItem.bigramEntryMap = new HashMap<Integer, Integer>();                  }                    fromItem.bigramEntryMap.put(toItem.index, freq);                }          } catch (NumberFormatException e) {              e.printStackTrace();          } catch (UnsupportedEncodingException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              IOUtil.close(reader);          }        }" compose:Replacement merge: LineBased]
										[T -> getCRFSplitWord({FormalParametersInternal}) : MethodDecl "public static SplitWord getCRFSplitWord() {          if (crfSplitWord != null) {              return crfSplitWord;          }          LOCK.lock();          if (crfSplitWord != null) {              return crfSplitWord;          }            try {              long start = System.currentTimeMillis();              LIBRARYLOG.info("begin init crf model!");              crfSplitWord = new SplitWord(Model.loadModel(DicReader.getInputStream("crf/crf.model")));              LIBRARYLOG.info("load crf crf use time:" + (System.currentTimeMillis() - start));          } catch (Exception e) {              e.printStackTrace();          } finally {              LOCK.unlock();          }            return crfSplitWord;      }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> ansj : Folder]
						[NT -> util : Folder]
							[NT -> MyStaticValue.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package org.ansj.util;" compose:Replacement merge: Default]
									[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
									[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
									[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
									[T -> java.io.ObjectInputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectInputStream;" compose:Replacement merge: Default]
									[T -> java.io.UnsupportedEncodingException{ImportPackage} : ImportDeclaration "import java.io.UnsupportedEncodingException;" compose:Replacement merge: Default]
									[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
									[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
									[T -> java.util.PropertyResourceBundle{ImportPackage} : ImportDeclaration "import java.util.PropertyResourceBundle;" compose:Replacement merge: Default]
									[T -> java.util.ResourceBundle{ImportPackage} : ImportDeclaration "import java.util.ResourceBundle;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.locks.Lock{ImportPackage} : ImportDeclaration "import java.util.concurrent.locks.Lock;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.locks.ReentrantLock{ImportPackage} : ImportDeclaration "import java.util.concurrent.locks.ReentrantLock;" compose:Replacement merge: Default]
									[T -> java.util.logging.Logger{ImportPackage} : ImportDeclaration "import java.util.logging.Logger;" compose:Replacement merge: Default]
									[T -> org.ansj.app.crf.Model{ImportPackage} : ImportDeclaration "import org.ansj.app.crf.Model;" compose:Replacement merge: Default]
									[T -> org.ansj.app.crf.SplitWord{ImportPackage} : ImportDeclaration "import org.ansj.app.crf.SplitWord;" compose:Replacement merge: Default]
									[T -> org.ansj.dic.DicReader{ImportPackage} : ImportDeclaration "import org.ansj.dic.DicReader;" compose:Replacement merge: Default]
									[T -> org.ansj.domain.AnsjItem{ImportPackage} : ImportDeclaration "import org.ansj.domain.AnsjItem;" compose:Replacement merge: Default]
									[T -> org.ansj.library.DATDictionary{ImportPackage} : ImportDeclaration "import org.ansj.library.DATDictionary;" compose:Replacement merge: Default]
									[T -> org.nlpcn.commons.lang.util.FileFinder{ImportPackage} : ImportDeclaration "import org.nlpcn.commons.lang.util.FileFinder;" compose:Replacement merge: Default]
									[T -> org.nlpcn.commons.lang.util.IOUtil{ImportPackage} : ImportDeclaration "import org.nlpcn.commons.lang.util.IOUtil;" compose:Replacement merge: Default]
									[T -> org.nlpcn.commons.lang.util.StringUtil{ImportPackage} : ImportDeclaration "import org.nlpcn.commons.lang.util.StringUtil;" compose:Replacement merge: Default]
									[NT -> MyStaticValue : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> MyStaticValue : Id "MyStaticValue" compose:Replacement merge: Default]
										[T -> LIBRARYLOG : FieldDecl "public static final Logger LIBRARYLOG = Logger.getLogger("DICLOG");" compose:Replacement merge: SemanticConflict]
										[T -> isNameRecognition : FieldDecl "public static boolean isNameRecognition = true;" compose:Replacement merge: SemanticConflict]
										[T -> LOCK : FieldDecl "private static final Lock LOCK = new ReentrantLock();" compose:Replacement merge: SemanticConflict]
										[T -> isNumRecognition : FieldDecl "public static boolean isNumRecognition = true;" compose:Replacement merge: SemanticConflict]
										[T -> isQuantifierRecognition : FieldDecl "public static boolean isQuantifierRecognition = true;" compose:Replacement merge: SemanticConflict]
										[T -> crfSplitWord : FieldDecl "private static SplitWord crfSplitWord = null;" compose:Replacement merge: SemanticConflict]
										[T -> isRealName : FieldDecl "public static boolean isRealName = false;" compose:Replacement merge: SemanticConflict]
										[T -> userLibrary : FieldDecl "public static String userLibrary = "library/default.dic";" compose:Replacement merge: SemanticConflict]
										[T -> ambiguityLibrary : FieldDecl "public static String ambiguityLibrary = "library/ambiguity.dic";" compose:Replacement merge: SemanticConflict]
										[T -> crfModel : FieldDecl "public static String crfModel = "library/crf.model";" compose:Replacement merge: SemanticConflict]
										[T -> isSkipUserDefine : FieldDecl "public static boolean isSkipUserDefine = false;" compose:Replacement merge: SemanticConflict]
										[T -> auto3 : InitializerDecl "static {          /**           * 配置文件变量           */          ResourceBundle rb = null;          try {              rb = ResourceBundle.getBundle("library");          } catch (Exception e) {              try {                  File find = FileFinder.find("library.properties");                  if (find != null) {                      rb = new PropertyResourceBundle(IOUtil.getReader(find.getAbsolutePath(), System.getProperty("file.encoding")));                      LIBRARYLOG.info("load library not find in classPath ! i find it in " + find.getAbsolutePath() + " make sure it is your config!");                  }              } catch (Exception e1) {                  LIBRARYLOG.warning("not find library.properties. and err " + e.getMessage() + " i think it is a bug!");              }          }            if (rb == null) {              LIBRARYLOG.warning("not find library.properties in classpath use it by default !");          } else {                if (rb.containsKey("userLibrary"))                  userLibrary = rb.getString("userLibrary");              if (rb.containsKey("ambiguityLibrary"))                  ambiguityLibrary = rb.getString("ambiguityLibrary");              if (rb.containsKey("isSkipUserDefine"))                  isSkipUserDefine = Boolean.valueOf(rb.getString("isSkipUserDefine"));              if (rb.containsKey("isRealName"))                  isRealName = Boolean.valueOf(rb.getString("isRealName"));              if (rb.containsKey("crfModel"))                  crfModel = rb.getString("crfModel");          }      }" compose:Replacement merge: Default]
										[T -> getPersonReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getPersonReader() {          return DicReader.getReader("person/person.dic");      }" compose:Replacement merge: LineBased]
										[T -> getCompanReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getCompanReader() {          return DicReader.getReader("company/company.data");      }" compose:Replacement merge: LineBased]
										[T -> getNewWordReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNewWordReader() {          return DicReader.getReader("newWord/new_word_freq.dic");      }" compose:Replacement merge: LineBased]
										[T -> getArraysReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getArraysReader() {          return DicReader.getReader("arrays.dic");      }" compose:Replacement merge: LineBased]
										[T -> getNumberReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNumberReader() {          return DicReader.getReader("numberLibrary.dic");      }" compose:Replacement merge: LineBased]
										[T -> getEnglishReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getEnglishReader() {          return DicReader.getReader("englishLibrary.dic");      }" compose:Replacement merge: LineBased]
										[T -> getNatureMapReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNatureMapReader() {          return DicReader.getReader("nature/nature.map");      }" compose:Replacement merge: LineBased]
										[T -> getNatureTableReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getNatureTableReader() {          return DicReader.getReader("nature/nature.table");      }" compose:Replacement merge: LineBased]
										[T -> getPersonFreqReader({FormalParametersInternal}) : MethodDecl "public static BufferedReader getPersonFreqReader() {          return DicReader.getReader("person/name_freq.dic");      }" compose:Replacement merge: LineBased]
										[T -> getPersonFreqMap({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")      public static Map<String, int[][]> getPersonFreqMap() {          InputStream inputStream = null;          ObjectInputStream objectInputStream = null;          Map<String, int[][]> map = new HashMap<String, int[][]>(0);          try {              inputStream = DicReader.getInputStream("person/asian_name_freq.data");              objectInputStream = new ObjectInputStream(inputStream);              map = (Map<String, int[][]>) objectInputStream.readObject();            } catch (IOException e) {              e.printStackTrace();          } catch (ClassNotFoundException e) {              e.printStackTrace();          } finally {              try {                  if (objectInputStream != null)                      objectInputStream.close();                  if (inputStream != null)                      inputStream.close();              } catch (IOException e) {                  e.printStackTrace();              }          }          return map;      }" compose:Replacement merge: LineBased]
										[T -> initBigramTables({FormalParametersInternal}) : MethodDecl "public static void initBigramTables() {          BufferedReader reader = null;          try {              reader = IOUtil.getReader(DicReader.getInputStream("bigramdict.dic"), "UTF-8");              String temp = null;              String[] strs = null;              int freq = 0;              while ((temp = reader.readLine()) != null) {                  if (StringUtil.isBlank(temp)) {                      continue;                  }                  strs = temp.split("\t");                  freq = Integer.parseInt(strs[1]);                  strs = strs[0].split("@");                  AnsjItem fromItem = DATDictionary.getItem(strs[0]);                    AnsjItem toItem = DATDictionary.getItem(strs[1]);                    if (fromItem == AnsjItem.NULL && strs[0].contains("#")) {                      fromItem = AnsjItem.BEGIN;                  }                    if (toItem == AnsjItem.NULL && strs[1].contains("#")) {                      toItem = AnsjItem.END;                  }                    if (fromItem == AnsjItem.NULL || toItem == AnsjItem.NULL) {                      continue;                  }                    if (fromItem.bigramEntryMap == null) {                      fromItem.bigramEntryMap = new HashMap<Integer, Integer>();                  }                    fromItem.bigramEntryMap.put(toItem.index, freq);                }          } catch (NumberFormatException e) {              e.printStackTrace();          } catch (UnsupportedEncodingException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              IOUtil.close(reader);          }        }" compose:Replacement merge: LineBased]
										[T -> getCRFSplitWord({FormalParametersInternal}) : MethodDecl "public static SplitWord getCRFSplitWord() {          if (crfSplitWord != null) {              return crfSplitWord;          }          LOCK.lock();          if (crfSplitWord != null) {              return crfSplitWord;          }            try {              long start = System.currentTimeMillis();              LIBRARYLOG.info("begin init crf model!");              crfSplitWord = new SplitWord(Model.loadModel(IOUtil.getInputStream(crfModel)));              LIBRARYLOG.info("load crf crf use time:" + (System.currentTimeMillis() - start));          } catch (Exception e) {              e.printStackTrace();          } finally {              LOCK.unlock();          }            return crfSplitWord;      }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> ansj : Folder]
						[NT -> util : Folder]
							[NT -> MyStaticValue.java.merge : .java.merge-File]
								[T -> MyStaticValue.java : .java-Content "package org.ansj.util;  import lombok.SneakyThrows; import org.ansj.app.crf.Model; import org.ansj.app.crf.SplitWord; import org.ansj.domain.AnsjItem; import org.ansj.library.DATDictionary; import org.nlpcn.commons.lang.util.FileFinder; import org.nlpcn.commons.lang.util.IOUtil;  import java.io.BufferedReader; import java.io.File; import java.io.ObjectInputStream; import java.util.HashMap; import java.util.Map; import java.util.PropertyResourceBundle; import java.util.ResourceBundle; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.logging.Logger;  import static org.apache.commons.lang3.StringUtils.isBlank;  /**  * 这个类储存一些公用变量.  *  * @author ansj  */ public class MyStaticValue {      public static final Logger LIBRARYLOG = Logger.getLogger("DICLOG");      // 是否开启人名识别     public static boolean isNameRecognition = true;      private static final Lock LOCK = new ReentrantLock();      // 是否开启数字识别     public static boolean isNumRecognition = true;      // 是否数字和量词合并     public static boolean isQuantifierRecognition = true;      // crf 模型      private static SplitWord crfSplitWord = null;      public static boolean isRealName = false;      /**      * 用户自定义词典的加载,如果是路径就扫描路径下的dic文件      */     public static String userLibrary = "library/default.dic";      public static String ambiguityLibrary = "library/ambiguity.dic";      /**      * 是否用户辞典不加载相同的词      */     public static boolean isSkipUserDefine = false;      static {         init();     }      @SneakyThrows     private static void init() {         /**          * 配置文件变量          */         ResourceBundle rb = null;         try {             rb = ResourceBundle.getBundle("library");         } catch (Exception e) {             try {                 File find = FileFinder.find("library.properties");                 if (find != null) {                     rb = new PropertyResourceBundle(IOUtil.getReader(find.getAbsolutePath(), System.getProperty("file.encoding")));                     LIBRARYLOG.info("load library not find in classPath ! i find it in " + find.getAbsolutePath() + " make sure it is your config!");                 }             } catch (Exception e1) {                 LIBRARYLOG.warning("not find library.properties. and err " + e.getMessage() + " i think it is a bug!");             }         }          if (rb == null) {             LIBRARYLOG.warning("not find library.properties in classpath use it by default !");         }          if (rb.containsKey("userLibrary"))             userLibrary = rb.getString("userLibrary");         if (rb.containsKey("ambiguityLibrary"))             ambiguityLibrary = rb.getString("ambiguityLibrary");         if (rb.containsKey("isSkipUserDefine"))             isSkipUserDefine = Boolean.valueOf(rb.getString("isSkipUserDefine"));         if (rb.containsKey("isRealName"))             isRealName = Boolean.valueOf(rb.getString("isRealName"));     }      /**      * 人名词典      */     public static BufferedReader getPersonReader() {         return AnsjUtils.getReader("person/person.dic");     }      /**      * 机构名词典      */     public static BufferedReader getCompanReader() {         return AnsjUtils.getReader("company/company.data");     }      /**      * 词性表      */     public static BufferedReader getNatureMapReader() {         return AnsjUtils.getReader("nature/nature.map");     }      /**      * 词性关联表      */     public static BufferedReader getNatureTableReader() {         return AnsjUtils.getReader("nature/nature.table");     }      /**      * 得道姓名单字的词频词典      */     public static BufferedReader getPersonFreqReader() {         return AnsjUtils.getReader("person/name_freq.dic");     }      /**      * 机构名词典      */     public static BufferedReader getNewWordReader() {         return AnsjUtils.getReader("newWord/new_word_freq.dic");     }      /**      * 核心词典      */     public static BufferedReader getArraysReader() {         return AnsjUtils.getReader("arrays.dic");     }      /**      * 数字词典      */     public static BufferedReader getNumberReader() {         return AnsjUtils.getReader("numberLibrary.dic");     }      /**      * 英文词典      */     public static BufferedReader getEnglishReader() {         return AnsjUtils.getReader("englishLibrary.dic");     }      /**      * 名字词性对象反序列化      */     @SneakyThrows     @SuppressWarnings("unchecked")     public static Map<String, int[][]> getPersonFreqMap() {         try (final ObjectInputStream os = new ObjectInputStream(AnsjUtils.getInputStream("person/asian_name_freq.data"))) {             return (Map<String, int[][]>) os.readObject();         }     }      /**      * 词与词之间的关联表数据      */     @SneakyThrows     public static void initBigramTables() {         try (final BufferedReader reader = IOUtil.getReader(AnsjUtils.getInputStream("bigramdict.dic"), "UTF-8")) {             String temp;             while ((temp = reader.readLine()) != null) {                 if (isBlank(temp)) {                     continue;                 }                 final String[] split = temp.split("\t");                 final int freq = Integer.parseInt(split[1]);                 final String[] strs = split[0].split("@");                  AnsjItem fromItem = DATDictionary.getItem(strs[0]);                 AnsjItem toItem = DATDictionary.getItem(strs[1]);                  if (fromItem == AnsjItem.NULL && strs[0].contains("#")) {                     fromItem = AnsjItem.BEGIN;                 }                 if (toItem == AnsjItem.NULL && strs[1].contains("#")) {                     toItem = AnsjItem.END;                 }                 if (fromItem == AnsjItem.NULL || toItem == AnsjItem.NULL) {                     continue;                 }                  if (fromItem.bigramEntryMap == null) {                     fromItem.bigramEntryMap = new HashMap<>();                 }                  fromItem.bigramEntryMap.put(toItem.getIndex(), freq);             }         }     }      /**      * 得到默认的模型      */     @SneakyThrows     public static SplitWord getCRFSplitWord() {         if (crfSplitWord != null) {             return crfSplitWord;         }         LOCK.lock();         if (crfSplitWord != null) {             return crfSplitWord;         }          try {             long start = System.currentTimeMillis();             LIBRARYLOG.info("begin init crf model!");             crfSplitWord = new SplitWord(Model.loadModel(AnsjUtils.getInputStream("crf/crf.model")));             LIBRARYLOG.info("load crf crf use time:" + (System.currentTimeMillis() - start));         } finally {             LOCK.unlock();         }          return crfSplitWord;     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> ansj : Folder]
						[NT -> util : Folder]
							[NT -> MyStaticValue.java.merge : .java.merge-File]
								[T -> MyStaticValue.java : .java-Content "package org.ansj.util;  import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.UnsupportedEncodingException; import java.util.HashMap; import java.util.Map; import java.util.PropertyResourceBundle; import java.util.ResourceBundle; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.logging.Logger;  import org.ansj.app.crf.Model; import org.ansj.app.crf.SplitWord; import org.ansj.dic.DicReader; import org.ansj.domain.AnsjItem; import org.ansj.library.DATDictionary; import org.nlpcn.commons.lang.util.FileFinder; import org.nlpcn.commons.lang.util.IOUtil; import org.nlpcn.commons.lang.util.StringUtil;  /**  * 这个类储存一些公用变量.  *   * @author ansj  *   */ public class MyStaticValue {      public static final Logger LIBRARYLOG = Logger.getLogger("DICLOG");      // 是否开启人名识别     public static boolean isNameRecognition = true;      private static final Lock LOCK = new ReentrantLock();      // 是否开启数字识别     public static boolean isNumRecognition = true;      // 是否数字和量词合并     public static boolean isQuantifierRecognition = true;      // crf 模型      private static SplitWord crfSplitWord = null;      public static boolean isRealName = false;      /**      * 用户自定义词典的加载,如果是路径就扫描路径下的dic文件      */     public static String userLibrary = "library/default.dic";      public static String ambiguityLibrary = "library/ambiguity.dic";      /**      * 是否用户辞典不加载相同的词      */     public static boolean isSkipUserDefine = false;      static {         /**          * 配置文件变量          */         ResourceBundle rb = null;         try {             rb = ResourceBundle.getBundle("library");         } catch (Exception e) {             try {                 File find = FileFinder.find("library.properties");                 if (find != null) {                     rb = new PropertyResourceBundle(IOUtil.getReader(find.getAbsolutePath(), System.getProperty("file.encoding")));                     LIBRARYLOG.info("load library not find in classPath ! i find it in " + find.getAbsolutePath() + " make sure it is your config!");                 }             } catch (Exception e1) {                 LIBRARYLOG.warning("not find library.properties. and err " + e.getMessage() + " i think it is a bug!");             }         }          if (rb == null) {             LIBRARYLOG.warning("not find library.properties in classpath use it by default !");         }          if (rb.containsKey("userLibrary"))             userLibrary = rb.getString("userLibrary");         if (rb.containsKey("ambiguityLibrary"))             ambiguityLibrary = rb.getString("ambiguityLibrary");         if (rb.containsKey("isSkipUserDefine"))             isSkipUserDefine = Boolean.valueOf(rb.getString("isSkipUserDefine"));         if (rb.containsKey("isRealName"))             isRealName = Boolean.valueOf(rb.getString("isRealName"));     }      /**      * 人名词典      *       * @return      */     public static BufferedReader getPersonReader() {         return DicReader.getReader("person/person.dic");     }      /**      * 机构名词典      *       * @return      */     public static BufferedReader getCompanReader() {         return DicReader.getReader("company/company.data");     }      /**      * 机构名词典      *       * @return      */     public static BufferedReader getNewWordReader() {         return DicReader.getReader("newWord/new_word_freq.dic");     }      /**      * 核心词典      *       * @return      */     public static BufferedReader getArraysReader() {         return DicReader.getReader("arrays.dic");     }      /**      * 数字词典      *       * @return      */     public static BufferedReader getNumberReader() {         return DicReader.getReader("numberLibrary.dic");     }      /**      * 英文词典      *       * @return      */     public static BufferedReader getEnglishReader() {         return DicReader.getReader("englishLibrary.dic");     }      /**      * 词性表      *       * @return      */     public static BufferedReader getNatureMapReader() {         return DicReader.getReader("nature/nature.map");     }      /**      * 词性关联表      *       * @return      */     public static BufferedReader getNatureTableReader() {         return DicReader.getReader("nature/nature.table");     }      /**      * 得道姓名单字的词频词典      *       * @return      */     public static BufferedReader getPersonFreqReader() {         return DicReader.getReader("person/name_freq.dic");     }      /**      * 名字词性对象反序列化      *       * @return      */     @SuppressWarnings("unchecked")     public static Map<String, int[][]> getPersonFreqMap() {         InputStream inputStream = null;         ObjectInputStream objectInputStream = null;         Map<String, int[][]> map = new HashMap<String, int[][]>(0);         try {             inputStream = DicReader.getInputStream("person/asian_name_freq.data");             objectInputStream = new ObjectInputStream(inputStream);             map = (Map<String, int[][]>) objectInputStream.readObject();          } catch (IOException e) {             e.printStackTrace();         } catch (ClassNotFoundException e) {             e.printStackTrace();         } finally {             try {                 if (objectInputStream != null)                     objectInputStream.close();                 if (inputStream != null)                     inputStream.close();             } catch (IOException e) {                 e.printStackTrace();             }         }         return map;     }      /**      * 词与词之间的关联表数据      *       * @return      */     public static void initBigramTables() {         BufferedReader reader = null;         try {             reader = IOUtil.getReader(DicReader.getInputStream("bigramdict.dic"), "UTF-8");             String temp = null;             String[] strs = null;             int freq = 0;             while ((temp = reader.readLine()) != null) {                 if (StringUtil.isBlank(temp)) {                     continue;                 }                 strs = temp.split("\t");                 freq = Integer.parseInt(strs[1]);                 strs = strs[0].split("@");                 AnsjItem fromItem = DATDictionary.getItem(strs[0]);                  AnsjItem toItem = DATDictionary.getItem(strs[1]);                  if (fromItem == AnsjItem.NULL && strs[0].contains("#")) {                     fromItem = AnsjItem.BEGIN;                 }                  if (toItem == AnsjItem.NULL && strs[1].contains("#")) {                     toItem = AnsjItem.END;                 }                  if (fromItem == AnsjItem.NULL || toItem == AnsjItem.NULL) {                     continue;                 }                  if (fromItem.bigramEntryMap == null) {                     fromItem.bigramEntryMap = new HashMap<Integer, Integer>();                 }                  fromItem.bigramEntryMap.put(toItem.index, freq);              }         } catch (NumberFormatException e) {             e.printStackTrace();         } catch (UnsupportedEncodingException e) {             e.printStackTrace();         } catch (IOException e) {             e.printStackTrace();         } finally {             IOUtil.close(reader);         }      }      /**      * 得到默认的模型      *       * @return      */     public static SplitWord getCRFSplitWord() {         if (crfSplitWord != null) {             return crfSplitWord;         }         LOCK.lock();         if (crfSplitWord != null) {             return crfSplitWord;         }          try {             long start = System.currentTimeMillis();             LIBRARYLOG.info("begin init crf model!");             crfSplitWord = new SplitWord(Model.loadModel(DicReader.getInputStream("crf/crf.model")));             LIBRARYLOG.info("load crf crf use time:" + (System.currentTimeMillis() - start));         } catch (Exception e) {             e.printStackTrace();         } finally {             LOCK.unlock();         }          return crfSplitWord;     }  } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> ansj : Folder]
						[NT -> util : Folder]
							[NT -> MyStaticValue.java.merge : .java.merge-File]
								[T -> MyStaticValue.java : .java-Content "package org.ansj.util;  import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.UnsupportedEncodingException; import java.util.HashMap; import java.util.Map; import java.util.PropertyResourceBundle; import java.util.ResourceBundle; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.logging.Logger;  import org.ansj.app.crf.Model; import org.ansj.app.crf.SplitWord; import org.ansj.dic.DicReader; import org.ansj.domain.AnsjItem; import org.ansj.library.DATDictionary; import org.nlpcn.commons.lang.util.FileFinder; import org.nlpcn.commons.lang.util.IOUtil; import org.nlpcn.commons.lang.util.StringUtil;  /**  * 这个类储存一些公用变量.  *   * @author ansj  *   */ public class MyStaticValue {      public static final Logger LIBRARYLOG = Logger.getLogger("DICLOG");      // 是否开启人名识别     public static boolean isNameRecognition = true;      private static final Lock LOCK = new ReentrantLock();      // 是否开启数字识别     public static boolean isNumRecognition = true;      // 是否数字和量词合并     public static boolean isQuantifierRecognition = true;      // crf 模型      private static SplitWord crfSplitWord = null;      public static boolean isRealName = false;      /**      * 用户自定义词典的加载,如果是路径就扫描路径下的dic文件      */     public static String userLibrary = "library/default.dic";      public static String ambiguityLibrary = "library/ambiguity.dic";          public static String crfModel = "library/crf.model";      /**      * 是否用户辞典不加载相同的词      */     public static boolean isSkipUserDefine = false;      static {         /**          * 配置文件变量          */         ResourceBundle rb = null;         try {             rb = ResourceBundle.getBundle("library");         } catch (Exception e) {             try {                 File find = FileFinder.find("library.properties");                 if (find != null) {                     rb = new PropertyResourceBundle(IOUtil.getReader(find.getAbsolutePath(), System.getProperty("file.encoding")));                     LIBRARYLOG.info("load library not find in classPath ! i find it in " + find.getAbsolutePath() + " make sure it is your config!");                 }             } catch (Exception e1) {                 LIBRARYLOG.warning("not find library.properties. and err " + e.getMessage() + " i think it is a bug!");             }         }          if (rb == null) {             LIBRARYLOG.warning("not find library.properties in classpath use it by default !");         } else {              if (rb.containsKey("userLibrary"))                 userLibrary = rb.getString("userLibrary");             if (rb.containsKey("ambiguityLibrary"))                 ambiguityLibrary = rb.getString("ambiguityLibrary");             if (rb.containsKey("isSkipUserDefine"))                 isSkipUserDefine = Boolean.valueOf(rb.getString("isSkipUserDefine"));             if (rb.containsKey("isRealName"))                 isRealName = Boolean.valueOf(rb.getString("isRealName"));             if (rb.containsKey("crfModel"))                 crfModel = rb.getString("crfModel");         }     }      /**      * 人名词典      *       * @return      */     public static BufferedReader getPersonReader() {         return DicReader.getReader("person/person.dic");     }      /**      * 机构名词典      *       * @return      */     public static BufferedReader getCompanReader() {         return DicReader.getReader("company/company.data");     }      /**      * 机构名词典      *       * @return      */     public static BufferedReader getNewWordReader() {         return DicReader.getReader("newWord/new_word_freq.dic");     }      /**      * 核心词典      *       * @return      */     public static BufferedReader getArraysReader() {         return DicReader.getReader("arrays.dic");     }      /**      * 数字词典      *       * @return      */     public static BufferedReader getNumberReader() {         return DicReader.getReader("numberLibrary.dic");     }      /**      * 英文词典      *       * @return      */     public static BufferedReader getEnglishReader() {         return DicReader.getReader("englishLibrary.dic");     }      /**      * 词性表      *       * @return      */     public static BufferedReader getNatureMapReader() {         return DicReader.getReader("nature/nature.map");     }      /**      * 词性关联表      *       * @return      */     public static BufferedReader getNatureTableReader() {         return DicReader.getReader("nature/nature.table");     }      /**      * 得道姓名单字的词频词典      *       * @return      */     public static BufferedReader getPersonFreqReader() {         return DicReader.getReader("person/name_freq.dic");     }      /**      * 名字词性对象反序列化      *       * @return      */     @SuppressWarnings("unchecked")     public static Map<String, int[][]> getPersonFreqMap() {         InputStream inputStream = null;         ObjectInputStream objectInputStream = null;         Map<String, int[][]> map = new HashMap<String, int[][]>(0);         try {             inputStream = DicReader.getInputStream("person/asian_name_freq.data");             objectInputStream = new ObjectInputStream(inputStream);             map = (Map<String, int[][]>) objectInputStream.readObject();          } catch (IOException e) {             e.printStackTrace();         } catch (ClassNotFoundException e) {             e.printStackTrace();         } finally {             try {                 if (objectInputStream != null)                     objectInputStream.close();                 if (inputStream != null)                     inputStream.close();             } catch (IOException e) {                 e.printStackTrace();             }         }         return map;     }      /**      * 词与词之间的关联表数据      *       * @return      */     public static void initBigramTables() {         BufferedReader reader = null;         try {             reader = IOUtil.getReader(DicReader.getInputStream("bigramdict.dic"), "UTF-8");             String temp = null;             String[] strs = null;             int freq = 0;             while ((temp = reader.readLine()) != null) {                 if (StringUtil.isBlank(temp)) {                     continue;                 }                 strs = temp.split("\t");                 freq = Integer.parseInt(strs[1]);                 strs = strs[0].split("@");                 AnsjItem fromItem = DATDictionary.getItem(strs[0]);                  AnsjItem toItem = DATDictionary.getItem(strs[1]);                  if (fromItem == AnsjItem.NULL && strs[0].contains("#")) {                     fromItem = AnsjItem.BEGIN;                 }                  if (toItem == AnsjItem.NULL && strs[1].contains("#")) {                     toItem = AnsjItem.END;                 }                  if (fromItem == AnsjItem.NULL || toItem == AnsjItem.NULL) {                     continue;                 }                  if (fromItem.bigramEntryMap == null) {                     fromItem.bigramEntryMap = new HashMap<Integer, Integer>();                 }                  fromItem.bigramEntryMap.put(toItem.index, freq);              }         } catch (NumberFormatException e) {             e.printStackTrace();         } catch (UnsupportedEncodingException e) {             e.printStackTrace();         } catch (IOException e) {             e.printStackTrace();         } finally {             IOUtil.close(reader);         }      }      /**      * 得到默认的模型      *       * @return      */     public static SplitWord getCRFSplitWord() {         if (crfSplitWord != null) {             return crfSplitWord;         }         LOCK.lock();         if (crfSplitWord != null) {             return crfSplitWord;         }          try {             long start = System.currentTimeMillis();             LIBRARYLOG.info("begin init crf model!");             crfSplitWord = new SplitWord(Model.loadModel(IOUtil.getInputStream(crfModel)));             LIBRARYLOG.info("load crf crf use time:" + (System.currentTimeMillis() - start));         } catch (Exception e) {             e.printStackTrace();         } finally {             LOCK.unlock();         }          return crfSplitWord;     }  } " compose:StringConcatenation merge: LineBased]
