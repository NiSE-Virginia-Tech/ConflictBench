Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/simplify/f1f39138ee268639c9563ef9107f75288be7b1b6/left/smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/simplify/f1f39138ee268639c9563ef9107f75288be7b1b6/left/smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/simplify/f1f39138ee268639c9563ef9107f75288be7b1b6/base/smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/simplify/f1f39138ee268639c9563ef9107f75288be7b1b6/base/smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/simplify/f1f39138ee268639c9563ef9107f75288be7b1b6/right/smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/simplify/f1f39138ee268639c9563ef9107f75288be7b1b6/right/smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
[NT -> left : Feature]
	[NT -> smalivm : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> cf : Folder]
							[NT -> smalivm : Folder]
								[NT -> smali : Folder]
									[NT -> SmaliClassLoader.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package org.cf.smalivm.smali;" compose:Replacement merge: Default]
											[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: Default]
											[T -> java.net.URLClassLoader{ImportPackage} : ImportDeclaration "import java.net.URLClassLoader;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> org.cf.util.ClassNameUtils{ImportPackage} : ImportDeclaration "import org.cf.util.ClassNameUtils;" compose:Replacement merge: Default]
											[T -> org.jf.dexlib2.iface.ClassDef{ImportPackage} : ImportDeclaration "import org.jf.dexlib2.iface.ClassDef;" compose:Replacement merge: Default]
											[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
											[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
											[NT -> SmaliClassLoader : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> SmaliClassLoader : Id "SmaliClassLoader" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends ClassLoader" compose:Replacement merge: Default]
												[T -> log : FieldDecl "private static final Logger log = LoggerFactory.getLogger(SmaliClassLoader.class.getSimpleName());" compose:Replacement merge: SemanticConflict]
												[T -> FRAMEWORK_STUBS_JAR : FieldDecl "private static final String FRAMEWORK_STUBS_JAR = "/framework/android-23.jar";" compose:Replacement merge: SemanticConflict]
												[T -> cachedClasses : FieldDecl "private static final Map<String, Class<?>> cachedClasses = new HashMap<String, Class<?>>();" compose:Replacement merge: SemanticConflict]
												[T -> classBuilder : FieldDecl "private final ClassBuilder classBuilder;" compose:Replacement merge: SemanticConflict]
												[T -> classManager : FieldDecl "private final ClassManager classManager;" compose:Replacement merge: SemanticConflict]
												[T -> jarLoader : FieldDecl "private final URLClassLoader jarLoader;" compose:Replacement merge: SemanticConflict]
												[T -> SmaliClassLoader(ClassManager-ClassManager) : ConstructorDecl "public SmaliClassLoader(ClassManager classManager) {         super(SmaliClassLoader.class.getClassLoader());         // cachedClasses = new HashMap<String, Class<?>>();         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);         jarLoader = new URLClassLoader(new URL[] { jarURL });         this.classBuilder = new ClassBuilder();         this.classManager = classManager;     }" compose:Replacement merge: LineBased]
												[T -> findClass(String-String) : MethodDecl "@Override     protected Class<?> findClass(String name) throws ClassNotFoundException {         try {             return super.findClass(name);         } catch (ClassNotFoundException e) {         }          if (name.startsWith("java.")) {             log.warn("Unable to load prohibited class name: {}\nThis error is likely the result of using a class which references a java.* class only available on Android. There's no work-around at this time since loading protected classes is a huge pain.",                             name);             throw new ClassNotFoundException(name);         }          // try {         // return jarLoader.loadClass(name);         // } catch (ClassNotFoundException e) {         // }          Class<?> klazz = cachedClasses.get(name);         if (klazz != null) {             return klazz;         }          String internalName = ClassNameUtils.binaryToInternal(name);         if (!classManager.isLocalClass(internalName)) {             throw new ClassNotFoundException(name);         }          ClassDef classDef = classManager.getClass(internalName);         byte[] b = classBuilder.build(classDef);         klazz = defineClass(name, b, 0, b.length);         cachedClasses.put(name, klazz);          // No one ever tells you this is also necessary, or you'll have null package for the class:         String packageName = getPackageName(name);         if (packageName != null && getPackage(packageName) == null) {             definePackage(getPackageName(name), null, null, null, null, null, null, null);         }          return klazz;     }" compose:Replacement merge: LineBased]
												[T -> getPackageName(String-String) : MethodDecl "private static String getPackageName(String className) {         int i = className.lastIndexOf('.');         if (i > 0) {             return className.substring(0, i);         } else {             // No package name, e.g. LsomeClass;             return null;         }     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> smalivm : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> cf : Folder]
							[NT -> smalivm : Folder]
								[NT -> smali : Folder]
									[NT -> SmaliClassLoader.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package org.cf.smalivm.smali;" compose:Replacement merge: Default]
											[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: Default]
											[T -> java.net.URLClassLoader{ImportPackage} : ImportDeclaration "import java.net.URLClassLoader;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: Default]
											[T -> javax.annotation.Nullable{ImportPackage} : ImportDeclaration "import javax.annotation.Nullable;" compose:Replacement merge: Default]
											[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
											[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
											[NT -> SmaliClassLoader : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> SmaliClassLoader : Id "SmaliClassLoader" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends ClassLoader" compose:Replacement merge: Default]
												[T -> log : FieldDecl "private static final Logger log = LoggerFactory.getLogger(SmaliClassLoader.class.getSimpleName());" compose:Replacement merge: SemanticConflict]
												[T -> FRAMEWORK_STUBS_JAR : FieldDecl "private static final String FRAMEWORK_STUBS_JAR = "/framework/framework-17.jar";" compose:Replacement merge: SemanticConflict]
												[T -> cachedClasses : FieldDecl "private Map<String, Class<?>> cachedClasses;" compose:Replacement merge: SemanticConflict]
												[T -> classBuilder : FieldDecl "private final ClassBuilder classBuilder;" compose:Replacement merge: SemanticConflict]
												[T -> classManager : FieldDecl "private final ClassManager classManager;" compose:Replacement merge: SemanticConflict]
												[T -> jarLoader : FieldDecl "private URLClassLoader jarLoader;" compose:Replacement merge: SemanticConflict]
												[T -> SmaliClassLoader(ClassManager-ClassManager) : ConstructorDecl "public SmaliClassLoader(ClassManager classManager) {         super(SmaliClassLoader.class.getClassLoader());         cachedClasses = new HashMap<String, Class<?>>();         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);         jarLoader = new URLClassLoader(new URL[] { jarURL });         this.classBuilder = new ClassBuilder(classManager, jarLoader);         this.classManager = classManager;     }" compose:Replacement merge: LineBased]
												[T -> loadClassWithoutBuilding(String-String) : MethodDecl "private @Nullable Class<?> loadClassWithoutBuilding(String name) {         Class<?> klazz = null;         klazz = findLoadedClass(name);         if (klazz != null) {             return klazz;         }          try {             klazz = super.loadClass(name);             if (klazz != null) {                 return klazz;             }         } catch (Exception e) {             e.printStackTrace();         }          klazz = findClass(name);         if (klazz != null) {             return klazz;         }          return null;     }" compose:Replacement merge: LineBased]
												[T -> findClass(String-String) : MethodDecl "@Override     protected Class<?> findClass(String name) {         try {             return jarLoader.loadClass(name);         } catch (ClassNotFoundException e) {         }          if (classBuilder.isShallowClass(name)) {             return null;         }          return cachedClasses.get(name);     }" compose:Replacement merge: LineBased]
												[T -> loadClass(String-String) : MethodDecl "@Override     public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {         Class<?> klazz = loadClassWithoutBuilding(name);         if (klazz != null) {             return klazz;         }          if (cachedClasses.isEmpty()) {             Set<String> classNames = classManager.getNonFrameworkClassNames();             // If I don't set this to null first, cachedClasses does not update.             // VERY VERY STRANGE             cachedClasses = null;             cachedClasses = classBuilder.build(classNames);         }          klazz = findClass(name);         if (klazz == null) {             throw new ClassNotFoundException(name);         }          return klazz;     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> smalivm : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> cf : Folder]
							[NT -> smalivm : Folder]
								[NT -> smali : Folder]
									[NT -> SmaliClassLoader.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package org.cf.smalivm.smali;" compose:Replacement merge: Default]
											[T -> java.net.URL{ImportPackage} : ImportDeclaration "import java.net.URL;" compose:Replacement merge: Default]
											[T -> java.net.URLClassLoader{ImportPackage} : ImportDeclaration "import java.net.URLClassLoader;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.Iterator{ImportPackage} : ImportDeclaration "import java.util.Iterator;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: Default]
											[T -> javax.annotation.Nullable{ImportPackage} : ImportDeclaration "import javax.annotation.Nullable;" compose:Replacement merge: Default]
											[T -> org.cf.util.ClassNameUtils{ImportPackage} : ImportDeclaration "import org.cf.util.ClassNameUtils;" compose:Replacement merge: Default]
											[T -> org.jf.dexlib2.iface.ClassDef{ImportPackage} : ImportDeclaration "import org.jf.dexlib2.iface.ClassDef;" compose:Replacement merge: Default]
											[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
											[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
											[NT -> SmaliClassLoader : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> SmaliClassLoader : Id "SmaliClassLoader" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends ClassLoader" compose:Replacement merge: Default]
												[T -> log : FieldDecl "private static final Logger log = LoggerFactory.getLogger(SmaliClassLoader.class.getSimpleName());" compose:Replacement merge: SemanticConflict]
												[T -> FRAMEWORK_STUBS_JAR : FieldDecl "private static final String FRAMEWORK_STUBS_JAR = "/framework/framework-17.jar";" compose:Replacement merge: SemanticConflict]
												[T -> cachedClasses : FieldDecl "private Map<String, Class<?>> cachedClasses;" compose:Replacement merge: SemanticConflict]
												[T -> classBuilder : FieldDecl "private final ClassBuilder classBuilder;" compose:Replacement merge: SemanticConflict]
												[T -> classManager : FieldDecl "private final ClassManager classManager;" compose:Replacement merge: SemanticConflict]
												[T -> jarLoader : FieldDecl "private URLClassLoader jarLoader;" compose:Replacement merge: SemanticConflict]
												[T -> SmaliClassLoader(ClassManager-ClassManager) : ConstructorDecl "public SmaliClassLoader(ClassManager classManager) {         super(SmaliClassLoader.class.getClassLoader());         cachedClasses = new HashMap<String, Class<?>>();         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);         jarLoader = new URLClassLoader(new URL[] { jarURL });         this.classBuilder = new ClassBuilder(classManager, jarLoader);         this.classManager = classManager;     }" compose:Replacement merge: LineBased]
												[T -> loadClassWithoutBuilding(String-String) : MethodDecl "private @Nullable Class<?> loadClassWithoutBuilding(String name) {         Class<?> klazz = null;         klazz = findLoadedClass(name);         if (klazz != null) {             return klazz;         }          try {             klazz = super.loadClass(name);             if (klazz != null) {                 return klazz;             }         } catch (Exception e) {             e.printStackTrace();         }          klazz = findClass(name);         if (klazz != null) {             return klazz;         }          return null;     }" compose:Replacement merge: LineBased]
												[T -> findClass(String-String) : MethodDecl "@Override     protected Class<?> findClass(String name) {         try {             return jarLoader.loadClass(name);         } catch (ClassNotFoundException e) {         }          if (classBuilder.isShallowClass(name)) {             return null;         }          return cachedClasses.get(name);     }" compose:Replacement merge: LineBased]
												[T -> filterAvailableClasses(Set<String>-Set<String>) : MethodDecl "private void filterAvailableClasses(Set<String> classNames) {         Iterator<String> iter = classNames.iterator();         while (iter.hasNext()) {             String className = iter.next();             String baseName = ClassNameUtils.getComponentBase(className);             String binaryName = ClassNameUtils.internalToBinary(baseName);             if (loadClassWithoutBuilding(binaryName) != null) {                 iter.remove();             }         }     }" compose:Replacement merge: LineBased]
												[T -> loadClass(String-String) : MethodDecl "@Override     public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {         Class<?> klazz = loadClassWithoutBuilding(name);         if (klazz != null) {             return klazz;         }          ClassDef classDef = classManager.getClass(ClassNameUtils.binaryToInternal(name));         Set<String> classNames = ClassDependencyCollector.collect(classDef);         filterAvailableClasses(classNames);         Map<String, Class<?>> newClasses = classBuilder.build(classNames);         cachedClasses.putAll(newClasses);          // if (cachedClasses.isEmpty()) {         // Set<String> classNames = classManager.getNonFrameworkClassNames();         // classNames.clear();         // classNames.add(name);         // If I don't set this to null first, cachedClasses does not update.         // VERY VERY STRANGE         // cachedClasses = null;         // cachedClasses = classBuilder.build(classNames);         // }          klazz = findClass(name);         if (klazz == null) {             throw new ClassNotFoundException(name);         }          return klazz;     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> smalivm : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> cf : Folder]
							[NT -> smalivm : Folder]
								[NT -> smali : Folder]
									[NT -> SmaliClassLoader.java.merge : .java.merge-File]
										[T -> SmaliClassLoader.java : .java-Content "package org.cf.smalivm.smali;  import java.net.URL; import java.net.URLClassLoader; import java.util.HashMap; import java.util.Map;  import org.cf.util.ClassNameUtils; import org.jf.dexlib2.iface.ClassDef; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class SmaliClassLoader extends ClassLoader {      private static final Logger log = LoggerFactory.getLogger(SmaliClassLoader.class.getSimpleName());      private static final String FRAMEWORK_STUBS_JAR = "/framework/android-23.jar";      private static final Map<String, Class<?>> cachedClasses = new HashMap<String, Class<?>>();     private final ClassBuilder classBuilder;     private final ClassManager classManager;     private final URLClassLoader jarLoader;      public SmaliClassLoader(ClassManager classManager) {         super(SmaliClassLoader.class.getClassLoader());         // cachedClasses = new HashMap<String, Class<?>>();         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);         jarLoader = new URLClassLoader(new URL[] { jarURL });         this.classBuilder = new ClassBuilder();         this.classManager = classManager;     }      @Override     protected Class<?> findClass(String name) throws ClassNotFoundException {         try {             return super.findClass(name);         } catch (ClassNotFoundException e) {         }          if (name.startsWith("java.")) {             log.warn("Unable to load prohibited class name: {}\nThis error is likely the result of using a class which references a java.* class only available on Android. There's no work-around at this time since loading protected classes is a huge pain.",                             name);             throw new ClassNotFoundException(name);         }          // try {         // return jarLoader.loadClass(name);         // } catch (ClassNotFoundException e) {         // }          Class<?> klazz = cachedClasses.get(name);         if (klazz != null) {             return klazz;         }          String internalName = ClassNameUtils.binaryToInternal(name);         if (!classManager.isLocalClass(internalName)) {             throw new ClassNotFoundException(name);         }          ClassDef classDef = classManager.getClass(internalName);         byte[] b = classBuilder.build(classDef);         klazz = defineClass(name, b, 0, b.length);         cachedClasses.put(name, klazz);          // No one ever tells you this is also necessary, or you'll have null package for the class:         String packageName = getPackageName(name);         if (packageName != null && getPackage(packageName) == null) {             definePackage(getPackageName(name), null, null, null, null, null, null, null);         }          return klazz;     }      private static String getPackageName(String className) {         int i = className.lastIndexOf('.');         if (i > 0) {             return className.substring(0, i);         } else {             // No package name, e.g. LsomeClass;             return null;         }     }  } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> smalivm : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> cf : Folder]
							[NT -> smalivm : Folder]
								[NT -> smali : Folder]
									[NT -> SmaliClassLoader.java.merge : .java.merge-File]
										[T -> SmaliClassLoader.java : .java-Content "package org.cf.smalivm.smali;  import java.net.URL; import java.net.URLClassLoader; import java.util.HashMap; import java.util.Map; import java.util.Set;  import javax.annotation.Nullable;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class SmaliClassLoader extends ClassLoader {      private static final Logger log = LoggerFactory.getLogger(SmaliClassLoader.class.getSimpleName());      private static final String FRAMEWORK_STUBS_JAR = "/framework/framework-17.jar";      private Map<String, Class<?>> cachedClasses;     private final ClassBuilder classBuilder;     private final ClassManager classManager;     private URLClassLoader jarLoader;      public SmaliClassLoader(ClassManager classManager) {         super(SmaliClassLoader.class.getClassLoader());         cachedClasses = new HashMap<String, Class<?>>();         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);         jarLoader = new URLClassLoader(new URL[] { jarURL });         this.classBuilder = new ClassBuilder(classManager, jarLoader);         this.classManager = classManager;     }      private @Nullable Class<?> loadClassWithoutBuilding(String name) {         Class<?> klazz = null;         klazz = findLoadedClass(name);         if (klazz != null) {             return klazz;         }          try {             klazz = super.loadClass(name);             if (klazz != null) {                 return klazz;             }         } catch (Exception e) {             e.printStackTrace();         }          klazz = findClass(name);         if (klazz != null) {             return klazz;         }          return null;     }      @Override     protected Class<?> findClass(String name) {         try {             return jarLoader.loadClass(name);         } catch (ClassNotFoundException e) {         }          if (classBuilder.isShallowClass(name)) {             return null;         }          return cachedClasses.get(name);     }      @Override     public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {         Class<?> klazz = loadClassWithoutBuilding(name);         if (klazz != null) {             return klazz;         }          if (cachedClasses.isEmpty()) {             Set<String> classNames = classManager.getNonFrameworkClassNames();             // If I don't set this to null first, cachedClasses does not update.             // VERY VERY STRANGE             cachedClasses = null;             cachedClasses = classBuilder.build(classNames);         }          klazz = findClass(name);         if (klazz == null) {             throw new ClassNotFoundException(name);         }          return klazz;     }  } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> smalivm : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> cf : Folder]
							[NT -> smalivm : Folder]
								[NT -> smali : Folder]
									[NT -> SmaliClassLoader.java.merge : .java.merge-File]
										[T -> SmaliClassLoader.java : .java-Content "package org.cf.smalivm.smali;  import java.net.URL; import java.net.URLClassLoader; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  import javax.annotation.Nullable;  import org.cf.util.ClassNameUtils; import org.jf.dexlib2.iface.ClassDef; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  public class SmaliClassLoader extends ClassLoader {      private static final Logger log = LoggerFactory.getLogger(SmaliClassLoader.class.getSimpleName());      private static final String FRAMEWORK_STUBS_JAR = "/framework/framework-17.jar";      private Map<String, Class<?>> cachedClasses;     private final ClassBuilder classBuilder;     private final ClassManager classManager;     private URLClassLoader jarLoader;      public SmaliClassLoader(ClassManager classManager) {         super(SmaliClassLoader.class.getClassLoader());         cachedClasses = new HashMap<String, Class<?>>();         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);         jarLoader = new URLClassLoader(new URL[] { jarURL });         this.classBuilder = new ClassBuilder(classManager, jarLoader);         this.classManager = classManager;     }      private @Nullable Class<?> loadClassWithoutBuilding(String name) {         Class<?> klazz = null;         klazz = findLoadedClass(name);         if (klazz != null) {             return klazz;         }          try {             klazz = super.loadClass(name);             if (klazz != null) {                 return klazz;             }         } catch (Exception e) {             e.printStackTrace();         }          klazz = findClass(name);         if (klazz != null) {             return klazz;         }          return null;     }      @Override     protected Class<?> findClass(String name) {         try {             return jarLoader.loadClass(name);         } catch (ClassNotFoundException e) {         }          if (classBuilder.isShallowClass(name)) {             return null;         }          return cachedClasses.get(name);     }      private void filterAvailableClasses(Set<String> classNames) {         Iterator<String> iter = classNames.iterator();         while (iter.hasNext()) {             String className = iter.next();             String baseName = ClassNameUtils.getComponentBase(className);             String binaryName = ClassNameUtils.internalToBinary(baseName);             if (loadClassWithoutBuilding(binaryName) != null) {                 iter.remove();             }         }     }      @Override     public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {         Class<?> klazz = loadClassWithoutBuilding(name);         if (klazz != null) {             return klazz;         }          ClassDef classDef = classManager.getClass(ClassNameUtils.binaryToInternal(name));         Set<String> classNames = ClassDependencyCollector.collect(classDef);         filterAvailableClasses(classNames);         Map<String, Class<?>> newClasses = classBuilder.build(classNames);         cachedClasses.putAll(newClasses);          // if (cachedClasses.isEmpty()) {         // Set<String> classNames = classManager.getNonFrameworkClassNames();         // classNames.clear();         // classNames.add(name);         // If I don't set this to null first, cachedClasses does not update.         // VERY VERY STRANGE         // cachedClasses = null;         // cachedClasses = classBuilder.build(classNames);         // }          klazz = findClass(name);         if (klazz == null) {             throw new ClassNotFoundException(name);         }          return klazz;     }  } " compose:StringConcatenation merge: LineBased]
