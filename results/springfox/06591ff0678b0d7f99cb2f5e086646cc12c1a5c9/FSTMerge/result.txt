Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/springfox-swagger2/src/main/java/springfox/documentation/swagger2/mappers/ModelMapper.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/springfox-swagger2/src/main/java/springfox/documentation/swagger2/mappers/ModelMapper.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/springfox-swagger2/src/main/java/springfox/documentation/swagger2/mappers/ModelMapper.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/springfox-swagger2/src/main/java/springfox/documentation/swagger2/mappers/ModelMapper.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/springfox-swagger2/src/main/java/springfox/documentation/swagger2/mappers/ModelMapper.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/springfox-swagger2/src/main/java/springfox/documentation/swagger2/mappers/ModelMapper.java
[NT -> left : Feature]
	[NT -> springfox-swagger2 : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> springfox : Folder]
						[NT -> documentation : Folder]
							[NT -> swagger2 : Folder]
								[NT -> mappers : Folder]
									[NT -> ModelMapper.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package springfox.documentation.swagger2.mappers;" compose:Replacement merge: Default]
											[T -> com.fasterxml.classmate.ResolvedType{ImportPackage} : ImportDeclaration "import com.fasterxml.classmate.ResolvedType;" compose:Replacement merge: Default]
											[T -> com.fasterxml.classmate.types.ResolvedInterfaceType{ImportPackage} : ImportDeclaration "import com.fasterxml.classmate.types.ResolvedInterfaceType;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Function{ImportPackage} : ImportDeclaration "import com.google.common.base.Function;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Optional{ImportPackage} : ImportDeclaration "import com.google.common.base.Optional;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Predicate{ImportPackage} : ImportDeclaration "import com.google.common.base.Predicate;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.FluentIterable{ImportPackage} : ImportDeclaration "import com.google.common.collect.FluentIterable;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Multimap{ImportPackage} : ImportDeclaration "import com.google.common.collect.Multimap;" compose:Replacement merge: Default]
											[T -> io.swagger.models.Model{ImportPackage} : ImportDeclaration "import io.swagger.models.Model;" compose:Replacement merge: Default]
											[T -> io.swagger.models.ModelImpl{ImportPackage} : ImportDeclaration "import io.swagger.models.ModelImpl;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.AbstractNumericProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.AbstractNumericProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.ArrayProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.ArrayProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.MapProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.MapProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.ObjectProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.ObjectProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.Property{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.Property;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.StringProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.StringProperty;" compose:Replacement merge: Default]
											[T -> org.mapstruct.Mapper{ImportPackage} : ImportDeclaration "import org.mapstruct.Mapper;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.ModelProperty{ImportPackage} : ImportDeclaration "import springfox.documentation.schema.ModelProperty;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.ModelRef{ImportPackage} : ImportDeclaration "import springfox.documentation.schema.ModelRef;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableListValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableListValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableRangeValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableRangeValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.ApiListing{ImportPackage} : ImportDeclaration "import springfox.documentation.service.ApiListing;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.TreeMap{ImportPackage} : ImportDeclaration "import java.util.TreeMap;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Maps.* : ImportDeclaration "import static com.google.common.collect.Maps.*;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.Maps.* : ImportDeclaration "import static springfox.documentation.schema.Maps.*;" compose:Replacement merge: Default]
											[T -> springfox.documentation.swagger2.mappers.Properties.* : ImportDeclaration "import static springfox.documentation.swagger2.mappers.Properties.*;" compose:Replacement merge: Default]
											[NT -> ModelMapper : ClassDeclaration]
												[T -> - : Modifiers "@Mapper public abstract" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> ModelMapper : Id "ModelMapper" compose:Replacement merge: Default]
												[T -> mapModels(Map<String,springfox.documentation.schema.Model>-Map<String,springfox.documentation.schema.Model>) : MethodDecl "public Map<String, Model> mapModels(Map<String, springfox.documentation.schema.Model> from) {     if (from == null) {       return null;     }      Map<String, Model> map = new HashMap<String, Model>();      for (java.util.Map.Entry<String, springfox.documentation.schema.Model> entry : from.entrySet()) {       String key = entry.getKey();       Model value = mapProperties(entry.getValue());       map.put(key, value);     }      return map;   }" compose:Replacement merge: LineBased]
												[T -> mapProperties(springfox.documentation.schema.Model-springfox.documentation.schema.Model) : MethodDecl "public Model mapProperties(springfox.documentation.schema.Model source) {      ModelImpl model = new ModelImpl()         .description(source.getDescription())         .discriminator(source.getDiscriminator())         .example("")         .name(source.getName());     TreeMap<String, Property> sorted = newTreeMap();     sorted.putAll(mapProperties(source.getProperties()));     model.setProperties(sorted);     FluentIterable<String> requiredFields = FluentIterable.from(source.getProperties().values())         .filter(requiredProperty())         .transform(propertyName());     model.setRequired(requiredFields.toList());     model.setSimple(false);     if (isInterface(source.getType())) {       model.setType(ModelImpl.OBJECT);     }     if (isMapType(source.getType())) {       Optional<Class> clazz = typeOfValue(source);       if (clazz.isPresent()) {         model.additionalProperties(property(clazz.get().getSimpleName()));       } else {         model.additionalProperties(new ObjectProperty());       }     }     return model;   }" compose:Replacement merge: LineBased]
												[T -> isInterface(ResolvedType-ResolvedType) : MethodDecl "private boolean isInterface(ResolvedType type) {     return type instanceof ResolvedInterfaceType;   }" compose:Replacement merge: LineBased]
												[T -> typeOfValue(springfox.documentation.schema.Model-springfox.documentation.schema.Model) : MethodDecl "private Optional<Class> typeOfValue(springfox.documentation.schema.Model source) {     if (source.getType().getTypeParameters() != null && source.getType().getTypeParameters().size() > 0) {       return Optional.of((Class)source.getType().getTypeParameters().get(1).getErasedType());     }     return Optional.absent();   }" compose:Replacement merge: LineBased]
												[T -> mapProperty(ModelProperty-ModelProperty) : MethodDecl "public Property mapProperty(ModelProperty source) {     Property property = modelRefToProperty(source.getModelRef());      addEnumValues(property, source.getAllowableValues());      if (property instanceof ArrayProperty) {       ArrayProperty arrayProperty = (ArrayProperty) property;       addEnumValues(arrayProperty.getItems(), source.getAllowableValues());     }      if (property instanceof AbstractNumericProperty) {       AllowableValues allowableValues = source.getAllowableValues();       if (allowableValues instanceof AllowableRangeValues) {         AllowableRangeValues range = (AllowableRangeValues) allowableValues;         ((AbstractNumericProperty) property).maximum(Double.valueOf(range.getMax()));         ((AbstractNumericProperty) property).minimum(Double.valueOf(range.getMin()));       }     }     if (property != null) {       property.setDescription(source.getDescription());       property.setName(source.getName());       property.setRequired(source.isRequired());       property.setReadOnly(source.isReadOnly());     }     return property;   }" compose:Replacement merge: LineBased]
												[T -> addEnumValues(Property-Property-AllowableValues-AllowableValues) : MethodDecl "private static Property addEnumValues(Property property, AllowableValues allowableValues) {     if (property instanceof StringProperty && allowableValues instanceof AllowableListValues) {       StringProperty stringProperty = (StringProperty) property;       AllowableListValues listValues = (AllowableListValues) allowableValues;       stringProperty.setEnum(listValues.getValues());     }     return property;   }" compose:Replacement merge: LineBased]
												[T -> modelRefToProperty(ModelRef-ModelRef) : MethodDecl "static Property modelRefToProperty(ModelRef modelRef) {     if (modelRef == null || "void".equalsIgnoreCase(modelRef.getType())) {       return null;     }     Property responseProperty;     if (modelRef.isCollection()) {       String itemType = modelRef.getItemType();       responseProperty = new ArrayProperty(addEnumValues(property(itemType), modelRef.getAllowableValues()));     } else if (modelRef.isMap()) {       String itemType = modelRef.getItemType();       responseProperty = new MapProperty(property(itemType));     } else {       responseProperty = property(modelRef.getType());     }      addEnumValues(responseProperty, modelRef.getAllowableValues());      return responseProperty;   }" compose:Replacement merge: LineBased]
												[T -> modelsFromApiListings(Multimap<String,ApiListing>-Multimap<String,ApiListing>) : MethodDecl "protected Map<String, Model> modelsFromApiListings(Multimap<String, ApiListing> apiListings) {     Map<String, springfox.documentation.schema.Model> definitions = newHashMap();     for (ApiListing each : apiListings.values()) {       definitions.putAll(each.getModels());     }     return mapModels(definitions);   }" compose:Replacement merge: LineBased]
												[T -> mapProperties(Map<String,ModelProperty>-Map<String,ModelProperty>) : MethodDecl "protected abstract Map<String, Property> mapProperties(Map<String, ModelProperty> properties);" compose:Replacement merge: LineBased]
												[T -> propertyName({FormalParametersInternal}) : MethodDecl "private Function<ModelProperty, String> propertyName() {     return new Function<ModelProperty, String>() {       @Override       public String apply(ModelProperty input) {         return input.getName();       }     };   }" compose:Replacement merge: LineBased]
												[T -> requiredProperty({FormalParametersInternal}) : MethodDecl "private Predicate<ModelProperty> requiredProperty() {     return new Predicate<ModelProperty>() {       @Override       public boolean apply(ModelProperty input) {         return input.isRequired();       }     };   }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> springfox-swagger2 : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> springfox : Folder]
						[NT -> documentation : Folder]
							[NT -> swagger2 : Folder]
								[NT -> mappers : Folder]
									[NT -> ModelMapper.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package springfox.documentation.swagger2.mappers;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Function{ImportPackage} : ImportDeclaration "import com.google.common.base.Function;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Optional{ImportPackage} : ImportDeclaration "import com.google.common.base.Optional;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Predicate{ImportPackage} : ImportDeclaration "import com.google.common.base.Predicate;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.FluentIterable{ImportPackage} : ImportDeclaration "import com.google.common.collect.FluentIterable;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Multimap{ImportPackage} : ImportDeclaration "import com.google.common.collect.Multimap;" compose:Replacement merge: Default]
											[T -> io.swagger.models.Model{ImportPackage} : ImportDeclaration "import io.swagger.models.Model;" compose:Replacement merge: Default]
											[T -> io.swagger.models.ModelImpl{ImportPackage} : ImportDeclaration "import io.swagger.models.ModelImpl;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.AbstractNumericProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.AbstractNumericProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.ArrayProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.ArrayProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.MapProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.MapProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.ObjectProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.ObjectProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.Property{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.Property;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.StringProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.StringProperty;" compose:Replacement merge: Default]
											[T -> org.mapstruct.Mapper{ImportPackage} : ImportDeclaration "import org.mapstruct.Mapper;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.ModelProperty{ImportPackage} : ImportDeclaration "import springfox.documentation.schema.ModelProperty;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.ModelRef{ImportPackage} : ImportDeclaration "import springfox.documentation.schema.ModelRef;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableListValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableListValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableRangeValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableRangeValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.ApiListing{ImportPackage} : ImportDeclaration "import springfox.documentation.service.ApiListing;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.TreeMap{ImportPackage} : ImportDeclaration "import java.util.TreeMap;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Maps.* : ImportDeclaration "import static com.google.common.collect.Maps.*;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.Maps.* : ImportDeclaration "import static springfox.documentation.schema.Maps.*;" compose:Replacement merge: Default]
											[T -> springfox.documentation.swagger2.mappers.Properties.* : ImportDeclaration "import static springfox.documentation.swagger2.mappers.Properties.*;" compose:Replacement merge: Default]
											[NT -> ModelMapper : ClassDeclaration]
												[T -> - : Modifiers "@Mapper public abstract" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> ModelMapper : Id "ModelMapper" compose:Replacement merge: Default]
												[T -> mapModels(Map<String,springfox.documentation.schema.Model>-Map<String,springfox.documentation.schema.Model>) : MethodDecl "public Map<String, Model> mapModels(Map<String, springfox.documentation.schema.Model> from) {     if (from == null) {       return null;     }      Map<String, Model> map = new HashMap<String, Model>();      for (java.util.Map.Entry<String, springfox.documentation.schema.Model> entry : from.entrySet()) {       String key = entry.getKey();       Model value = mapProperties(entry.getValue());       map.put(key, value);     }      return map;   }" compose:Replacement merge: LineBased]
												[T -> mapProperties(springfox.documentation.schema.Model-springfox.documentation.schema.Model) : MethodDecl "public Model mapProperties(springfox.documentation.schema.Model source) {      ModelImpl model = new ModelImpl()         .description(source.getDescription())         .discriminator(source.getDiscriminator())         .example("")         .name(source.getName());     TreeMap<String, Property> sorted = newTreeMap();     sorted.putAll(mapProperties(source.getProperties()));     model.setProperties(sorted);     FluentIterable<String> requiredFields = FluentIterable.from(source.getProperties().values())         .filter(requiredProperty())         .transform(propertyName());     model.setRequired(requiredFields.toList());     model.setSimple(false);     if (isMapType(source.getType())) {       Optional<Class> clazz = typeOfValue(source);       if (clazz.isPresent()) {         model.additionalProperties(property(clazz.get().getSimpleName()));       } else {         model.additionalProperties(new ObjectProperty());       }     }     return model;   }" compose:Replacement merge: LineBased]
												[T -> typeOfValue(springfox.documentation.schema.Model-springfox.documentation.schema.Model) : MethodDecl "private Optional<Class> typeOfValue(springfox.documentation.schema.Model source) {     if (source.getType().getTypeParameters() != null && source.getType().getTypeParameters().size() > 0) {       return Optional.of((Class)source.getType().getTypeParameters().get(1).getErasedType());     }     return Optional.absent();   }" compose:Replacement merge: LineBased]
												[T -> mapProperty(ModelProperty-ModelProperty) : MethodDecl "public Property mapProperty(ModelProperty source) {     Property property = modelRefToProperty(source.getModelRef());      addEnumValues(property, source.getAllowableValues());      if (property instanceof ArrayProperty) {       ArrayProperty arrayProperty = (ArrayProperty) property;       addEnumValues(arrayProperty.getItems(), source.getAllowableValues());     }      if (property instanceof AbstractNumericProperty) {       AllowableValues allowableValues = source.getAllowableValues();       if (allowableValues instanceof AllowableRangeValues) {         AllowableRangeValues range = (AllowableRangeValues) allowableValues;         ((AbstractNumericProperty) property).maximum(Double.valueOf(range.getMax()));         ((AbstractNumericProperty) property).minimum(Double.valueOf(range.getMin()));       }     }     if (property != null) {       property.setDescription(source.getDescription());       property.setName(source.getName());       property.setRequired(source.isRequired());       property.setReadOnly(source.isReadOnly());     }     return property;   }" compose:Replacement merge: LineBased]
												[T -> addEnumValues(Property-Property-AllowableValues-AllowableValues) : MethodDecl "private static Property addEnumValues(Property property, AllowableValues allowableValues) {     if (property instanceof StringProperty && allowableValues instanceof AllowableListValues) {       StringProperty stringProperty = (StringProperty) property;       AllowableListValues listValues = (AllowableListValues) allowableValues;       stringProperty.setEnum(listValues.getValues());     }     return property;   }" compose:Replacement merge: LineBased]
												[T -> modelRefToProperty(ModelRef-ModelRef) : MethodDecl "static Property modelRefToProperty(ModelRef modelRef) {     if (modelRef == null || "void".equalsIgnoreCase(modelRef.getType())) {       return null;     }     Property responseProperty;     if (modelRef.isCollection()) {       String itemType = modelRef.getItemType();       responseProperty = new ArrayProperty(addEnumValues(property(itemType), modelRef.getAllowableValues()));     } else if (modelRef.isMap()) {       String itemType = modelRef.getItemType();       responseProperty = new MapProperty(property(itemType));     } else {       responseProperty = property(modelRef.getType());     }      addEnumValues(responseProperty, modelRef.getAllowableValues());      return responseProperty;   }" compose:Replacement merge: LineBased]
												[T -> modelsFromApiListings(Multimap<String,ApiListing>-Multimap<String,ApiListing>) : MethodDecl "protected Map<String, Model> modelsFromApiListings(Multimap<String, ApiListing> apiListings) {     Map<String, springfox.documentation.schema.Model> definitions = newHashMap();     for (ApiListing each : apiListings.values()) {       definitions.putAll(each.getModels());     }     return mapModels(definitions);   }" compose:Replacement merge: LineBased]
												[T -> mapProperties(Map<String,ModelProperty>-Map<String,ModelProperty>) : MethodDecl "protected abstract Map<String, Property> mapProperties(Map<String, ModelProperty> properties);" compose:Replacement merge: LineBased]
												[T -> propertyName({FormalParametersInternal}) : MethodDecl "private Function<ModelProperty, String> propertyName() {     return new Function<ModelProperty, String>() {       @Override       public String apply(ModelProperty input) {         return input.getName();       }     };   }" compose:Replacement merge: LineBased]
												[T -> requiredProperty({FormalParametersInternal}) : MethodDecl "private Predicate<ModelProperty> requiredProperty() {     return new Predicate<ModelProperty>() {       @Override       public boolean apply(ModelProperty input) {         return input.isRequired();       }     };   }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> springfox-swagger2 : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> springfox : Folder]
						[NT -> documentation : Folder]
							[NT -> swagger2 : Folder]
								[NT -> mappers : Folder]
									[NT -> ModelMapper.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package springfox.documentation.swagger2.mappers;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Maps.newHashMap{ImportPackage} : ImportDeclaration "import static com.google.common.collect.Maps.newHashMap;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Maps.newTreeMap{ImportPackage} : ImportDeclaration "import static com.google.common.collect.Maps.newTreeMap;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.Maps.isMapType{ImportPackage} : ImportDeclaration "import static springfox.documentation.schema.Maps.isMapType;" compose:Replacement merge: Default]
											[T -> springfox.documentation.swagger2.mappers.Properties.property{ImportPackage} : ImportDeclaration "import static springfox.documentation.swagger2.mappers.Properties.property;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.TreeMap{ImportPackage} : ImportDeclaration "import java.util.TreeMap;" compose:Replacement merge: Default]
											[T -> org.mapstruct.Mapper{ImportPackage} : ImportDeclaration "import org.mapstruct.Mapper;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Function{ImportPackage} : ImportDeclaration "import com.google.common.base.Function;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Optional{ImportPackage} : ImportDeclaration "import com.google.common.base.Optional;" compose:Replacement merge: Default]
											[T -> com.google.common.base.Predicate{ImportPackage} : ImportDeclaration "import com.google.common.base.Predicate;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.FluentIterable{ImportPackage} : ImportDeclaration "import com.google.common.collect.FluentIterable;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Multimap{ImportPackage} : ImportDeclaration "import com.google.common.collect.Multimap;" compose:Replacement merge: Default]
											[T -> io.swagger.models.Model{ImportPackage} : ImportDeclaration "import io.swagger.models.Model;" compose:Replacement merge: Default]
											[T -> io.swagger.models.ModelImpl{ImportPackage} : ImportDeclaration "import io.swagger.models.ModelImpl;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.AbstractNumericProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.AbstractNumericProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.ArrayProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.ArrayProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.MapProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.MapProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.ObjectProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.ObjectProperty;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.Property{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.Property;" compose:Replacement merge: Default]
											[T -> io.swagger.models.properties.StringProperty{ImportPackage} : ImportDeclaration "import io.swagger.models.properties.StringProperty;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.ModelProperty{ImportPackage} : ImportDeclaration "import springfox.documentation.schema.ModelProperty;" compose:Replacement merge: Default]
											[T -> springfox.documentation.schema.ModelRef{ImportPackage} : ImportDeclaration "import springfox.documentation.schema.ModelRef;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableListValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableListValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableRangeValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableRangeValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.AllowableValues{ImportPackage} : ImportDeclaration "import springfox.documentation.service.AllowableValues;" compose:Replacement merge: Default]
											[T -> springfox.documentation.service.ApiListing{ImportPackage} : ImportDeclaration "import springfox.documentation.service.ApiListing;" compose:Replacement merge: Default]
											[NT -> ModelMapper : ClassDeclaration]
												[T -> - : Modifiers "@Mapper public abstract" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> ModelMapper : Id "ModelMapper" compose:Replacement merge: Default]
												[T -> mapModels(Map<String,springfox.documentation.schema.Model>-Map<String,springfox.documentation.schema.Model>) : MethodDecl "public Map<String, Model> mapModels(Map<String, springfox.documentation.schema.Model> from) {     if (from == null) {       return null;     }      Map<String, Model> map = new HashMap<String, Model>();      for (java.util.Map.Entry<String, springfox.documentation.schema.Model> entry : from.entrySet()) {       String key = entry.getKey();       Model value = mapProperties(entry.getValue());       map.put(key, value);     }      return map;   }" compose:Replacement merge: LineBased]
												[T -> mapProperties(springfox.documentation.schema.Model-springfox.documentation.schema.Model) : MethodDecl "public Model mapProperties(springfox.documentation.schema.Model source) {      ModelImpl model = new ModelImpl()         .description(source.getDescription())         .discriminator(source.getDiscriminator())         .example(source.getExample())         .name(source.getName());     TreeMap<String, Property> sorted = newTreeMap();     sorted.putAll(mapProperties(source.getProperties()));     model.setProperties(sorted);     FluentIterable<String> requiredFields = FluentIterable.from(source.getProperties().values())         .filter(requiredProperty())         .transform(propertyName());     model.setRequired(requiredFields.toList());     model.setSimple(false);     if (isMapType(source.getType())) {       Optional<Class> clazz = typeOfValue(source);       if (clazz.isPresent()) {         model.additionalProperties(property(clazz.get().getSimpleName()));       } else {         model.additionalProperties(new ObjectProperty());       }     }     return model;   }" compose:Replacement merge: LineBased]
												[T -> typeOfValue(springfox.documentation.schema.Model-springfox.documentation.schema.Model) : MethodDecl "private Optional<Class> typeOfValue(springfox.documentation.schema.Model source) {     if (source.getType().getTypeParameters() != null && source.getType().getTypeParameters().size() > 0) {       return Optional.of((Class)source.getType().getTypeParameters().get(1).getErasedType());     }     return Optional.absent();   }" compose:Replacement merge: LineBased]
												[T -> mapProperty(ModelProperty-ModelProperty) : MethodDecl "public Property mapProperty(ModelProperty source) {     Property property = modelRefToProperty(source.getModelRef());      addEnumValues(property, source.getAllowableValues());      if (property instanceof ArrayProperty) {       ArrayProperty arrayProperty = (ArrayProperty) property;       addEnumValues(arrayProperty.getItems(), source.getAllowableValues());     }      if (property instanceof AbstractNumericProperty) {       AllowableValues allowableValues = source.getAllowableValues();       if (allowableValues instanceof AllowableRangeValues) {         AllowableRangeValues range = (AllowableRangeValues) allowableValues;         ((AbstractNumericProperty) property).maximum(Double.valueOf(range.getMax()));         ((AbstractNumericProperty) property).minimum(Double.valueOf(range.getMin()));       }     }     if (property != null) {       property.setDescription(source.getDescription());       property.setName(source.getName());       property.setRequired(source.isRequired());       property.setReadOnly(source.isReadOnly());       property.setExample(source.getExample());     }     return property;   }" compose:Replacement merge: LineBased]
												[T -> addEnumValues(Property-Property-AllowableValues-AllowableValues) : MethodDecl "private static Property addEnumValues(Property property, AllowableValues allowableValues) {     if (property instanceof StringProperty && allowableValues instanceof AllowableListValues) {       StringProperty stringProperty = (StringProperty) property;       AllowableListValues listValues = (AllowableListValues) allowableValues;       stringProperty.setEnum(listValues.getValues());     }     return property;   }" compose:Replacement merge: LineBased]
												[T -> modelRefToProperty(ModelRef-ModelRef) : MethodDecl "static Property modelRefToProperty(ModelRef modelRef) {     if (modelRef == null || "void".equalsIgnoreCase(modelRef.getType())) {       return null;     }     Property responseProperty;     if (modelRef.isCollection()) {       String itemType = modelRef.getItemType();       responseProperty = new ArrayProperty(addEnumValues(property(itemType), modelRef.getAllowableValues()));     } else if (modelRef.isMap()) {       String itemType = modelRef.getItemType();       responseProperty = new MapProperty(property(itemType));     } else {       responseProperty = property(modelRef.getType());     }      addEnumValues(responseProperty, modelRef.getAllowableValues());      return responseProperty;   }" compose:Replacement merge: LineBased]
												[T -> modelsFromApiListings(Multimap<String,ApiListing>-Multimap<String,ApiListing>) : MethodDecl "protected Map<String, Model> modelsFromApiListings(Multimap<String, ApiListing> apiListings) {     Map<String, springfox.documentation.schema.Model> definitions = newHashMap();     for (ApiListing each : apiListings.values()) {       definitions.putAll(each.getModels());     }     return mapModels(definitions);   }" compose:Replacement merge: LineBased]
												[T -> mapProperties(Map<String,ModelProperty>-Map<String,ModelProperty>) : MethodDecl "protected abstract Map<String, Property> mapProperties(Map<String, ModelProperty> properties);" compose:Replacement merge: LineBased]
												[T -> propertyName({FormalParametersInternal}) : MethodDecl "private Function<ModelProperty, String> propertyName() {     return new Function<ModelProperty, String>() {       @Override       public String apply(ModelProperty input) {         return input.getName();       }     };   }" compose:Replacement merge: LineBased]
												[T -> requiredProperty({FormalParametersInternal}) : MethodDecl "private Predicate<ModelProperty> requiredProperty() {     return new Predicate<ModelProperty>() {       @Override       public boolean apply(ModelProperty input) {         return input.isRequired();       }     };   }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> springfox-swagger2 : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> springfox : Folder]
						[NT -> documentation : Folder]
							[NT -> swagger2 : Folder]
								[NT -> mappers : Folder]
									[NT -> ModelMapper.java.merge : .java.merge-File]
										[T -> ModelMapper.java : .java-Content "/*  *  *  Copyright 2015 the original author or authors.  *  *  Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *         http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  *  */  package springfox.documentation.swagger2.mappers;  import com.fasterxml.classmate.ResolvedType; import com.fasterxml.classmate.types.ResolvedInterfaceType; import com.google.common.base.Function; import com.google.common.base.Optional; import com.google.common.base.Predicate; import com.google.common.collect.FluentIterable; import com.google.common.collect.Multimap; import io.swagger.models.Model; import io.swagger.models.ModelImpl; import io.swagger.models.properties.AbstractNumericProperty; import io.swagger.models.properties.ArrayProperty; import io.swagger.models.properties.MapProperty; import io.swagger.models.properties.ObjectProperty; import io.swagger.models.properties.Property; import io.swagger.models.properties.StringProperty; import org.mapstruct.Mapper; import springfox.documentation.schema.ModelProperty; import springfox.documentation.schema.ModelRef; import springfox.documentation.service.AllowableListValues; import springfox.documentation.service.AllowableRangeValues; import springfox.documentation.service.AllowableValues; import springfox.documentation.service.ApiListing;  import java.util.HashMap; import java.util.Map; import java.util.TreeMap;  import static com.google.common.collect.Maps.*; import static springfox.documentation.schema.Maps.*; import static springfox.documentation.swagger2.mappers.Properties.*;  @Mapper public abstract class ModelMapper {   public Map<String, Model> mapModels(Map<String, springfox.documentation.schema.Model> from) {     if (from == null) {       return null;     }      Map<String, Model> map = new HashMap<String, Model>();      for (java.util.Map.Entry<String, springfox.documentation.schema.Model> entry : from.entrySet()) {       String key = entry.getKey();       Model value = mapProperties(entry.getValue());       map.put(key, value);     }      return map;   }    public Model mapProperties(springfox.documentation.schema.Model source) {      ModelImpl model = new ModelImpl()         .description(source.getDescription())         .discriminator(source.getDiscriminator())         .example("")         .name(source.getName());     TreeMap<String, Property> sorted = newTreeMap();     sorted.putAll(mapProperties(source.getProperties()));     model.setProperties(sorted);     FluentIterable<String> requiredFields = FluentIterable.from(source.getProperties().values())         .filter(requiredProperty())         .transform(propertyName());     model.setRequired(requiredFields.toList());     model.setSimple(false);     if (isInterface(source.getType())) {       model.setType(ModelImpl.OBJECT);     }     if (isMapType(source.getType())) {       Optional<Class> clazz = typeOfValue(source);       if (clazz.isPresent()) {         model.additionalProperties(property(clazz.get().getSimpleName()));       } else {         model.additionalProperties(new ObjectProperty());       }     }     return model;   }    private boolean isInterface(ResolvedType type) {     return type instanceof ResolvedInterfaceType;   }    private Optional<Class> typeOfValue(springfox.documentation.schema.Model source) {     if (source.getType().getTypeParameters() != null && source.getType().getTypeParameters().size() > 0) {       return Optional.of((Class)source.getType().getTypeParameters().get(1).getErasedType());     }     return Optional.absent();   }    public Property mapProperty(ModelProperty source) {     Property property = modelRefToProperty(source.getModelRef());      addEnumValues(property, source.getAllowableValues());      if (property instanceof ArrayProperty) {       ArrayProperty arrayProperty = (ArrayProperty) property;       addEnumValues(arrayProperty.getItems(), source.getAllowableValues());     }      if (property instanceof AbstractNumericProperty) {       AllowableValues allowableValues = source.getAllowableValues();       if (allowableValues instanceof AllowableRangeValues) {         AllowableRangeValues range = (AllowableRangeValues) allowableValues;         ((AbstractNumericProperty) property).maximum(Double.valueOf(range.getMax()));         ((AbstractNumericProperty) property).minimum(Double.valueOf(range.getMin()));       }     }     if (property != null) {       property.setDescription(source.getDescription());       property.setName(source.getName());       property.setRequired(source.isRequired());       property.setReadOnly(source.isReadOnly());     }     return property;   }    private static Property addEnumValues(Property property, AllowableValues allowableValues) {     if (property instanceof StringProperty && allowableValues instanceof AllowableListValues) {       StringProperty stringProperty = (StringProperty) property;       AllowableListValues listValues = (AllowableListValues) allowableValues;       stringProperty.setEnum(listValues.getValues());     }     return property;   }    static Property modelRefToProperty(ModelRef modelRef) {     if (modelRef == null || "void".equalsIgnoreCase(modelRef.getType())) {       return null;     }     Property responseProperty;     if (modelRef.isCollection()) {       String itemType = modelRef.getItemType();       responseProperty = new ArrayProperty(addEnumValues(property(itemType), modelRef.getAllowableValues()));     } else if (modelRef.isMap()) {       String itemType = modelRef.getItemType();       responseProperty = new MapProperty(property(itemType));     } else {       responseProperty = property(modelRef.getType());     }      addEnumValues(responseProperty, modelRef.getAllowableValues());      return responseProperty;   }    protected Map<String, Model> modelsFromApiListings(Multimap<String, ApiListing> apiListings) {     Map<String, springfox.documentation.schema.Model> definitions = newHashMap();     for (ApiListing each : apiListings.values()) {       definitions.putAll(each.getModels());     }     return mapModels(definitions);   }    protected abstract Map<String, Property> mapProperties(Map<String, ModelProperty> properties);    private Function<ModelProperty, String> propertyName() {     return new Function<ModelProperty, String>() {       @Override       public String apply(ModelProperty input) {         return input.getName();       }     };   }    private Predicate<ModelProperty> requiredProperty() {     return new Predicate<ModelProperty>() {       @Override       public boolean apply(ModelProperty input) {         return input.isRequired();       }     };   } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> springfox-swagger2 : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> springfox : Folder]
						[NT -> documentation : Folder]
							[NT -> swagger2 : Folder]
								[NT -> mappers : Folder]
									[NT -> ModelMapper.java.merge : .java.merge-File]
										[T -> ModelMapper.java : .java-Content "/*  *  *  Copyright 2015 the original author or authors.  *  *  Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *         http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  *  */  package springfox.documentation.swagger2.mappers;  import com.google.common.base.Function; import com.google.common.base.Optional; import com.google.common.base.Predicate; import com.google.common.collect.FluentIterable; import com.google.common.collect.Multimap; import io.swagger.models.Model; import io.swagger.models.ModelImpl; import io.swagger.models.properties.AbstractNumericProperty; import io.swagger.models.properties.ArrayProperty; import io.swagger.models.properties.MapProperty; import io.swagger.models.properties.ObjectProperty; import io.swagger.models.properties.Property; import io.swagger.models.properties.StringProperty; import org.mapstruct.Mapper; import springfox.documentation.schema.ModelProperty; import springfox.documentation.schema.ModelRef; import springfox.documentation.service.AllowableListValues; import springfox.documentation.service.AllowableRangeValues; import springfox.documentation.service.AllowableValues; import springfox.documentation.service.ApiListing;  import java.util.HashMap; import java.util.Map; import java.util.TreeMap;  import static com.google.common.collect.Maps.*; import static springfox.documentation.schema.Maps.*; import static springfox.documentation.swagger2.mappers.Properties.*;  @Mapper public abstract class ModelMapper {   public Map<String, Model> mapModels(Map<String, springfox.documentation.schema.Model> from) {     if (from == null) {       return null;     }      Map<String, Model> map = new HashMap<String, Model>();      for (java.util.Map.Entry<String, springfox.documentation.schema.Model> entry : from.entrySet()) {       String key = entry.getKey();       Model value = mapProperties(entry.getValue());       map.put(key, value);     }      return map;   }    public Model mapProperties(springfox.documentation.schema.Model source) {      ModelImpl model = new ModelImpl()         .description(source.getDescription())         .discriminator(source.getDiscriminator())         .example("")         .name(source.getName());     TreeMap<String, Property> sorted = newTreeMap();     sorted.putAll(mapProperties(source.getProperties()));     model.setProperties(sorted);     FluentIterable<String> requiredFields = FluentIterable.from(source.getProperties().values())         .filter(requiredProperty())         .transform(propertyName());     model.setRequired(requiredFields.toList());     model.setSimple(false);     if (isMapType(source.getType())) {       Optional<Class> clazz = typeOfValue(source);       if (clazz.isPresent()) {         model.additionalProperties(property(clazz.get().getSimpleName()));       } else {         model.additionalProperties(new ObjectProperty());       }     }     return model;   }    private Optional<Class> typeOfValue(springfox.documentation.schema.Model source) {     if (source.getType().getTypeParameters() != null && source.getType().getTypeParameters().size() > 0) {       return Optional.of((Class)source.getType().getTypeParameters().get(1).getErasedType());     }     return Optional.absent();   }    public Property mapProperty(ModelProperty source) {     Property property = modelRefToProperty(source.getModelRef());      addEnumValues(property, source.getAllowableValues());      if (property instanceof ArrayProperty) {       ArrayProperty arrayProperty = (ArrayProperty) property;       addEnumValues(arrayProperty.getItems(), source.getAllowableValues());     }      if (property instanceof AbstractNumericProperty) {       AllowableValues allowableValues = source.getAllowableValues();       if (allowableValues instanceof AllowableRangeValues) {         AllowableRangeValues range = (AllowableRangeValues) allowableValues;         ((AbstractNumericProperty) property).maximum(Double.valueOf(range.getMax()));         ((AbstractNumericProperty) property).minimum(Double.valueOf(range.getMin()));       }     }     if (property != null) {       property.setDescription(source.getDescription());       property.setName(source.getName());       property.setRequired(source.isRequired());       property.setReadOnly(source.isReadOnly());     }     return property;   }    private static Property addEnumValues(Property property, AllowableValues allowableValues) {     if (property instanceof StringProperty && allowableValues instanceof AllowableListValues) {       StringProperty stringProperty = (StringProperty) property;       AllowableListValues listValues = (AllowableListValues) allowableValues;       stringProperty.setEnum(listValues.getValues());     }     return property;   }    static Property modelRefToProperty(ModelRef modelRef) {     if (modelRef == null || "void".equalsIgnoreCase(modelRef.getType())) {       return null;     }     Property responseProperty;     if (modelRef.isCollection()) {       String itemType = modelRef.getItemType();       responseProperty = new ArrayProperty(addEnumValues(property(itemType), modelRef.getAllowableValues()));     } else if (modelRef.isMap()) {       String itemType = modelRef.getItemType();       responseProperty = new MapProperty(property(itemType));     } else {       responseProperty = property(modelRef.getType());     }      addEnumValues(responseProperty, modelRef.getAllowableValues());      return responseProperty;   }    protected Map<String, Model> modelsFromApiListings(Multimap<String, ApiListing> apiListings) {     Map<String, springfox.documentation.schema.Model> definitions = newHashMap();     for (ApiListing each : apiListings.values()) {       definitions.putAll(each.getModels());     }     return mapModels(definitions);   }    protected abstract Map<String, Property> mapProperties(Map<String, ModelProperty> properties);    private Function<ModelProperty, String> propertyName() {     return new Function<ModelProperty, String>() {       @Override       public String apply(ModelProperty input) {         return input.getName();       }     };   }    private Predicate<ModelProperty> requiredProperty() {     return new Predicate<ModelProperty>() {       @Override       public boolean apply(ModelProperty input) {         return input.isRequired();       }     };   } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> springfox-swagger2 : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> springfox : Folder]
						[NT -> documentation : Folder]
							[NT -> swagger2 : Folder]
								[NT -> mappers : Folder]
									[NT -> ModelMapper.java.merge : .java.merge-File]
										[T -> ModelMapper.java : .java-Content "/*  *  *  Copyright 2015 the original author or authors.  *  *  Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *         http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  *  */  package springfox.documentation.swagger2.mappers;  import static com.google.common.collect.Maps.newHashMap; import static com.google.common.collect.Maps.newTreeMap; import static springfox.documentation.schema.Maps.isMapType; import static springfox.documentation.swagger2.mappers.Properties.property;  import java.util.HashMap; import java.util.Map; import java.util.TreeMap;  import org.mapstruct.Mapper;  import com.google.common.base.Function; import com.google.common.base.Optional; import com.google.common.base.Predicate; import com.google.common.collect.FluentIterable; import com.google.common.collect.Multimap;  import io.swagger.models.Model; import io.swagger.models.ModelImpl; import io.swagger.models.properties.AbstractNumericProperty; import io.swagger.models.properties.ArrayProperty; import io.swagger.models.properties.MapProperty; import io.swagger.models.properties.ObjectProperty; import io.swagger.models.properties.Property; import io.swagger.models.properties.StringProperty; import springfox.documentation.schema.ModelProperty; import springfox.documentation.schema.ModelRef; import springfox.documentation.service.AllowableListValues; import springfox.documentation.service.AllowableRangeValues; import springfox.documentation.service.AllowableValues; import springfox.documentation.service.ApiListing;  @Mapper public abstract class ModelMapper {   public Map<String, Model> mapModels(Map<String, springfox.documentation.schema.Model> from) {     if (from == null) {       return null;     }      Map<String, Model> map = new HashMap<String, Model>();      for (java.util.Map.Entry<String, springfox.documentation.schema.Model> entry : from.entrySet()) {       String key = entry.getKey();       Model value = mapProperties(entry.getValue());       map.put(key, value);     }      return map;   }    public Model mapProperties(springfox.documentation.schema.Model source) {      ModelImpl model = new ModelImpl()         .description(source.getDescription())         .discriminator(source.getDiscriminator())         .example(source.getExample())         .name(source.getName());     TreeMap<String, Property> sorted = newTreeMap();     sorted.putAll(mapProperties(source.getProperties()));     model.setProperties(sorted);     FluentIterable<String> requiredFields = FluentIterable.from(source.getProperties().values())         .filter(requiredProperty())         .transform(propertyName());     model.setRequired(requiredFields.toList());     model.setSimple(false);     if (isMapType(source.getType())) {       Optional<Class> clazz = typeOfValue(source);       if (clazz.isPresent()) {         model.additionalProperties(property(clazz.get().getSimpleName()));       } else {         model.additionalProperties(new ObjectProperty());       }     }     return model;   }    private Optional<Class> typeOfValue(springfox.documentation.schema.Model source) {     if (source.getType().getTypeParameters() != null && source.getType().getTypeParameters().size() > 0) {       return Optional.of((Class)source.getType().getTypeParameters().get(1).getErasedType());     }     return Optional.absent();   }    public Property mapProperty(ModelProperty source) {     Property property = modelRefToProperty(source.getModelRef());      addEnumValues(property, source.getAllowableValues());      if (property instanceof ArrayProperty) {       ArrayProperty arrayProperty = (ArrayProperty) property;       addEnumValues(arrayProperty.getItems(), source.getAllowableValues());     }      if (property instanceof AbstractNumericProperty) {       AllowableValues allowableValues = source.getAllowableValues();       if (allowableValues instanceof AllowableRangeValues) {         AllowableRangeValues range = (AllowableRangeValues) allowableValues;         ((AbstractNumericProperty) property).maximum(Double.valueOf(range.getMax()));         ((AbstractNumericProperty) property).minimum(Double.valueOf(range.getMin()));       }     }     if (property != null) {       property.setDescription(source.getDescription());       property.setName(source.getName());       property.setRequired(source.isRequired());       property.setReadOnly(source.isReadOnly());       property.setExample(source.getExample());     }     return property;   }    private static Property addEnumValues(Property property, AllowableValues allowableValues) {     if (property instanceof StringProperty && allowableValues instanceof AllowableListValues) {       StringProperty stringProperty = (StringProperty) property;       AllowableListValues listValues = (AllowableListValues) allowableValues;       stringProperty.setEnum(listValues.getValues());     }     return property;   }    static Property modelRefToProperty(ModelRef modelRef) {     if (modelRef == null || "void".equalsIgnoreCase(modelRef.getType())) {       return null;     }     Property responseProperty;     if (modelRef.isCollection()) {       String itemType = modelRef.getItemType();       responseProperty = new ArrayProperty(addEnumValues(property(itemType), modelRef.getAllowableValues()));     } else if (modelRef.isMap()) {       String itemType = modelRef.getItemType();       responseProperty = new MapProperty(property(itemType));     } else {       responseProperty = property(modelRef.getType());     }      addEnumValues(responseProperty, modelRef.getAllowableValues());      return responseProperty;   }    protected Map<String, Model> modelsFromApiListings(Multimap<String, ApiListing> apiListings) {     Map<String, springfox.documentation.schema.Model> definitions = newHashMap();     for (ApiListing each : apiListings.values()) {       definitions.putAll(each.getModels());     }     return mapModels(definitions);   }    protected abstract Map<String, Property> mapProperties(Map<String, ModelProperty> properties);    private Function<ModelProperty, String> propertyName() {     return new Function<ModelProperty, String>() {       @Override       public String apply(ModelProperty input) {         return input.getName();       }     };   }    private Predicate<ModelProperty> requiredProperty() {     return new Predicate<ModelProperty>() {       @Override       public boolean apply(ModelProperty input) {         return input.isRequired();       }     };   } } " compose:StringConcatenation merge: LineBased]
