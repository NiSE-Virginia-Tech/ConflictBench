Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/com/ning/http/client/AsyncHttpClient.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/com/ning/http/client/AsyncHttpClient.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/com/ning/http/client/AsyncHttpClient.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/com/ning/http/client/AsyncHttpClient.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/com/ning/http/client/AsyncHttpClient.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/com/ning/http/client/AsyncHttpClient.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> ning : Folder]
						[NT -> http : Folder]
							[NT -> client : Folder]
								[NT -> AsyncHttpClient.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.ning.http.client;" compose:Replacement merge: Default]
										[T -> com.ning.http.client.Request.EntityWriter{ImportPackage} : ImportDeclaration "import com.ning.http.client.Request.EntityWriter;" compose:Replacement merge: Default]
										[T -> com.ning.http.client.providers.NettyAsyncHttpProvider{ImportPackage} : ImportDeclaration "import com.ning.http.client.providers.NettyAsyncHttpProvider;" compose:Replacement merge: Default]
										[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
										[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.Future{ImportPackage} : ImportDeclaration "import java.util.concurrent.Future;" compose:Replacement merge: Default]
										[NT -> AsyncHttpClient : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> AsyncHttpClient : Id "AsyncHttpClient" compose:Replacement merge: Default]
											[T -> httpProvider : FieldDecl "private final AsyncHttpProvider httpProvider;" compose:Replacement merge: SemanticConflict]
											[T -> config : FieldDecl "private final AsyncHttpClientConfig config;" compose:Replacement merge: SemanticConflict]
											[T -> AsyncHttpClient({FormalParametersInternal}) : ConstructorDecl "public AsyncHttpClient() {         this(new AsyncHttpClientConfig.Builder().build());     }" compose:Replacement merge: LineBased]
											[T -> AsyncHttpClient(AsyncHttpClientConfig-AsyncHttpClientConfig) : ConstructorDecl "public AsyncHttpClient(AsyncHttpClientConfig config) {         this.config = config;         this.httpProvider = new NettyAsyncHttpProvider(config);     }" compose:Replacement merge: LineBased]
											[T -> AsyncHttpClient(AsyncHttpProvider-AsyncHttpProvider) : ConstructorDecl "public AsyncHttpClient(AsyncHttpProvider httpProvider) {         this.config = new AsyncHttpClientConfig.Builder().build();         this.httpProvider = httpProvider;     }" compose:Replacement merge: LineBased]
											[T -> voidHandler : FieldDecl "private final static AsyncHandler<Response> voidHandler = new AsyncHandler<Response>(){          @Override         public Response onCompleted(Response response) throws IOException{             return response;         }          @Override         public void onThrowable(Throwable t) {             t.printStackTrace();         }      };" compose:Replacement merge: SemanticConflict]
											[T -> getProvider({FormalParametersInternal}) : MethodDecl "public AsyncHttpProvider getProvider() {         return httpProvider;     }" compose:Replacement merge: LineBased]
											[T -> close({FormalParametersInternal}) : MethodDecl "public void close() {         httpProvider.close();     }" compose:Replacement merge: LineBased]
											[T -> finalize({FormalParametersInternal}) : MethodDecl "@Override     protected void finalize() throws Throwable {         close();         super.finalize();     }" compose:Replacement merge: LineBased]
											[T -> getConfig({FormalParametersInternal}) : MethodDecl "public AsyncHttpClientConfig getConfig(){         return config;     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String) : MethodDecl "public Future<Response> doGet(String url) throws IOException {         return doGet(url,(Headers) null);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers) : MethodDecl "public Future<Response> doGet(String url, Headers headers) throws IOException {         return doGet(url, headers,(List<Cookie>) null);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers-List<Cookie>-List<Cookie>) : MethodDecl "public Future<Response> doGet(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doGet(String url, AsyncHandler<T> handler) throws IOException {         return doGet(url, null, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doGet(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doGet(url, headers, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers-List<Cookie>-List<Cookie>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doGet(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-byte[]-byte[]) : MethodDecl "public Future<Response>  doPost(String url, byte[] data) throws IOException {         return doPost(url, null, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-byte[]-byte[]) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, byte[] data) throws IOException {         return doPost(url, headers, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream) : MethodDecl "public Future<Response>  doPost(String url, InputStream data) throws IOException {         return doPost(url, null, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-EntityWriter-EntityWriter) : MethodDecl "public Future<Response>  doPost(String url, EntityWriter entityWriter) throws IOException {         return doPost(url, null, null, entityWriter, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, InputStream data) throws IOException {         return doPost(url, headers, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter) throws IOException {         return doPost(url, headers, entityWriter, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPost(url, headers, cookies, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream-long-long) : MethodDecl "public Future<Response>  doPost(String url, InputStream data, long length) throws IOException {         return doPost(url, null, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, InputStream data, long length) throws IOException {         return doPost(url, headers, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Map<String,String>-Map<String,String>) : MethodDecl "public Future<Response> doPost(String url, Map<String, String> params) throws IOException {         return doPost(url, (Headers)null, (List<Cookie>)null, params);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-Map<String,String>-Map<String,String>) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, Map<String, String> params) throws IOException {         return doPost(url, headers, null, params);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-Map<String,String>-Map<String,String>) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-EntityWriter-EntityWriter-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, entityWriter, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, entityWriter, handler, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter-AsyncHandler<T>-AsyncHandler<T>-long-long) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, cookies, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Map<String,String>-Map<String,String>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-Map<String,String>-Map<String,String>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-Map<String,String>-Map<String,String>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-List<Part>-List<Part>) : MethodDecl "public Future<Response> doMultipartPost(String url, List<Part> params) throws IOException {         return doMultipartPost(url, null, null, params);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Part>-List<Part>) : MethodDecl "public Future<Response> doMultipartPost(String url, Headers headers, List<Part> params) throws IOException {         return doMultipartPost(url, headers, null, params);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-List<Part>-List<Part>) : MethodDecl "public Future<Response> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-List<Part>-List<Part>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doMultipartPost(String url, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, null, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Part>-List<Part>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doMultipartPost(String url, Headers headers, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, headers, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-List<Part>-List<Part>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-byte[]-byte[]) : MethodDecl "public Future<Response> doPut(String url, byte[] data) throws IOException {         return doPut(url, null, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-byte[]-byte[]) : MethodDecl "public Future<Response> doPut(String url, Headers headers, byte[] data) throws IOException {         return doPut(url, headers, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream) : MethodDecl "public Future<Response> doPut(String url, InputStream data) throws IOException {         return doPut(url, null, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream) : MethodDecl "public Future<Response> doPut(String url, Headers headers, InputStream data) throws IOException {         return doPut(url, headers, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPut(url, headers, cookies, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream-long-long) : MethodDecl "public Future<Response> doPut(String url, InputStream data, long length) throws IOException {         return doPut(url, null, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, InputStream data, long length) throws IOException {         return doPut(url, headers, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPut(url, headers, (List<Cookie>)null, entityWriter, length);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, cookies, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-EntityWriter-EntityWriter-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, entityWriter, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String) : MethodDecl "public Future<Response> doDelete(String url) throws IOException {         return doDelete(url, (Headers)null);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers) : MethodDecl "public Future<Response> doDelete(String url, Headers headers) throws IOException {         return doDelete(url, headers, (List<Cookie>)null);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers-List<Cookie>-List<Cookie>) : MethodDecl "public Future<Response> doDelete(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doDelete(String url, AsyncHandler<T> handler) throws IOException {         return doDelete(url, null, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doDelete(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doDelete(url, headers, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers-List<Cookie>-List<Cookie>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doDelete(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), handler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String) : MethodDecl "public Future<Response> doHead(String url) throws IOException {         return doHead(url, (Headers)null);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers) : MethodDecl "public Future<Response> doHead(String url, Headers headers) throws IOException {         return doHead(url, headers, (List<Cookie>)null);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers-List<Cookie>-List<Cookie>) : MethodDecl "public Future<Response> doHead(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doHead(String url, AsyncHandler<T> handler) throws IOException {         return doHead(url, null, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doHead(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doHead(url, headers, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers-List<Cookie>-List<Cookie>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doHead(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), handler);     }" compose:Replacement merge: LineBased]
											[T -> performRequest(Request-Request-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> performRequest(Request request,                                 AsyncHandler<T> handler) throws IOException {         return httpProvider.handle(request, handler);     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> ning : Folder]
						[NT -> http : Folder]
							[NT -> client : Folder]
								[NT -> AsyncHttpClient.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.ning.http.client;" compose:Replacement merge: Default]
										[T -> com.ning.http.client.Request.EntityWriter{ImportPackage} : ImportDeclaration "import com.ning.http.client.Request.EntityWriter;" compose:Replacement merge: Default]
										[T -> com.ning.http.client.providers.NettyAsyncHttpProvider{ImportPackage} : ImportDeclaration "import com.ning.http.client.providers.NettyAsyncHttpProvider;" compose:Replacement merge: Default]
										[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
										[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.Executors{ImportPackage} : ImportDeclaration "import java.util.concurrent.Executors;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.Future{ImportPackage} : ImportDeclaration "import java.util.concurrent.Future;" compose:Replacement merge: Default]
										[NT -> AsyncHttpClient : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> AsyncHttpClient : Id "AsyncHttpClient" compose:Replacement merge: Default]
											[T -> DEFAULT_MAX_TOTAL_CONNECTIONS : FieldDecl "public static final int DEFAULT_MAX_TOTAL_CONNECTIONS = Integer.getInteger("xn.httpClient.defaultMaxTotalConnections", 2000);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_MAX_CONNECTIONS_PER_HOST : FieldDecl "public static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = Integer.getInteger("xn.httpClient.defaultMaxConnectionsPerHost", 2000);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_CONNECTION_TIMEOUT_MS : FieldDecl "public static final long DEFAULT_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultConnectionTimeoutInMS", 60 * 1000L);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_IDLE_CONNECTION_TIMEOUT_MS : FieldDecl "public static final long DEFAULT_IDLE_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultIdleConnectionTimeoutInMS", 15 * 1000L);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_REQUEST_TIMEOUT_MS : FieldDecl "public static final int DEFAULT_REQUEST_TIMEOUT_MS = Integer.getInteger("xn.httpClient.defaultRequestTimeoutInMS", 60 * 1000);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_REDIRECTS_ENABLED : FieldDecl "public static final boolean DEFAULT_REDIRECTS_ENABLED = Boolean.getBoolean("xn.httpClient.defaultRedirectsEnabled");" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_MAX_REDIRECTS : FieldDecl "public static final int DEFAULT_MAX_REDIRECTS = Integer.getInteger("xn.httpClient.defaultMaxRedirects", 5);" compose:Replacement merge: SemanticConflict]
											[T -> httpProvider : FieldDecl "private final AsyncHttpProvider httpProvider;" compose:Replacement merge: SemanticConflict]
											[T -> AsyncHttpClient({FormalParametersInternal}) : ConstructorDecl "public AsyncHttpClient() {         this(new NettyAsyncHttpProvider(new ProviderConfig(                 Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()))));     }" compose:Replacement merge: LineBased]
											[T -> AsyncHttpClient(AsyncHttpProvider-AsyncHttpProvider) : ConstructorDecl "public AsyncHttpClient(AsyncHttpProvider httpProvider) {         this.httpProvider = httpProvider;          setMaximumConnectionsTotal(DEFAULT_MAX_TOTAL_CONNECTIONS);         setMaximumConnectionsPerHost(DEFAULT_MAX_CONNECTIONS_PER_HOST);         setFollowRedirects(DEFAULT_REDIRECTS_ENABLED);         setRequestTimeout(DEFAULT_REQUEST_TIMEOUT_MS);         setConnectionTimeout(DEFAULT_CONNECTION_TIMEOUT_MS);         setIdleConnectionTimeout(DEFAULT_IDLE_CONNECTION_TIMEOUT_MS);         setMaximumNumberOfRedirects(DEFAULT_MAX_REDIRECTS);     }" compose:Replacement merge: LineBased]
											[T -> voidHandler : FieldDecl "private final static AsyncHandler<Response> voidHandler = new AsyncHandler<Response>(){          @Override         public Response onCompleted(Response response) throws IOException{             return response;         }          @Override         public void onThrowable(Throwable t) {             t.printStackTrace();         }      };" compose:Replacement merge: SemanticConflict]
											[T -> getProvider({FormalParametersInternal}) : MethodDecl "public AsyncHttpProvider getProvider() {         return httpProvider;     }" compose:Replacement merge: LineBased]
											[T -> close({FormalParametersInternal}) : MethodDecl "public void close() {         httpProvider.close();     }" compose:Replacement merge: LineBased]
											[T -> finalize({FormalParametersInternal}) : MethodDecl "@Override     protected void finalize() throws Throwable {         close();         super.finalize();     }" compose:Replacement merge: LineBased]
											[T -> setMaximumConnectionsTotal(int-int) : MethodDecl "public void setMaximumConnectionsTotal(int maxConnectionsTotal) {         httpProvider.setMaximumConnectionsTotal(maxConnectionsTotal);     }" compose:Replacement merge: LineBased]
											[T -> setMaximumConnectionsPerHost(int-int) : MethodDecl "public void setMaximumConnectionsPerHost(int maxConnectionsPerHost) {         httpProvider.setMaximumConnectionsPerHost(maxConnectionsPerHost);     }" compose:Replacement merge: LineBased]
											[T -> setConnectionTimeout(long-long) : MethodDecl "public void setConnectionTimeout(long timeOutInMS) {         httpProvider.setConnectionTimeout(timeOutInMS);     }" compose:Replacement merge: LineBased]
											[T -> setIdleConnectionTimeout(long-long) : MethodDecl "public void setIdleConnectionTimeout(long timeOutInMS) {         httpProvider.setIdleConnectionTimeout(timeOutInMS);     }" compose:Replacement merge: LineBased]
											[T -> setRequestTimeout(int-int) : MethodDecl "public void setRequestTimeout(int timeOutInMS) {         httpProvider.setRequestTimeout(timeOutInMS);     }" compose:Replacement merge: LineBased]
											[T -> setFollowRedirects(boolean-boolean) : MethodDecl "public void setFollowRedirects(boolean followRedirects) {         httpProvider.setFollowRedirects(followRedirects);     }" compose:Replacement merge: LineBased]
											[T -> setMaximumNumberOfRedirects(int-int) : MethodDecl "public void setMaximumNumberOfRedirects(int maxNumRedirects) {         httpProvider.setMaximumNumberOfRedirects(maxNumRedirects);     }" compose:Replacement merge: LineBased]
											[T -> setCompressionEnabled(boolean-boolean) : MethodDecl "public void setCompressionEnabled(boolean compressionEnabled) {         httpProvider.setCompressionEnabled(compressionEnabled);     }" compose:Replacement merge: LineBased]
											[T -> setUserAgent(String-String) : MethodDecl "public void setUserAgent(String userAgent) {         httpProvider.setUserAgent(userAgent);     }" compose:Replacement merge: LineBased]
											[T -> setProxy(ProxyServer-ProxyServer) : MethodDecl "public void setProxy(final ProxyServer proxyServer) {         httpProvider.setProxyServer(proxyServer);     }" compose:Replacement merge: LineBased]
											[T -> isCompressionEnabled({FormalParametersInternal}) : MethodDecl "public boolean isCompressionEnabled() {         return httpProvider.isCompressionEnabled();     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String) : MethodDecl "public Future<Response> doGet(String url) throws IOException {         return doGet(url,(Headers) null);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers) : MethodDecl "public Future<Response> doGet(String url, Headers headers) throws IOException {         return doGet(url, headers,(List<Cookie>) null);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers-List<Cookie>-List<Cookie>) : MethodDecl "public Future<Response> doGet(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doGet(String url, AsyncHandler<T> handler) throws IOException {         return doGet(url, null, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doGet(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doGet(url, headers, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doGet(String-String-Headers-Headers-List<Cookie>-List<Cookie>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doGet(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-byte[]-byte[]) : MethodDecl "public Future<Response>  doPost(String url, byte[] data) throws IOException {         return doPost(url, null, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-byte[]-byte[]) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, byte[] data) throws IOException {         return doPost(url, headers, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream) : MethodDecl "public Future<Response>  doPost(String url, InputStream data) throws IOException {         return doPost(url, null, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-EntityWriter-EntityWriter) : MethodDecl "public Future<Response>  doPost(String url, EntityWriter entityWriter) throws IOException {         return doPost(url, null, null, entityWriter, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, InputStream data) throws IOException {         return doPost(url, headers, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter) throws IOException {         return doPost(url, headers, entityWriter, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPost(url, headers, cookies, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream-long-long) : MethodDecl "public Future<Response>  doPost(String url, InputStream data, long length) throws IOException {         return doPost(url, null, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, InputStream data, long length) throws IOException {         return doPost(url, headers, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Map<String,String>-Map<String,String>) : MethodDecl "public Future<Response> doPost(String url, Map<String, String> params) throws IOException {         return doPost(url, (Headers)null, (List<Cookie>)null, params);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-Map<String,String>-Map<String,String>) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, Map<String, String> params) throws IOException {         return doPost(url, headers, null, params);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-Map<String,String>-Map<String,String>) : MethodDecl "public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-EntityWriter-EntityWriter-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, entityWriter, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, entityWriter, handler, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-EntityWriter-EntityWriter-AsyncHandler<T>-AsyncHandler<T>-long-long) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, cookies, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Map<String,String>-Map<String,String>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-Map<String,String>-Map<String,String>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-Map<String,String>-Map<String,String>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-List<Part>-List<Part>) : MethodDecl "public Future<Response> doMultipartPost(String url, List<Part> params) throws IOException {         return doMultipartPost(url, null, null, params);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Part>-List<Part>) : MethodDecl "public Future<Response> doMultipartPost(String url, Headers headers, List<Part> params) throws IOException {         return doMultipartPost(url, headers, null, params);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-List<Part>-List<Part>) : MethodDecl "public Future<Response> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-List<Part>-List<Part>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doMultipartPost(String url, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, null, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Part>-List<Part>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doMultipartPost(String url, Headers headers, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, headers, null, params, handler);     }" compose:Replacement merge: LineBased]
											[T -> doMultipartPost(String-String-Headers-Headers-List<Cookie>-List<Cookie>-List<Part>-List<Part>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-byte[]-byte[]) : MethodDecl "public Future<Response> doPut(String url, byte[] data) throws IOException {         return doPut(url, null, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-byte[]-byte[]) : MethodDecl "public Future<Response> doPut(String url, Headers headers, byte[] data) throws IOException {         return doPut(url, headers, null, data);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream) : MethodDecl "public Future<Response> doPut(String url, InputStream data) throws IOException {         return doPut(url, null, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream) : MethodDecl "public Future<Response> doPut(String url, Headers headers, InputStream data) throws IOException {         return doPut(url, headers, null, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPut(url, headers, cookies, data, -1);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream-long-long) : MethodDecl "public Future<Response> doPut(String url, InputStream data, long length) throws IOException {         return doPut(url, null, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, InputStream data, long length) throws IOException {         return doPut(url, headers, null, data, length);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPut(url, headers, (List<Cookie>)null, entityWriter, length);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long) : MethodDecl "public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-byte[]-byte[]-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, cookies, data, -1, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-EntityWriter-EntityWriter-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, entityWriter, length, handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-InputStream-InputStream-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doPut(String-String-Headers-Headers-List<Cookie>-List<Cookie>-EntityWriter-EntityWriter-long-long-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), handler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String) : MethodDecl "public Future<Response> doDelete(String url) throws IOException {         return doDelete(url, (Headers)null);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers) : MethodDecl "public Future<Response> doDelete(String url, Headers headers) throws IOException {         return doDelete(url, headers, (List<Cookie>)null);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers-List<Cookie>-List<Cookie>) : MethodDecl "public Future<Response> doDelete(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doDelete(String url, AsyncHandler<T> handler) throws IOException {         return doDelete(url, null, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doDelete(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doDelete(url, headers, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doDelete(String-String-Headers-Headers-List<Cookie>-List<Cookie>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doDelete(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), handler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String) : MethodDecl "public Future<Response> doHead(String url) throws IOException {         return doHead(url, (Headers)null);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers) : MethodDecl "public Future<Response> doHead(String url, Headers headers) throws IOException {         return doHead(url, headers, (List<Cookie>)null);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers-List<Cookie>-List<Cookie>) : MethodDecl "public Future<Response> doHead(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), voidHandler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doHead(String url, AsyncHandler<T> handler) throws IOException {         return doHead(url, null, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doHead(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doHead(url, headers, null, handler);     }" compose:Replacement merge: LineBased]
											[T -> doHead(String-String-Headers-Headers-List<Cookie>-List<Cookie>-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> doHead(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), handler);     }" compose:Replacement merge: LineBased]
											[T -> performRequest(Request-Request-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> performRequest(Request request,                                 AsyncHandler<T> handler) throws IOException {         return httpProvider.handle(request, handler);     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> ning : Folder]
						[NT -> http : Folder]
							[NT -> client : Folder]
								[NT -> AsyncHttpClient.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.ning.http.client;" compose:Replacement merge: Default]
										[T -> com.ning.http.client.providers.NettyAsyncHttpProvider{ImportPackage} : ImportDeclaration "import com.ning.http.client.providers.NettyAsyncHttpProvider;" compose:Replacement merge: Default]
										[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.Executors{ImportPackage} : ImportDeclaration "import java.util.concurrent.Executors;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.Future{ImportPackage} : ImportDeclaration "import java.util.concurrent.Future;" compose:Replacement merge: Default]
										[NT -> AsyncHttpClient : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> AsyncHttpClient : Id "AsyncHttpClient" compose:Replacement merge: Default]
											[T -> DEFAULT_MAX_TOTAL_CONNECTIONS : FieldDecl "public static final int DEFAULT_MAX_TOTAL_CONNECTIONS = Integer.getInteger("xn.httpClient.defaultMaxTotalConnections", 2000);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_MAX_CONNECTIONS_PER_HOST : FieldDecl "public static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = Integer.getInteger("xn.httpClient.defaultMaxConnectionsPerHost", 2000);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_CONNECTION_TIMEOUT_MS : FieldDecl "public static final long DEFAULT_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultConnectionTimeoutInMS", 60 * 1000L);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_IDLE_CONNECTION_TIMEOUT_MS : FieldDecl "public static final long DEFAULT_IDLE_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultIdleConnectionTimeoutInMS", 15 * 1000L);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_REQUEST_TIMEOUT_MS : FieldDecl "public static final int DEFAULT_REQUEST_TIMEOUT_MS = Integer.getInteger("xn.httpClient.defaultRequestTimeoutInMS", 60 * 1000);" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_REDIRECTS_ENABLED : FieldDecl "public static final boolean DEFAULT_REDIRECTS_ENABLED = Boolean.getBoolean("xn.httpClient.defaultRedirectsEnabled");" compose:Replacement merge: SemanticConflict]
											[T -> DEFAULT_MAX_REDIRECTS : FieldDecl "public static final int DEFAULT_MAX_REDIRECTS = Integer.getInteger("xn.httpClient.defaultMaxRedirects", 5);" compose:Replacement merge: SemanticConflict]
											[T -> httpProvider : FieldDecl "private final AsyncHttpProvider httpProvider;" compose:Replacement merge: SemanticConflict]
											[T -> AsyncHttpClient({FormalParametersInternal}) : ConstructorDecl "public AsyncHttpClient() {         this(new NettyAsyncHttpProvider(new ProviderConfig(                 Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()))));     }" compose:Replacement merge: LineBased]
											[T -> AsyncHttpClient(AsyncHttpProvider-AsyncHttpProvider) : ConstructorDecl "public AsyncHttpClient(AsyncHttpProvider httpProvider) {         this.httpProvider = httpProvider;          setMaximumConnectionsTotal(DEFAULT_MAX_TOTAL_CONNECTIONS);         setMaximumConnectionsPerHost(DEFAULT_MAX_CONNECTIONS_PER_HOST);         setFollowRedirects(DEFAULT_REDIRECTS_ENABLED);         setRequestTimeout(DEFAULT_REQUEST_TIMEOUT_MS);         setConnectionTimeout(DEFAULT_CONNECTION_TIMEOUT_MS);         setIdleConnectionTimeout(DEFAULT_IDLE_CONNECTION_TIMEOUT_MS);         setMaximumNumberOfRedirects(DEFAULT_MAX_REDIRECTS);     }" compose:Replacement merge: LineBased]
											[T -> voidHandler : FieldDecl "private final static AsyncHandler<Response> voidHandler = new AsyncHandler<Response>(){          @Override         public Response onCompleted(Response response) throws IOException{             return response;         }          @Override         public void onThrowable(Throwable t) {             t.printStackTrace();         }      };" compose:Replacement merge: SemanticConflict]
											[NT -> BoundRequestBuilder : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> BoundRequestBuilder : Id "BoundRequestBuilder" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends RequestBuilderBase<BoundRequestBuilder>" compose:Replacement merge: Default]
												[T -> BoundRequestBuilder(RequestType-RequestType) : ConstructorDecl "private BoundRequestBuilder(RequestType type) {             super(type);         }" compose:Replacement merge: LineBased]
												[T -> BoundRequestBuilder(Request-Request) : ConstructorDecl "private BoundRequestBuilder(Request prototype) {             super(prototype);         }" compose:Replacement merge: LineBased]
												[T -> execute(AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> execute(AsyncHandler<T> handler) throws IOException {             return AsyncHttpClient.this.performRequest(build(), handler);         }" compose:Replacement merge: LineBased]
												[T -> execute({FormalParametersInternal}) : MethodDecl "public Future<Response> execute() throws IOException {             return AsyncHttpClient.this.performRequest(build(), voidHandler);         }" compose:Replacement merge: LineBased]
											[T -> getProvider({FormalParametersInternal}) : MethodDecl "public AsyncHttpProvider getProvider() {         return httpProvider;     }" compose:Replacement merge: LineBased]
											[T -> close({FormalParametersInternal}) : MethodDecl "public void close() {         httpProvider.close();     }" compose:Replacement merge: LineBased]
											[T -> finalize({FormalParametersInternal}) : MethodDecl "@Override     protected void finalize() throws Throwable {         close();         super.finalize();     }" compose:Replacement merge: LineBased]
											[T -> setMaximumConnectionsTotal(int-int) : MethodDecl "public void setMaximumConnectionsTotal(int maxConnectionsTotal) {         httpProvider.setMaximumConnectionsTotal(maxConnectionsTotal);     }" compose:Replacement merge: LineBased]
											[T -> setMaximumConnectionsPerHost(int-int) : MethodDecl "public void setMaximumConnectionsPerHost(int maxConnectionsPerHost) {         httpProvider.setMaximumConnectionsPerHost(maxConnectionsPerHost);     }" compose:Replacement merge: LineBased]
											[T -> setConnectionTimeout(long-long) : MethodDecl "public void setConnectionTimeout(long timeOutInMS) {         httpProvider.setConnectionTimeout(timeOutInMS);     }" compose:Replacement merge: LineBased]
											[T -> setIdleConnectionTimeout(long-long) : MethodDecl "public void setIdleConnectionTimeout(long timeOutInMS) {         httpProvider.setIdleConnectionTimeout(timeOutInMS);     }" compose:Replacement merge: LineBased]
											[T -> setRequestTimeout(int-int) : MethodDecl "public void setRequestTimeout(int timeOutInMS) {         httpProvider.setRequestTimeout(timeOutInMS);     }" compose:Replacement merge: LineBased]
											[T -> setFollowRedirects(boolean-boolean) : MethodDecl "public void setFollowRedirects(boolean followRedirects) {         httpProvider.setFollowRedirects(followRedirects);     }" compose:Replacement merge: LineBased]
											[T -> setMaximumNumberOfRedirects(int-int) : MethodDecl "public void setMaximumNumberOfRedirects(int maxNumRedirects) {         httpProvider.setMaximumNumberOfRedirects(maxNumRedirects);     }" compose:Replacement merge: LineBased]
											[T -> setCompressionEnabled(boolean-boolean) : MethodDecl "public void setCompressionEnabled(boolean compressionEnabled) {         httpProvider.setCompressionEnabled(compressionEnabled);     }" compose:Replacement merge: LineBased]
											[T -> setUserAgent(String-String) : MethodDecl "public void setUserAgent(String userAgent) {         httpProvider.setUserAgent(userAgent);     }" compose:Replacement merge: LineBased]
											[T -> setProxy(ProxyServer-ProxyServer) : MethodDecl "public void setProxy(final ProxyServer proxyServer) {         httpProvider.setProxyServer(proxyServer);     }" compose:Replacement merge: LineBased]
											[T -> isCompressionEnabled({FormalParametersInternal}) : MethodDecl "public boolean isCompressionEnabled() {         return httpProvider.isCompressionEnabled();     }" compose:Replacement merge: LineBased]
											[T -> prepareGet(String-String) : MethodDecl "public BoundRequestBuilder prepareGet(String url) {         return new BoundRequestBuilder(RequestType.GET).setUrl(url);     }" compose:Replacement merge: LineBased]
											[T -> prepareHead(String-String) : MethodDecl "public BoundRequestBuilder prepareHead(String url) {         return new BoundRequestBuilder(RequestType.HEAD).setUrl(url);     }" compose:Replacement merge: LineBased]
											[T -> preparePost(String-String) : MethodDecl "public BoundRequestBuilder preparePost(String url) {         return new BoundRequestBuilder(RequestType.POST).setUrl(url);     }" compose:Replacement merge: LineBased]
											[T -> preparePut(String-String) : MethodDecl "public BoundRequestBuilder preparePut(String url) {         return new BoundRequestBuilder(RequestType.PUT).setUrl(url);     }" compose:Replacement merge: LineBased]
											[T -> prepareDelete(String-String) : MethodDecl "public BoundRequestBuilder prepareDelete(String url) {         return new BoundRequestBuilder(RequestType.DELETE).setUrl(url);     }" compose:Replacement merge: LineBased]
											[T -> prepareRequest(Request-Request) : MethodDecl "public BoundRequestBuilder prepareRequest(Request request) {         return new BoundRequestBuilder(request);     }" compose:Replacement merge: LineBased]
											[T -> performRequest(Request-Request-AsyncHandler<T>-AsyncHandler<T>) : MethodDecl "public <T> Future<T> performRequest(Request request, AsyncHandler<T> handler) throws IOException {         return httpProvider.handle(request, handler);     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> ning : Folder]
						[NT -> http : Folder]
							[NT -> client : Folder]
								[NT -> AsyncHttpClient.java.merge : .java.merge-File]
									[T -> AsyncHttpClient.java : .java-Content "/*  * Copyright 2010 Ning, Inc.  *  * Ning licenses this file to you under the Apache License, version 2.0  * (the "License"); you may not use this file except in compliance with the  * License.  You may obtain a copy of the License at:  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the  * License for the specific language governing permissions and limitations  * under the License.  *  */ package com.ning.http.client;  import com.ning.http.client.Request.EntityWriter; import com.ning.http.client.providers.NettyAsyncHttpProvider;  import java.io.IOException; import java.io.InputStream; import java.util.List; import java.util.Map; import java.util.concurrent.Future;  /**  * This class support asynchronous and synchronous HTTP request.  *  * To execute synchronous HTTP request, you just need to do  * {@code  *    AsyncHttpClient c = new AsyncHttpClient();  *    Future<Response> f = c.doGet("http://www.ning.com/").get();  * }  *  * The code above will block until the response is fully received. To execute asynchronous HTTP request, you  * create an {@link AsyncHandler}  *  * {@code  *       AsyncHttpClient c = new AsyncHttpClient();  *       Future<Response> f = c.doGet("http://www.ning.com/", new AsyncHandler<Response>() &#123;  *  *          @Override  *          public Response onCompleted(Response response) throws IOException &#123;  *               // Do something  *              return response;  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Response response = f.get();  *  *      // We are just interested to retrieve the status code.  *     Future<Integer> f = c.doGet("http://www.ning.com/", new AsyncHandler<Integer>() &#123;  *  *          @Override  *          public Integer onCompleted(Response response) throws IOException &#123;  *               // Do something  *              return response.getStatusCode();  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Integer statusCode = f.get();  * }  * The {@link AsyncHandler#onCompleted(com.ning.http.client.Response)} will be invoked once the http response has been fully read, which include  * the http headers and the response body. Note that the entire response will be buffered in memory.  *   * You can also have more control about the how the response is asynchronously processed by using a {@link AsyncStreamingHandler}  * {@code  *      AsyncHttpClient c = new AsyncHttpClient();  *      Future<Response> f = c.doGet("http://www.ning.com/", new AsyncStreamingHandler() &#123;  *  *          @Override  *          public Response onContentReceived(HttpContent content) throws ResponseComplete &#123;  *              if (content instanceof HttpResponseHeaders) &#123;  *                  // The headers have been read  *                  // If you don't want to read the body, or stop processing the response  *                  throw new ResponseComplete();  *              &#125; else if (content instanceof HttpResponseBody) &#123;  *                  HttpResponseBody b = (HttpResponseBody) content;  *                  // Do something with the body. It may not been fully read yet.  *                  if (b.isComplete()) &#123;  *                      // The full response has been read.  *                  &#125;  *              &#125;  *              return content.getResponse();  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Response response = f.get();  * }  * From an {@link HttpContent}, you can asynchronously process the response headers and body and decide when to  * stop the processing the response by throwing {@link AsyncStreamingHandler.ResponseComplete} at any moment. The returned  * {@link Response} will be incomplete until {@link HttpResponseBody#isComplete()} return true, which means the  * response has been fully read and buffered in memory.  *  * This class can also be used with the need of {@link AsyncHandler}</p>  * {@code  *      AsyncHttpClient c = new AsyncHttpClient();  *      Future<Response> f = c.doGet(TARGET_URL);  *      Response r = f.get();  * }  */ public class AsyncHttpClient {      private final AsyncHttpProvider httpProvider;      private final AsyncHttpClientConfig config;       public AsyncHttpClient() {         this(new AsyncHttpClientConfig.Builder().build());     }      public AsyncHttpClient(AsyncHttpClientConfig config) {         this.config = config;         this.httpProvider = new NettyAsyncHttpProvider(config);     }      public AsyncHttpClient(AsyncHttpProvider httpProvider) {         this.config = new AsyncHttpClientConfig.Builder().build();         this.httpProvider = httpProvider;     }      private final static AsyncHandler<Response> voidHandler = new AsyncHandler<Response>(){          @Override         public Response onCompleted(Response response) throws IOException{             return response;         }          @Override         public void onThrowable(Throwable t) {             t.printStackTrace();         }      };       public AsyncHttpProvider getProvider() {         return httpProvider;     }      public void close() {         httpProvider.close();     }      @Override     protected void finalize() throws Throwable {         close();         super.finalize();     }       public AsyncHttpClientConfig getConfig(){         return config;     }       public Future<Response> doGet(String url) throws IOException {         return doGet(url,(Headers) null);     }      public Future<Response> doGet(String url, Headers headers) throws IOException {         return doGet(url, headers,(List<Cookie>) null);     }      public Future<Response> doGet(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), voidHandler);     }      public <T> Future<T> doGet(String url, AsyncHandler<T> handler) throws IOException {         return doGet(url, null, null, handler);     }      public <T> Future<T> doGet(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doGet(url, headers, null, handler);     }      public <T> Future<T> doGet(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), handler);     }      public Future<Response>  doPost(String url, byte[] data) throws IOException {         return doPost(url, null, null, data);     }      public Future<Response>  doPost(String url, Headers headers, byte[] data) throws IOException {         return doPost(url, headers, null, data);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), voidHandler);     }      public Future<Response>  doPost(String url, InputStream data) throws IOException {         return doPost(url, null, null, data, -1);     }      public Future<Response>  doPost(String url, EntityWriter entityWriter) throws IOException {         return doPost(url, null, null, entityWriter, -1);     }      public Future<Response>  doPost(String url, Headers headers, InputStream data) throws IOException {         return doPost(url, headers, null, data, -1);     }      public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter) throws IOException {         return doPost(url, headers, entityWriter, -1);     }      public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPost(url, headers, cookies, data, -1);     }      public Future<Response>  doPost(String url, InputStream data, long length) throws IOException {         return doPost(url, null, null, data, length);     }      public Future<Response>  doPost(String url, Headers headers, InputStream data, long length) throws IOException {         return doPost(url, headers, null, data, length);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), voidHandler);     }     public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), voidHandler);     }      public Future<Response> doPost(String url, Map<String, String> params) throws IOException {         return doPost(url, (Headers)null, (List<Cookie>)null, params);     }      public Future<Response>  doPost(String url, Headers headers, Map<String, String> params) throws IOException {         return doPost(url, headers, null, params);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }      public <T> Future<T> doPost(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, handler);     }      public <T> Future<T> doPost(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), handler);     }      public <T> Future<T> doPost(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, -1, handler);     }      public <T> Future<T> doPost(String url, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, entityWriter, -1, handler);     }      public <T> Future<T> doPost(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, -1, handler);     }      public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, entityWriter, handler, -1);     }      public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length, handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, cookies, data, -1, handler);     }      public <T> Future<T> doPost(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, length, handler);     }      public <T> Future<T> doPost(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, length, handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), handler);     }      public <T> Future<T> doPost(String url, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, params, handler);     }      public <T> Future<T> doPost(String url, Headers headers, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, params, handler);     }         public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }      public Future<Response> doMultipartPost(String url, List<Part> params) throws IOException {         return doMultipartPost(url, null, null, params);     }      public Future<Response> doMultipartPost(String url, Headers headers, List<Part> params) throws IOException {         return doMultipartPost(url, headers, null, params);     }      public Future<Response> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }          public <T> Future<T> doMultipartPost(String url, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, null, null, params, handler);     }      public <T> Future<T> doMultipartPost(String url, Headers headers, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, headers, null, params, handler);     }      public <T> Future<T> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }      public Future<Response> doPut(String url, byte[] data) throws IOException {         return doPut(url, null, null, data);     }      public Future<Response> doPut(String url, Headers headers, byte[] data) throws IOException {         return doPut(url, headers, null, data);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), voidHandler);     }      public Future<Response> doPut(String url, InputStream data) throws IOException {         return doPut(url, null, null, data, -1);     }      public Future<Response> doPut(String url, Headers headers, InputStream data) throws IOException {         return doPut(url, headers, null, data, -1);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPut(url, headers, cookies, data, -1);     }      public Future<Response> doPut(String url, InputStream data, long length) throws IOException {         return doPut(url, null, null, data, length);     }      public Future<Response> doPut(String url, Headers headers, InputStream data, long length) throws IOException {         return doPut(url, headers, null, data, length);     }      public Future<Response> doPut(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPut(url, headers, (List<Cookie>)null, entityWriter, length);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), voidHandler);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), voidHandler);     }      public <T> Future<T> doPut(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, handler);     }      public <T> Future<T> doPut(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), handler);     }      public <T> Future<T> doPut(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, -1, handler);     }      public <T> Future<T> doPut(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, -1, handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, cookies, data, -1, handler);     }      public <T> Future<T> doPut(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, length, handler);     }      public <T> Future<T> doPut(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, length, handler);     }      public <T> Future<T> doPut(String url, Headers headers, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, entityWriter, length, handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), handler);     }      public Future<Response> doDelete(String url) throws IOException {         return doDelete(url, (Headers)null);     }      public Future<Response> doDelete(String url, Headers headers) throws IOException {         return doDelete(url, headers, (List<Cookie>)null);     }      public Future<Response> doDelete(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), voidHandler);     }      public <T> Future<T> doDelete(String url, AsyncHandler<T> handler) throws IOException {         return doDelete(url, null, null, handler);     }      public <T> Future<T> doDelete(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doDelete(url, headers, null, handler);     }      public <T> Future<T> doDelete(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), handler);     }      public Future<Response> doHead(String url) throws IOException {         return doHead(url, (Headers)null);     }      public Future<Response> doHead(String url, Headers headers) throws IOException {         return doHead(url, headers, (List<Cookie>)null);     }      public Future<Response> doHead(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), voidHandler);     }          public <T> Future<T> doHead(String url, AsyncHandler<T> handler) throws IOException {         return doHead(url, null, null, handler);     }      public <T> Future<T> doHead(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doHead(url, headers, null, handler);     }      public <T> Future<T> doHead(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), handler);     }      public <T> Future<T> performRequest(Request request,                                 AsyncHandler<T> handler) throws IOException {         return httpProvider.handle(request, handler);     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> ning : Folder]
						[NT -> http : Folder]
							[NT -> client : Folder]
								[NT -> AsyncHttpClient.java.merge : .java.merge-File]
									[T -> AsyncHttpClient.java : .java-Content "/*  * Copyright 2010 Ning, Inc.  *  * Ning licenses this file to you under the Apache License, version 2.0  * (the "License"); you may not use this file except in compliance with the  * License.  You may obtain a copy of the License at:  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the  * License for the specific language governing permissions and limitations  * under the License.  *  */ package com.ning.http.client;  import com.ning.http.client.Request.EntityWriter; import com.ning.http.client.providers.NettyAsyncHttpProvider;  import java.io.IOException; import java.io.InputStream; import java.util.List; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.Future;  /**  * This class support asynchronous and synchronous HTTP request.  *  * To execute synchronous HTTP request, you just need to do  * {@code  *    AsyncHttpClient c = new AsyncHttpClient();  *    Future<Response> f = c.doGet("http://www.ning.com/").get();  * }  *  * The code above will block until the response is fully received. To execute asynchronous HTTP request, you  * create an {@link AsyncHandler}  *  * {@code  *       AsyncHttpClient c = new AsyncHttpClient();  *       Future<Response> f = c.doGet("http://www.ning.com/", new AsyncHandler<Response>() &#123;  *  *          @Override  *          public Response onCompleted(Response response) throws IOException &#123;  *               // Do something  *              return response;  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Response response = f.get();  *  *      // We are just interested to retrieve the status code.  *     Future<Integer> f = c.doGet("http://www.ning.com/", new AsyncHandler<Integer>() &#123;  *  *          @Override  *          public Integer onCompleted(Response response) throws IOException &#123;  *               // Do something  *              return response.getStatusCode();  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Integer statusCode = f.get();  * }  * The {@link AsyncHandler#onCompleted(com.ning.http.client.Response)} will be invoked once the http response has been fully read, which include  * the http headers and the response body. Note that the entire response will be buffered in memory.  *   * You can also have more control about the how the response is asynchronously processed by using a {@link AsyncStreamingHandler}  * {@code  *      AsyncHttpClient c = new AsyncHttpClient();  *      Future<Response> f = c.doGet("http://www.ning.com/", new AsyncStreamingHandler() &#123;  *  *          @Override  *          public Response onContentReceived(HttpContent content) throws ResponseComplete &#123;  *              if (content instanceof HttpResponseHeaders) &#123;  *                  // The headers have been read  *                  // If you don't want to read the body, or stop processing the response  *                  throw new ResponseComplete();  *              &#125; else if (content instanceof HttpResponseBody) &#123;  *                  HttpResponseBody b = (HttpResponseBody) content;  *                  // Do something with the body. It may not been fully read yet.  *                  if (b.isComplete()) &#123;  *                      // The full response has been read.  *                  &#125;  *              &#125;  *              return content.getResponse();  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Response response = f.get();  * }  * From an {@link HttpContent}, you can asynchronously process the response headers and body and decide when to  * stop the processing the response by throwing {@link AsyncStreamingHandler.ResponseComplete} at any moment. The returned  * {@link Response} will be incomplete until {@link HttpResponseBody#isComplete()} return true, which means the  * response has been fully read and buffered in memory.  *  * This class can also be used with the need of {@link AsyncHandler}</p>  * {@code  *      AsyncHttpClient c = new AsyncHttpClient();  *      Future<Response> f = c.doGet(TARGET_URL);  *      Response r = f.get();  * }  */ public class AsyncHttpClient {     public static final int DEFAULT_MAX_TOTAL_CONNECTIONS = Integer.getInteger("xn.httpClient.defaultMaxTotalConnections", 2000);     public static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = Integer.getInteger("xn.httpClient.defaultMaxConnectionsPerHost", 2000);     public static final long DEFAULT_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultConnectionTimeoutInMS", 60 * 1000L);     public static final long DEFAULT_IDLE_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultIdleConnectionTimeoutInMS", 15 * 1000L);     public static final int DEFAULT_REQUEST_TIMEOUT_MS = Integer.getInteger("xn.httpClient.defaultRequestTimeoutInMS", 60 * 1000);     public static final boolean DEFAULT_REDIRECTS_ENABLED = Boolean.getBoolean("xn.httpClient.defaultRedirectsEnabled");     public static final int DEFAULT_MAX_REDIRECTS = Integer.getInteger("xn.httpClient.defaultMaxRedirects", 5);      private final AsyncHttpProvider httpProvider;      public AsyncHttpClient() {         this(new NettyAsyncHttpProvider(new ProviderConfig(                 Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()))));     }      public AsyncHttpClient(AsyncHttpProvider httpProvider) {         this.httpProvider = httpProvider;          setMaximumConnectionsTotal(DEFAULT_MAX_TOTAL_CONNECTIONS);         setMaximumConnectionsPerHost(DEFAULT_MAX_CONNECTIONS_PER_HOST);         setFollowRedirects(DEFAULT_REDIRECTS_ENABLED);         setRequestTimeout(DEFAULT_REQUEST_TIMEOUT_MS);         setConnectionTimeout(DEFAULT_CONNECTION_TIMEOUT_MS);         setIdleConnectionTimeout(DEFAULT_IDLE_CONNECTION_TIMEOUT_MS);         setMaximumNumberOfRedirects(DEFAULT_MAX_REDIRECTS);     }      private final static AsyncHandler<Response> voidHandler = new AsyncHandler<Response>(){          @Override         public Response onCompleted(Response response) throws IOException{             return response;         }          @Override         public void onThrowable(Throwable t) {             t.printStackTrace();         }      };       public AsyncHttpProvider getProvider() {         return httpProvider;     }      public void close() {         httpProvider.close();     }      @Override     protected void finalize() throws Throwable {         close();         super.finalize();     }      public void setMaximumConnectionsTotal(int maxConnectionsTotal) {         httpProvider.setMaximumConnectionsTotal(maxConnectionsTotal);     }      public void setMaximumConnectionsPerHost(int maxConnectionsPerHost) {         httpProvider.setMaximumConnectionsPerHost(maxConnectionsPerHost);     }      public void setConnectionTimeout(long timeOutInMS) {         httpProvider.setConnectionTimeout(timeOutInMS);     }      public void setIdleConnectionTimeout(long timeOutInMS) {         httpProvider.setIdleConnectionTimeout(timeOutInMS);     }      public void setRequestTimeout(int timeOutInMS) {         httpProvider.setRequestTimeout(timeOutInMS);     }      public void setFollowRedirects(boolean followRedirects) {         httpProvider.setFollowRedirects(followRedirects);     }      public void setMaximumNumberOfRedirects(int maxNumRedirects) {         httpProvider.setMaximumNumberOfRedirects(maxNumRedirects);     }      public void setCompressionEnabled(boolean compressionEnabled) {         httpProvider.setCompressionEnabled(compressionEnabled);     }      public void setUserAgent(String userAgent) {         httpProvider.setUserAgent(userAgent);     }      /**      * Sets the proxy for this HttpClient.      *      * @param proxyServer The proxy server to use. Can be null, which means "no proxy".      */     public void setProxy(final ProxyServer proxyServer) {         httpProvider.setProxyServer(proxyServer);     }      public boolean isCompressionEnabled() {         return httpProvider.isCompressionEnabled();     }       public Future<Response> doGet(String url) throws IOException {         return doGet(url,(Headers) null);     }      public Future<Response> doGet(String url, Headers headers) throws IOException {         return doGet(url, headers,(List<Cookie>) null);     }      public Future<Response> doGet(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), voidHandler);     }      public <T> Future<T> doGet(String url, AsyncHandler<T> handler) throws IOException {         return doGet(url, null, null, handler);     }      public <T> Future<T> doGet(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doGet(url, headers, null, handler);     }      public <T> Future<T> doGet(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.GET, url, headers, cookies), handler);     }      public Future<Response>  doPost(String url, byte[] data) throws IOException {         return doPost(url, null, null, data);     }      public Future<Response>  doPost(String url, Headers headers, byte[] data) throws IOException {         return doPost(url, headers, null, data);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), voidHandler);     }      public Future<Response>  doPost(String url, InputStream data) throws IOException {         return doPost(url, null, null, data, -1);     }      public Future<Response>  doPost(String url, EntityWriter entityWriter) throws IOException {         return doPost(url, null, null, entityWriter, -1);     }      public Future<Response>  doPost(String url, Headers headers, InputStream data) throws IOException {         return doPost(url, headers, null, data, -1);     }      public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter) throws IOException {         return doPost(url, headers, entityWriter, -1);     }      public Future<Response>  doPost(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPost(url, headers, cookies, data, -1);     }      public Future<Response>  doPost(String url, InputStream data, long length) throws IOException {         return doPost(url, null, null, data, length);     }      public Future<Response>  doPost(String url, Headers headers, InputStream data, long length) throws IOException {         return doPost(url, headers, null, data, length);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), voidHandler);     }     public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), voidHandler);     }      public Future<Response> doPost(String url, Map<String, String> params) throws IOException {         return doPost(url, (Headers)null, (List<Cookie>)null, params);     }      public Future<Response>  doPost(String url, Headers headers, Map<String, String> params) throws IOException {         return doPost(url, headers, null, params);     }      public Future<Response>  doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }      public <T> Future<T> doPost(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, handler);     }      public <T> Future<T> doPost(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data), handler);     }      public <T> Future<T> doPost(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, -1, handler);     }      public <T> Future<T> doPost(String url, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, entityWriter, -1, handler);     }      public <T> Future<T> doPost(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, -1, handler);     }      public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, entityWriter, handler, -1);     }      public <T> Future<T> doPost(String url, Headers headers, EntityWriter entityWriter, AsyncHandler<T> handler, long length) throws IOException {         return doPost(url, headers, null, entityWriter, length, handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, cookies, data, -1, handler);     }      public <T> Future<T> doPost(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, data, length, handler);     }      public <T> Future<T> doPost(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, data, length, handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, data, length), handler);     }      public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, entityWriter, length), handler);     }      public <T> Future<T> doPost(String url, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, null, null, params, handler);     }      public <T> Future<T> doPost(String url, Headers headers, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return doPost(url, headers, null, params, handler);     }         public <T> Future<T> doPost(String url, Headers headers, List<Cookie> cookies, Map<String, String> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }      public Future<Response> doMultipartPost(String url, List<Part> params) throws IOException {         return doMultipartPost(url, null, null, params);     }      public Future<Response> doMultipartPost(String url, Headers headers, List<Part> params) throws IOException {         return doMultipartPost(url, headers, null, params);     }      public Future<Response> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), voidHandler);     }          public <T> Future<T> doMultipartPost(String url, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, null, null, params, handler);     }      public <T> Future<T> doMultipartPost(String url, Headers headers, List<Part> params, AsyncHandler<T> handler) throws IOException {         return doMultipartPost(url, headers, null, params, handler);     }      public <T> Future<T> doMultipartPost(String url, Headers headers, List<Cookie> cookies, List<Part> params, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.POST, url, headers, cookies, params), handler);     }      public Future<Response> doPut(String url, byte[] data) throws IOException {         return doPut(url, null, null, data);     }      public Future<Response> doPut(String url, Headers headers, byte[] data) throws IOException {         return doPut(url, headers, null, data);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), voidHandler);     }      public Future<Response> doPut(String url, InputStream data) throws IOException {         return doPut(url, null, null, data, -1);     }      public Future<Response> doPut(String url, Headers headers, InputStream data) throws IOException {         return doPut(url, headers, null, data, -1);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data) throws IOException {         return doPut(url, headers, cookies, data, -1);     }      public Future<Response> doPut(String url, InputStream data, long length) throws IOException {         return doPut(url, null, null, data, length);     }      public Future<Response> doPut(String url, Headers headers, InputStream data, long length) throws IOException {         return doPut(url, headers, null, data, length);     }      public Future<Response> doPut(String url, Headers headers, EntityWriter entityWriter, long length) throws IOException {         return doPut(url, headers, (List<Cookie>)null, entityWriter, length);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), voidHandler);     }      public Future<Response> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), voidHandler);     }      public <T> Future<T> doPut(String url, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, handler);     }      public <T> Future<T> doPut(String url, Headers headers, byte[] data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, byte[] data, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data), handler);     }      public <T> Future<T> doPut(String url, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, -1, handler);     }      public <T> Future<T> doPut(String url, Headers headers, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, -1, handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, cookies, data, -1, handler);     }      public <T> Future<T> doPut(String url, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, null, null, data, length, handler);     }      public <T> Future<T> doPut(String url, Headers headers, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, data, length, handler);     }      public <T> Future<T> doPut(String url, Headers headers, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return doPut(url, headers, null, entityWriter, length, handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, InputStream data, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, data, length), handler);     }      public <T> Future<T> doPut(String url, Headers headers, List<Cookie> cookies, EntityWriter entityWriter, long length, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.PUT, url, headers, cookies, entityWriter, length), handler);     }      public Future<Response> doDelete(String url) throws IOException {         return doDelete(url, (Headers)null);     }      public Future<Response> doDelete(String url, Headers headers) throws IOException {         return doDelete(url, headers, (List<Cookie>)null);     }      public Future<Response> doDelete(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), voidHandler);     }      public <T> Future<T> doDelete(String url, AsyncHandler<T> handler) throws IOException {         return doDelete(url, null, null, handler);     }      public <T> Future<T> doDelete(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doDelete(url, headers, null, handler);     }      public <T> Future<T> doDelete(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.DELETE, url, headers, cookies), handler);     }      public Future<Response> doHead(String url) throws IOException {         return doHead(url, (Headers)null);     }      public Future<Response> doHead(String url, Headers headers) throws IOException {         return doHead(url, headers, (List<Cookie>)null);     }      public Future<Response> doHead(String url, Headers headers, List<Cookie> cookies) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), voidHandler);     }          public <T> Future<T> doHead(String url, AsyncHandler<T> handler) throws IOException {         return doHead(url, null, null, handler);     }      public <T> Future<T> doHead(String url, Headers headers, AsyncHandler<T> handler) throws IOException {         return doHead(url, headers, null, handler);     }      public <T> Future<T> doHead(String url, Headers headers, List<Cookie> cookies, AsyncHandler<T> handler) throws IOException {         return performRequest(new Request(RequestType.HEAD, url, headers, cookies), handler);     }      public <T> Future<T> performRequest(Request request,                                 AsyncHandler<T> handler) throws IOException {         return httpProvider.handle(request, handler);     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> ning : Folder]
						[NT -> http : Folder]
							[NT -> client : Folder]
								[NT -> AsyncHttpClient.java.merge : .java.merge-File]
									[T -> AsyncHttpClient.java : .java-Content "/*  * Copyright 2010 Ning, Inc.  *  * Ning licenses this file to you under the Apache License, version 2.0  * (the "License"); you may not use this file except in compliance with the  * License.  You may obtain a copy of the License at:  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the  * License for the specific language governing permissions and limitations  * under the License.  *  */ package com.ning.http.client;  import com.ning.http.client.providers.NettyAsyncHttpProvider;  import java.io.IOException; import java.util.concurrent.Executors; import java.util.concurrent.Future;  /**  * This class support asynchronous and synchronous HTTP request.  *  * To execute synchronous HTTP request, you just need to do  * {@code  *    AsyncHttpClient c = new AsyncHttpClient();  *    Future<Response> f = c.doGet("http://www.ning.com/").get();  * }  *  * The code above will block until the response is fully received. To execute asynchronous HTTP request, you  * create an {@link AsyncHandler}  *  * {@code  *       AsyncHttpClient c = new AsyncHttpClient();  *       Future<Response> f = c.prepareGet("http://www.ning.com/").execute(new AsyncHandler<Response>() &#123;  *  *          @Override  *          public Response onCompleted(Response response) throws IOException &#123;  *               // Do something  *              return response;  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Response response = f.get();  *  *      // We are just interested to retrieve the status code.  *     Future<Integer> f = c.prepareGet("http://www.ning.com/").execute(new AsyncHandler<Integer>() &#123;  *  *          @Override  *          public Integer onCompleted(Response response) throws IOException &#123;  *               // Do something  *              return response.getStatusCode();  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Integer statusCode = f.get();  * }  * The {@link AsyncHandler#onCompleted(com.ning.http.client.Response)} will be invoked once the http response has been fully read, which include  * the http headers and the response body. Note that the entire response will be buffered in memory.  *   * You can also have more control about the how the response is asynchronously processed by using a {@link AsyncStreamingHandler}  * {@code  *      AsyncHttpClient c = new AsyncHttpClient();  *      Future<Response> f = c.prepareGet("http://www.ning.com/").execute(new AsyncStreamingHandler() &#123;  *  *          @Override  *          public Response onContentReceived(HttpContent content) throws ResponseComplete &#123;  *              if (content instanceof HttpResponseHeaders) &#123;  *                  // The headers have been read  *                  // If you don't want to read the body, or stop processing the response  *                  throw new ResponseComplete();  *              &#125; else if (content instanceof HttpResponseBody) &#123;  *                  HttpResponseBody b = (HttpResponseBody) content;  *                  // Do something with the body. It may not been fully read yet.  *                  if (b.isComplete()) &#123;  *                      // The full response has been read.  *                  &#125;  *              &#125;  *              return content.getResponse();  *          &#125;  *  *          @Override  *          public void onThrowable(Throwable t) &#123;  *          &#125;  *      &#125;);  *      Response response = f.get();  * }  * From an {@link HttpContent}, you can asynchronously process the response headers and body and decide when to  * stop the processing the response by throwing {@link AsyncStreamingHandler.ResponseComplete} at any moment. The returned  * {@link Response} will be incomplete until {@link HttpResponseBody#isComplete()} return true, which means the  * response has been fully read and buffered in memory.  *  * This class can also be used without the need of {@link AsyncHandler}</p>  * {@code  *      AsyncHttpClient c = new AsyncHttpClient();  *      Future<Response> f = c.prepareGet(TARGET_URL).execute();  *      Response r = f.get();  * }  */ public class AsyncHttpClient {     public static final int DEFAULT_MAX_TOTAL_CONNECTIONS = Integer.getInteger("xn.httpClient.defaultMaxTotalConnections", 2000);     public static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = Integer.getInteger("xn.httpClient.defaultMaxConnectionsPerHost", 2000);     public static final long DEFAULT_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultConnectionTimeoutInMS", 60 * 1000L);     public static final long DEFAULT_IDLE_CONNECTION_TIMEOUT_MS = Long.getLong("xn.httpClient.defaultIdleConnectionTimeoutInMS", 15 * 1000L);     public static final int DEFAULT_REQUEST_TIMEOUT_MS = Integer.getInteger("xn.httpClient.defaultRequestTimeoutInMS", 60 * 1000);     public static final boolean DEFAULT_REDIRECTS_ENABLED = Boolean.getBoolean("xn.httpClient.defaultRedirectsEnabled");     public static final int DEFAULT_MAX_REDIRECTS = Integer.getInteger("xn.httpClient.defaultMaxRedirects", 5);      private final AsyncHttpProvider httpProvider;      public AsyncHttpClient() {         this(new NettyAsyncHttpProvider(new ProviderConfig(                 Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()))));     }      public AsyncHttpClient(AsyncHttpProvider httpProvider) {         this.httpProvider = httpProvider;          setMaximumConnectionsTotal(DEFAULT_MAX_TOTAL_CONNECTIONS);         setMaximumConnectionsPerHost(DEFAULT_MAX_CONNECTIONS_PER_HOST);         setFollowRedirects(DEFAULT_REDIRECTS_ENABLED);         setRequestTimeout(DEFAULT_REQUEST_TIMEOUT_MS);         setConnectionTimeout(DEFAULT_CONNECTION_TIMEOUT_MS);         setIdleConnectionTimeout(DEFAULT_IDLE_CONNECTION_TIMEOUT_MS);         setMaximumNumberOfRedirects(DEFAULT_MAX_REDIRECTS);     }      private final static AsyncHandler<Response> voidHandler = new AsyncHandler<Response>(){          @Override         public Response onCompleted(Response response) throws IOException{             return response;         }          @Override         public void onThrowable(Throwable t) {             t.printStackTrace();         }      };      public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {         private BoundRequestBuilder(RequestType type) {             super(type);         }          private BoundRequestBuilder(Request prototype) {             super(prototype);         }          public <T> Future<T> execute(AsyncHandler<T> handler) throws IOException {             return AsyncHttpClient.this.performRequest(build(), handler);         }          public Future<Response> execute() throws IOException {             return AsyncHttpClient.this.performRequest(build(), voidHandler);         }     }      public AsyncHttpProvider getProvider() {         return httpProvider;     }      public void close() {         httpProvider.close();     }      @Override     protected void finalize() throws Throwable {         close();         super.finalize();     }      public void setMaximumConnectionsTotal(int maxConnectionsTotal) {         httpProvider.setMaximumConnectionsTotal(maxConnectionsTotal);     }      public void setMaximumConnectionsPerHost(int maxConnectionsPerHost) {         httpProvider.setMaximumConnectionsPerHost(maxConnectionsPerHost);     }      public void setConnectionTimeout(long timeOutInMS) {         httpProvider.setConnectionTimeout(timeOutInMS);     }      public void setIdleConnectionTimeout(long timeOutInMS) {         httpProvider.setIdleConnectionTimeout(timeOutInMS);     }      public void setRequestTimeout(int timeOutInMS) {         httpProvider.setRequestTimeout(timeOutInMS);     }      public void setFollowRedirects(boolean followRedirects) {         httpProvider.setFollowRedirects(followRedirects);     }      public void setMaximumNumberOfRedirects(int maxNumRedirects) {         httpProvider.setMaximumNumberOfRedirects(maxNumRedirects);     }      public void setCompressionEnabled(boolean compressionEnabled) {         httpProvider.setCompressionEnabled(compressionEnabled);     }      public void setUserAgent(String userAgent) {         httpProvider.setUserAgent(userAgent);     }      /**      * Sets the proxy for this HttpClient.      *      * @param proxyServer The proxy server to use. Can be null, which means "no proxy".      */     public void setProxy(final ProxyServer proxyServer) {         httpProvider.setProxyServer(proxyServer);     }      public boolean isCompressionEnabled() {         return httpProvider.isCompressionEnabled();     }          public BoundRequestBuilder prepareGet(String url) {         return new BoundRequestBuilder(RequestType.GET).setUrl(url);     }      public BoundRequestBuilder prepareHead(String url) {         return new BoundRequestBuilder(RequestType.HEAD).setUrl(url);     }      public BoundRequestBuilder preparePost(String url) {         return new BoundRequestBuilder(RequestType.POST).setUrl(url);     }      public BoundRequestBuilder preparePut(String url) {         return new BoundRequestBuilder(RequestType.PUT).setUrl(url);     }      public BoundRequestBuilder prepareDelete(String url) {         return new BoundRequestBuilder(RequestType.DELETE).setUrl(url);     }      public BoundRequestBuilder prepareRequest(Request request) {         return new BoundRequestBuilder(request);     }      public <T> Future<T> performRequest(Request request, AsyncHandler<T> handler) throws IOException {         return httpProvider.handle(request, handler);     } } " compose:StringConcatenation merge: LineBased]
