Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/hibernate-core/src/main/java/org/hibernate/query/criteria/internal/expression/LiteralExpression.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/hibernate-core/src/main/java/org/hibernate/query/criteria/internal/expression/LiteralExpression.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/hibernate-core/src/main/java/org/hibernate/query/criteria/internal/expression/LiteralExpression.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/hibernate-core/src/main/java/org/hibernate/query/criteria/internal/expression/LiteralExpression.java
[NT -> base : Feature]
	[NT -> hibernate-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> hibernate : Folder]
							[NT -> query : Folder]
								[NT -> criteria : Folder]
									[NT -> internal : Folder]
										[NT -> expression : Folder]
											[NT -> LiteralExpression.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package org.hibernate.query.criteria.internal.expression;" compose:Replacement merge: Default]
													[T -> java.io.Serializable{ImportPackage} : ImportDeclaration "import java.io.Serializable;" compose:Replacement merge: Default]
													[T -> org.hibernate.internal.util.StringHelper{ImportPackage} : ImportDeclaration "import org.hibernate.internal.util.StringHelper;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.LiteralHandlingMode{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.LiteralHandlingMode;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.CriteriaBuilderImpl{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.CriteriaBuilderImpl;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.ParameterRegistry{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.ParameterRegistry;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.ValueHandlerFactory{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.ValueHandlerFactory;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.ValueHandlerFactory.ValueHandler{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.ValueHandlerFactory.ValueHandler;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.compile.RenderingContext{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.compile.RenderingContext;" compose:Replacement merge: Default]
													[NT -> LiteralExpression : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> LiteralExpression : Id "LiteralExpression" compose:Replacement merge: Default]
														[T -> - : TypeParameters "<T>" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends ExpressionImpl<T>" compose:Replacement merge: Default]
														[T -> ImplList : ImplementsList "implements Serializable" compose:Replacement merge: SemanticConflict]
														[T -> literal : FieldDecl "private Object literal;" compose:Replacement merge: SemanticConflict]
														[T -> LiteralExpression(CriteriaBuilderImpl-CriteriaBuilderImpl-T-T) : ConstructorDecl "@SuppressWarnings({ "unchecked" })  public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, T literal) {   this( criteriaBuilder, (Class<T>) determineClass( literal ), literal );  }" compose:Replacement merge: LineBased]
														[T -> determineClass(Object-Object) : MethodDecl "private static Class determineClass(Object literal) {   return literal == null ? null : literal.getClass();  }" compose:Replacement merge: LineBased]
														[T -> LiteralExpression(CriteriaBuilderImpl-CriteriaBuilderImpl-Class<T>-Class<T>-T-T) : ConstructorDecl "public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, Class<T> type, T literal) {   super( criteriaBuilder, type );   this.literal = literal;  }" compose:Replacement merge: LineBased]
														[T -> getLiteral({FormalParametersInternal}) : MethodDecl "@SuppressWarnings({ "unchecked" })  public T getLiteral() {   return (T) literal;  }" compose:Replacement merge: LineBased]
														[T -> registerParameters(ParameterRegistry-ParameterRegistry) : MethodDecl "@Override  public void registerParameters(ParameterRegistry registry) {   // nothing to do  }" compose:Replacement merge: LineBased]
														[T -> render(RenderingContext-RenderingContext) : MethodDecl "@Override  public String render(RenderingContext renderingContext) {   // In the case of literals, we currently do not have an easy way to get the value.   // That would require some significant infrastructure changes.   // For now, we force the normalRender() code path for enums which means we will   // always use parameter binding for enum literals.   if ( literal instanceof Enum ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }    switch ( renderingContext.getClauseStack().getCurrent() ) {    case SELECT: {     return renderProjection( renderingContext );    }    case GROUP: {     // technically a literal in the group-by clause     // would be a reference to the position of a selection     //     // but this is what the code used to do...     return renderProjection( renderingContext );    }    default: {     return normalRender( renderingContext, renderingContext.getCriteriaLiteralHandlingMode() );    }   }  }" compose:Replacement merge: LineBased]
														[T -> normalRender(RenderingContext-RenderingContext-LiteralHandlingMode-LiteralHandlingMode) : MethodDecl "@SuppressWarnings("unchecked")  private String normalRender(RenderingContext renderingContext, LiteralHandlingMode literalHandlingMode) {   switch ( literalHandlingMode ) {    case AUTO: {     if ( ValueHandlerFactory.isNumeric( literal ) ) {      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literal );     }     else {      return bindLiteral( renderingContext );     }    }    case BIND: {     return bindLiteral( renderingContext );    }    case INLINE: {     Object literalValue = literal;     if ( String.class.equals( literal.getClass() ) ) {      literalValue = renderingContext.getDialect().inlineLiteral( (String) literal );     }      ValueHandler valueHandler = ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() );     if ( valueHandler == null ) {      return bindLiteral( renderingContext );     }      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literalValue );    }    default: {     throw new IllegalArgumentException( "Unexpected LiteralHandlingMode: " + literalHandlingMode );    }   }  }" compose:Replacement merge: LineBased]
														[T -> renderProjection(RenderingContext-RenderingContext) : MethodDecl "private String renderProjection(RenderingContext renderingContext) {   // some drivers/servers do not like parameters in the select clause   final ValueHandlerFactory.ValueHandler handler =     ValueHandlerFactory.determineAppropriateHandler( literal.getClass() );    if ( handler == null ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }    if ( ValueHandlerFactory.isCharacter( literal ) ) {    return renderingContext.getDialect().inlineLiteral( handler.render( literal ) );   }   else {    return handler.render( literal );   }  }" compose:Replacement merge: LineBased]
														[T -> bindLiteral(RenderingContext-RenderingContext) : MethodDecl "private String bindLiteral(RenderingContext renderingContext) {   final String parameterName = renderingContext.registerLiteralParameterBinding( getLiteral(), getJavaType() );   return ':' + parameterName;  }" compose:Replacement merge: LineBased]
														[T -> resetJavaType(Class-Class) : MethodDecl "@Override  @SuppressWarnings({ "unchecked" })  protected void resetJavaType(Class targetType) {   super.resetJavaType( targetType );   ValueHandlerFactory.ValueHandler valueHandler = getValueHandler();   if ( valueHandler == null ) {    valueHandler = ValueHandlerFactory.determineAppropriateHandler( targetType );    forceConversion( valueHandler );   }    if ( valueHandler != null ) {    literal = valueHandler.convert( literal );   }  }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> hibernate-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> hibernate : Folder]
							[NT -> query : Folder]
								[NT -> criteria : Folder]
									[NT -> internal : Folder]
										[NT -> expression : Folder]
											[NT -> LiteralExpression.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package org.hibernate.query.criteria.internal.expression;" compose:Replacement merge: Default]
													[T -> java.io.Serializable{ImportPackage} : ImportDeclaration "import java.io.Serializable;" compose:Replacement merge: Default]
													[T -> org.hibernate.internal.util.StringHelper{ImportPackage} : ImportDeclaration "import org.hibernate.internal.util.StringHelper;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.LiteralHandlingMode{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.LiteralHandlingMode;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.CriteriaBuilderImpl{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.CriteriaBuilderImpl;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.ParameterRegistry{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.ParameterRegistry;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.ValueHandlerFactory{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.ValueHandlerFactory;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.ValueHandlerFactory.ValueHandler{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.ValueHandlerFactory.ValueHandler;" compose:Replacement merge: Default]
													[T -> org.hibernate.query.criteria.internal.compile.RenderingContext{ImportPackage} : ImportDeclaration "import org.hibernate.query.criteria.internal.compile.RenderingContext;" compose:Replacement merge: Default]
													[NT -> LiteralExpression : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> LiteralExpression : Id "LiteralExpression" compose:Replacement merge: Default]
														[T -> - : TypeParameters "<T>" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends ExpressionImpl<T>" compose:Replacement merge: Default]
														[T -> ImplList : ImplementsList "implements Serializable" compose:Replacement merge: SemanticConflict]
														[T -> literal : FieldDecl "private Object literal;" compose:Replacement merge: SemanticConflict]
														[T -> LiteralExpression(CriteriaBuilderImpl-CriteriaBuilderImpl-T-T) : ConstructorDecl "@SuppressWarnings({ "unchecked" })  public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, T literal) {   this( criteriaBuilder, (Class<T>) determineClass( literal ), literal );  }" compose:Replacement merge: LineBased]
														[T -> determineClass(Object-Object) : MethodDecl "private static Class determineClass(Object literal) {   return literal == null ? null : literal.getClass();  }" compose:Replacement merge: LineBased]
														[T -> LiteralExpression(CriteriaBuilderImpl-CriteriaBuilderImpl-Class<T>-Class<T>-T-T) : ConstructorDecl "public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, Class<T> type, T literal) {   super( criteriaBuilder, type );   this.literal = literal;  }" compose:Replacement merge: LineBased]
														[T -> getLiteral({FormalParametersInternal}) : MethodDecl "@SuppressWarnings({ "unchecked" })  public T getLiteral() {   return (T) literal;  }" compose:Replacement merge: LineBased]
														[T -> registerParameters(ParameterRegistry-ParameterRegistry) : MethodDecl "@Override  public void registerParameters(ParameterRegistry registry) {   // nothing to do  }" compose:Replacement merge: LineBased]
														[T -> render(RenderingContext-RenderingContext) : MethodDecl "@Override  public String render(RenderingContext renderingContext) {   // In the case of literals, we currently do not have an easy way to get the value.   // That would require some significant infrastructure changes.   // For now, we force the normalRender() code path for enums which means we will   // always use parameter binding for enum literals.   if ( literal instanceof Enum ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }    switch ( renderingContext.getClauseStack().getCurrent() ) {    case SELECT: {     return renderProjection( renderingContext );    }    case GROUP: {     // technically a literal in the group-by clause     // would be a reference to the position of a selection     //     // but this is what the code used to do...     return renderProjection( renderingContext );    }    default: {     return normalRender( renderingContext, renderingContext.getCriteriaLiteralHandlingMode() );    }   }  }" compose:Replacement merge: LineBased]
														[T -> normalRender(RenderingContext-RenderingContext-LiteralHandlingMode-LiteralHandlingMode) : MethodDecl "@SuppressWarnings("unchecked")  private String normalRender(RenderingContext renderingContext, LiteralHandlingMode literalHandlingMode) {   switch ( literalHandlingMode ) {    case AUTO: {     if ( ValueHandlerFactory.isNumeric( literal ) ) {      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literal );     }     else {      return bindLiteral( renderingContext );     }    }    case BIND: {     return bindLiteral( renderingContext );    }    case INLINE: {     Object literalValue = literal;     if ( String.class.equals( literal.getClass() ) ) {      literalValue = renderingContext.getDialect().inlineLiteral( (String) literal );     }      ValueHandler valueHandler = ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() );     if ( valueHandler == null ) {      return bindLiteral( renderingContext );     }      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literalValue );    }    default: {     throw new IllegalArgumentException( "Unexpected LiteralHandlingMode: " + literalHandlingMode );    }   }  }" compose:Replacement merge: LineBased]
														[T -> renderProjection(RenderingContext-RenderingContext) : MethodDecl "private String renderProjection(RenderingContext renderingContext) {   if ( ValueHandlerFactory.isCharacter( literal ) ) {    // In case literal is a Character, pass literal.toString() as the argument.    return renderingContext.getDialect().inlineLiteral( literal.toString() );   }    // some drivers/servers do not like parameters in the select clause   final ValueHandlerFactory.ValueHandler handler =     ValueHandlerFactory.determineAppropriateHandler( literal.getClass() );    if ( handler == null ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }   else {    return handler.render( literal );   }  }" compose:Replacement merge: LineBased]
														[T -> bindLiteral(RenderingContext-RenderingContext) : MethodDecl "private String bindLiteral(RenderingContext renderingContext) {   final String parameterName = renderingContext.registerLiteralParameterBinding( getLiteral(), getJavaType() );   return ':' + parameterName;  }" compose:Replacement merge: LineBased]
														[T -> resetJavaType(Class-Class) : MethodDecl "@Override  @SuppressWarnings({ "unchecked" })  protected void resetJavaType(Class targetType) {   super.resetJavaType( targetType );   ValueHandlerFactory.ValueHandler valueHandler = getValueHandler();   if ( valueHandler == null ) {    valueHandler = ValueHandlerFactory.determineAppropriateHandler( targetType );    forceConversion( valueHandler );   }    if ( valueHandler != null ) {    literal = valueHandler.convert( literal );   }  }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> hibernate-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> hibernate : Folder]
							[NT -> query : Folder]
								[NT -> criteria : Folder]
									[NT -> internal : Folder]
										[NT -> expression : Folder]
											[NT -> LiteralExpression.java.merge : .java.merge-File]
												[T -> LiteralExpression.java : .java-Content "/*  * Hibernate, Relational Persistence for Idiomatic Java  *  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.  */ package org.hibernate.query.criteria.internal.expression;  import java.io.Serializable;  import org.hibernate.internal.util.StringHelper; import org.hibernate.query.criteria.LiteralHandlingMode; import org.hibernate.query.criteria.internal.CriteriaBuilderImpl; import org.hibernate.query.criteria.internal.ParameterRegistry; import org.hibernate.query.criteria.internal.ValueHandlerFactory; import org.hibernate.query.criteria.internal.ValueHandlerFactory.ValueHandler; import org.hibernate.query.criteria.internal.compile.RenderingContext;  /**  * Represents a literal expression.  *  * @author Steve Ebersole  */ public class LiteralExpression<T> extends ExpressionImpl<T> implements Serializable {   private Object literal;   @SuppressWarnings({ "unchecked" })  public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, T literal) {   this( criteriaBuilder, (Class<T>) determineClass( literal ), literal );  }   private static Class determineClass(Object literal) {   return literal == null ? null : literal.getClass();  }   public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, Class<T> type, T literal) {   super( criteriaBuilder, type );   this.literal = literal;  }   @SuppressWarnings({ "unchecked" })  public T getLiteral() {   return (T) literal;  }   @Override  public void registerParameters(ParameterRegistry registry) {   // nothing to do  }   @Override  public String render(RenderingContext renderingContext) {   // In the case of literals, we currently do not have an easy way to get the value.   // That would require some significant infrastructure changes.   // For now, we force the normalRender() code path for enums which means we will   // always use parameter binding for enum literals.   if ( literal instanceof Enum ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }    switch ( renderingContext.getClauseStack().getCurrent() ) {    case SELECT: {     return renderProjection( renderingContext );    }    case GROUP: {     // technically a literal in the group-by clause     // would be a reference to the position of a selection     //     // but this is what the code used to do...     return renderProjection( renderingContext );    }    default: {     return normalRender( renderingContext, renderingContext.getCriteriaLiteralHandlingMode() );    }   }  }   @SuppressWarnings("unchecked")  private String normalRender(RenderingContext renderingContext, LiteralHandlingMode literalHandlingMode) {   switch ( literalHandlingMode ) {    case AUTO: {     if ( ValueHandlerFactory.isNumeric( literal ) ) {      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literal );     }     else {      return bindLiteral( renderingContext );     }    }    case BIND: {     return bindLiteral( renderingContext );    }    case INLINE: {     Object literalValue = literal;     if ( String.class.equals( literal.getClass() ) ) {      literalValue = renderingContext.getDialect().inlineLiteral( (String) literal );     }      ValueHandler valueHandler = ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() );     if ( valueHandler == null ) {      return bindLiteral( renderingContext );     }      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literalValue );    }    default: {     throw new IllegalArgumentException( "Unexpected LiteralHandlingMode: " + literalHandlingMode );    }   }  }   private String renderProjection(RenderingContext renderingContext) {   // some drivers/servers do not like parameters in the select clause   final ValueHandlerFactory.ValueHandler handler =     ValueHandlerFactory.determineAppropriateHandler( literal.getClass() );    if ( handler == null ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }    if ( ValueHandlerFactory.isCharacter( literal ) ) {    return renderingContext.getDialect().inlineLiteral( handler.render( literal ) );   }   else {    return handler.render( literal );   }  }   private String bindLiteral(RenderingContext renderingContext) {   final String parameterName = renderingContext.registerLiteralParameterBinding( getLiteral(), getJavaType() );   return ':' + parameterName;  }   @Override  @SuppressWarnings({ "unchecked" })  protected void resetJavaType(Class targetType) {   super.resetJavaType( targetType );   ValueHandlerFactory.ValueHandler valueHandler = getValueHandler();   if ( valueHandler == null ) {    valueHandler = ValueHandlerFactory.determineAppropriateHandler( targetType );    forceConversion( valueHandler );   }    if ( valueHandler != null ) {    literal = valueHandler.convert( literal );   }  } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> hibernate-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> hibernate : Folder]
							[NT -> query : Folder]
								[NT -> criteria : Folder]
									[NT -> internal : Folder]
										[NT -> expression : Folder]
											[NT -> LiteralExpression.java.merge : .java.merge-File]
												[T -> LiteralExpression.java : .java-Content "/*  * Hibernate, Relational Persistence for Idiomatic Java  *  * License: GNU Lesser General Public License (LGPL), version 2.1 or later.  * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.  */ package org.hibernate.query.criteria.internal.expression;  import java.io.Serializable;  import org.hibernate.internal.util.StringHelper; import org.hibernate.query.criteria.LiteralHandlingMode; import org.hibernate.query.criteria.internal.CriteriaBuilderImpl; import org.hibernate.query.criteria.internal.ParameterRegistry; import org.hibernate.query.criteria.internal.ValueHandlerFactory; import org.hibernate.query.criteria.internal.ValueHandlerFactory.ValueHandler; import org.hibernate.query.criteria.internal.compile.RenderingContext;  /**  * Represents a literal expression.  *  * @author Steve Ebersole  */ public class LiteralExpression<T> extends ExpressionImpl<T> implements Serializable {   private Object literal;   @SuppressWarnings({ "unchecked" })  public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, T literal) {   this( criteriaBuilder, (Class<T>) determineClass( literal ), literal );  }   private static Class determineClass(Object literal) {   return literal == null ? null : literal.getClass();  }   public LiteralExpression(CriteriaBuilderImpl criteriaBuilder, Class<T> type, T literal) {   super( criteriaBuilder, type );   this.literal = literal;  }   @SuppressWarnings({ "unchecked" })  public T getLiteral() {   return (T) literal;  }   @Override  public void registerParameters(ParameterRegistry registry) {   // nothing to do  }   @Override  public String render(RenderingContext renderingContext) {   // In the case of literals, we currently do not have an easy way to get the value.   // That would require some significant infrastructure changes.   // For now, we force the normalRender() code path for enums which means we will   // always use parameter binding for enum literals.   if ( literal instanceof Enum ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }    switch ( renderingContext.getClauseStack().getCurrent() ) {    case SELECT: {     return renderProjection( renderingContext );    }    case GROUP: {     // technically a literal in the group-by clause     // would be a reference to the position of a selection     //     // but this is what the code used to do...     return renderProjection( renderingContext );    }    default: {     return normalRender( renderingContext, renderingContext.getCriteriaLiteralHandlingMode() );    }   }  }   @SuppressWarnings("unchecked")  private String normalRender(RenderingContext renderingContext, LiteralHandlingMode literalHandlingMode) {   switch ( literalHandlingMode ) {    case AUTO: {     if ( ValueHandlerFactory.isNumeric( literal ) ) {      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literal );     }     else {      return bindLiteral( renderingContext );     }    }    case BIND: {     return bindLiteral( renderingContext );    }    case INLINE: {     Object literalValue = literal;     if ( String.class.equals( literal.getClass() ) ) {      literalValue = renderingContext.getDialect().inlineLiteral( (String) literal );     }      ValueHandler valueHandler = ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() );     if ( valueHandler == null ) {      return bindLiteral( renderingContext );     }      return ValueHandlerFactory.determineAppropriateHandler( (Class) literal.getClass() ).render( literalValue );    }    default: {     throw new IllegalArgumentException( "Unexpected LiteralHandlingMode: " + literalHandlingMode );    }   }  }   private String renderProjection(RenderingContext renderingContext) {   if ( ValueHandlerFactory.isCharacter( literal ) ) {    // In case literal is a Character, pass literal.toString() as the argument.    return renderingContext.getDialect().inlineLiteral( literal.toString() );   }    // some drivers/servers do not like parameters in the select clause   final ValueHandlerFactory.ValueHandler handler =     ValueHandlerFactory.determineAppropriateHandler( literal.getClass() );    if ( handler == null ) {    return normalRender( renderingContext, LiteralHandlingMode.BIND );   }   else {    return handler.render( literal );   }  }   private String bindLiteral(RenderingContext renderingContext) {   final String parameterName = renderingContext.registerLiteralParameterBinding( getLiteral(), getJavaType() );   return ':' + parameterName;  }   @Override  @SuppressWarnings({ "unchecked" })  protected void resetJavaType(Class targetType) {   super.resetJavaType( targetType );   ValueHandlerFactory.ValueHandler valueHandler = getValueHandler();   if ( valueHandler == null ) {    valueHandler = ValueHandlerFactory.determineAppropriateHandler( targetType );    forceConversion( valueHandler );   }    if ( valueHandler != null ) {    literal = valueHandler.convert( literal );   }  } } " compose:StringConcatenation merge: LineBased]
