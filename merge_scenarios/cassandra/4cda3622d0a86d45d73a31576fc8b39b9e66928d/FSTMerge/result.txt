Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> java : Folder]
			[NT -> org : Folder]
				[NT -> apache : Folder]
					[NT -> cassandra : Folder]
						[NT -> net : Folder]
							[NT -> OutboundTcpConnection.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package org.apache.cassandra.net;" compose:Replacement merge: Default]
									[T -> java.io.BufferedOutputStream{ImportPackage} : ImportDeclaration "import java.io.BufferedOutputStream;" compose:Replacement merge: Default]
									[T -> java.io.DataInputStream{ImportPackage} : ImportDeclaration "import java.io.DataInputStream;" compose:Replacement merge: Default]
									[T -> java.io.DataOutputStream{ImportPackage} : ImportDeclaration "import java.io.DataOutputStream;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
									[T -> java.net.InetAddress{ImportPackage} : ImportDeclaration "import java.net.InetAddress;" compose:Replacement merge: Default]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: Default]
									[T -> java.net.SocketException{ImportPackage} : ImportDeclaration "import java.net.SocketException;" compose:Replacement merge: Default]
									[T -> java.nio.ByteBuffer{ImportPackage} : ImportDeclaration "import java.nio.ByteBuffer;" compose:Replacement merge: Default]
									[T -> java.util.UUID{ImportPackage} : ImportDeclaration "import java.util.UUID;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.BlockingQueue{ImportPackage} : ImportDeclaration "import java.util.concurrent.BlockingQueue;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.LinkedBlockingQueue{ImportPackage} : ImportDeclaration "import java.util.concurrent.LinkedBlockingQueue;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.TimeUnit{ImportPackage} : ImportDeclaration "import java.util.concurrent.TimeUnit;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.atomic.AtomicLong{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicLong;" compose:Replacement merge: Default]
									[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
									[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.tracing.TraceState{ImportPackage} : ImportDeclaration "import org.apache.cassandra.tracing.TraceState;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.tracing.Tracing{ImportPackage} : ImportDeclaration "import org.apache.cassandra.tracing.Tracing;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.utils.FBUtilities{ImportPackage} : ImportDeclaration "import org.apache.cassandra.utils.FBUtilities;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.utils.UUIDGen{ImportPackage} : ImportDeclaration "import org.apache.cassandra.utils.UUIDGen;" compose:Replacement merge: Default]
									[T -> org.xerial.snappy.SnappyOutputStream{ImportPackage} : ImportDeclaration "import org.xerial.snappy.SnappyOutputStream;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.config.Config{ImportPackage} : ImportDeclaration "import org.apache.cassandra.config.Config;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.config.DatabaseDescriptor{ImportPackage} : ImportDeclaration "import org.apache.cassandra.config.DatabaseDescriptor;" compose:Replacement merge: Default]
									[T -> com.google.common.util.concurrent.Uninterruptibles{ImportPackage} : ImportDeclaration "import com.google.common.util.concurrent.Uninterruptibles;" compose:Replacement merge: Default]
									[NT -> OutboundTcpConnection : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> OutboundTcpConnection : Id "OutboundTcpConnection" compose:Replacement merge: Default]
										[T -> - : ExtendsList "extends Thread" compose:Replacement merge: Default]
										[T -> logger : FieldDecl "private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);" compose:Replacement merge: SemanticConflict]
										[T -> CLOSE_SENTINEL : FieldDecl "private static final MessageOut CLOSE_SENTINEL = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE);" compose:Replacement merge: SemanticConflict]
										[T -> isStopped : FieldDecl "private volatile boolean isStopped = false;" compose:Replacement merge: SemanticConflict]
										[T -> OPEN_RETRY_DELAY : FieldDecl "private static final int OPEN_RETRY_DELAY = 100;" compose:Replacement merge: SemanticConflict]
										[T -> backlog : FieldDecl "private volatile BlockingQueue<QueuedMessage> backlog = new LinkedBlockingQueue<QueuedMessage>();" compose:Replacement merge: SemanticConflict]
										[T -> active : FieldDecl "private volatile BlockingQueue<QueuedMessage> active = new LinkedBlockingQueue<QueuedMessage>();" compose:Replacement merge: SemanticConflict]
										[T -> poolReference : FieldDecl "private final OutboundTcpConnectionPool poolReference;" compose:Replacement merge: SemanticConflict]
										[T -> out : FieldDecl "private DataOutputStream out;" compose:Replacement merge: SemanticConflict]
										[T -> socket : FieldDecl "private Socket socket;" compose:Replacement merge: SemanticConflict]
										[T -> completed : FieldDecl "private volatile long completed;" compose:Replacement merge: SemanticConflict]
										[T -> dropped : FieldDecl "private final AtomicLong dropped = new AtomicLong();" compose:Replacement merge: SemanticConflict]
										[T -> targetVersion : FieldDecl "private int targetVersion;" compose:Replacement merge: SemanticConflict]
										[T -> OutboundTcpConnection(OutboundTcpConnectionPool-OutboundTcpConnectionPool) : ConstructorDecl "public OutboundTcpConnection(OutboundTcpConnectionPool pool)     {         super("WRITE-" + pool.endPoint());         this.poolReference = pool;     }" compose:Replacement merge: LineBased]
										[T -> isLocalDC(InetAddress-InetAddress) : MethodDecl "private static boolean isLocalDC(InetAddress targetHost)     {         String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);         String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());         return remoteDC.equals(localDC);     }" compose:Replacement merge: LineBased]
										[T -> enqueue(MessageOut<?>-MessageOut<?>-int-int) : MethodDecl "public void enqueue(MessageOut<?> message, int id)     {         expireMessages();         try         {             backlog.put(new QueuedMessage(message, id));         }         catch (InterruptedException e)         {             throw new AssertionError(e);         }     }" compose:Replacement merge: LineBased]
										[T -> closeSocket(boolean-boolean) : MethodDecl "void closeSocket(boolean destroyThread)     {         active.clear();         backlog.clear();         isStopped = destroyThread; // Exit loop to stop the thread         enqueue(CLOSE_SENTINEL, -1);     }" compose:Replacement merge: LineBased]
										[T -> softCloseSocket({FormalParametersInternal}) : MethodDecl "void softCloseSocket()     {         enqueue(CLOSE_SENTINEL, -1);     }" compose:Replacement merge: LineBased]
										[T -> getTargetVersion({FormalParametersInternal}) : MethodDecl "public int getTargetVersion()     {         return targetVersion;     }" compose:Replacement merge: LineBased]
										[T -> run({FormalParametersInternal}) : MethodDecl "public void run()     {         while (true)         {             QueuedMessage qm = active.poll();             if (qm == null)             {                 // exhausted the active queue.  switch to backlog, once there's something to process there                 try                 {                     qm = backlog.take();                 }                 catch (InterruptedException e)                 {                     throw new AssertionError(e);                 }                  BlockingQueue<QueuedMessage> tmp = backlog;                 backlog = active;                 active = tmp;             }              MessageOut<?> m = qm.message;             if (m == CLOSE_SENTINEL)             {                 disconnect();                 if (isStopped)                     break;                 continue;             }             if (qm.timestamp < System.currentTimeMillis() - m.getTimeout())                 dropped.incrementAndGet();             else if (socket != null || connect())                 writeConnected(qm);             else                 // clear out the queue, else gossip messages back up.                 active.clear();         }     }" compose:Replacement merge: LineBased]
										[T -> getPendingMessages({FormalParametersInternal}) : MethodDecl "public int getPendingMessages()     {         return active.size() + backlog.size();     }" compose:Replacement merge: LineBased]
										[T -> getCompletedMesssages({FormalParametersInternal}) : MethodDecl "public long getCompletedMesssages()     {         return completed;     }" compose:Replacement merge: LineBased]
										[T -> getDroppedMessages({FormalParametersInternal}) : MethodDecl "public long getDroppedMessages()     {         return dropped.get();     }" compose:Replacement merge: LineBased]
										[T -> shouldCompressConnection({FormalParametersInternal}) : MethodDecl "private boolean shouldCompressConnection()     {         // assumes version >= 1.2         return DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all                || (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc && !isLocalDC(poolReference.endPoint()));     }" compose:Replacement merge: LineBased]
										[T -> writeConnected(QueuedMessage-QueuedMessage) : MethodDecl "private void writeConnected(QueuedMessage qm)     {         try         {             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);             if (sessionBytes != null)             {                 UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));                 TraceState state = Tracing.instance.get(sessionId);                 String message = String.format("Sending message to %s", poolReference.endPoint());                 // session may have already finished; see CASSANDRA-5668                 if (state == null)                 {                     TraceState.trace(ByteBuffer.wrap(sessionBytes), message, -1);                 }                 else                 {                     state.trace(message);                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)                         Tracing.instance.stopNonLocal(state);                 }             }              writeInternal(qm.message, qm.id, qm.timestamp);              completed++;             if (active.peek() == null)                 out.flush();         }         catch (Exception e)         {             disconnect();             if (e instanceof IOException)             {                 if (logger.isDebugEnabled())                     logger.debug("error writing to " + poolReference.endPoint(), e);                  // if the message was important, such as a repair acknowledgement, put it back on the queue                 // to retry after re-connecting.  See CASSANDRA-5393                 if (e instanceof SocketException && qm.shouldRetry())                 {                     try                     {                         backlog.put(new RetriedQueuedMessage(qm));                     }                     catch (InterruptedException e1)                     {                         throw new AssertionError(e1);                     }                 }             }             else             {                 // Non IO exceptions are likely a programming error so let's not silence them                 logger.error("error writing to " + poolReference.endPoint(), e);             }         }     }" compose:Replacement merge: LineBased]
										[T -> writeInternal(MessageOut-MessageOut-int-int-long-long) : MethodDecl "private void writeInternal(MessageOut message, int id, long timestamp) throws IOException     {         out.writeInt(MessagingService.PROTOCOL_MAGIC);          if (targetVersion < MessagingService.VERSION_20)             out.writeUTF(String.valueOf(id));         else             out.writeInt(id);          // int cast cuts off the high-order half of the timestamp, which we can assume remains         // the same between now and when the recipient reconstructs it.         out.writeInt((int) timestamp);         message.serialize(out, targetVersion);     }" compose:Replacement merge: LineBased]
										[T -> writeHeader(DataOutputStream-DataOutputStream-int-int-boolean-boolean) : MethodDecl "private static void writeHeader(DataOutputStream out, int version, boolean compressionEnabled) throws IOException     {         // 2 bits: unused.  used to be "serializer type," which was always Binary         // 1 bit: compression         // 1 bit: streaming mode         // 3 bits: unused         // 8 bits: version         // 15 bits: unused         int header = 0;         if (compressionEnabled)             header |= 4;         header |= (version << 8);         out.writeInt(header);     }" compose:Replacement merge: LineBased]
										[T -> disconnect({FormalParametersInternal}) : MethodDecl "private void disconnect()     {         if (socket != null)         {             try             {                 socket.close();             }             catch (IOException e)             {                 if (logger.isTraceEnabled())                     logger.trace("exception closing connection to " + poolReference.endPoint(), e);             }             out = null;             socket = null;         }     }" compose:Replacement merge: LineBased]
										[T -> connect({FormalParametersInternal}) : MethodDecl "private boolean connect()     {         if (logger.isDebugEnabled())             logger.debug("attempting to connect to " + poolReference.endPoint());          targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());          long start = System.nanoTime();         long timeout = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getRpcTimeout());         while (System.nanoTime() - start < timeout)         {             try             {                 socket = poolReference.newSocket();                 socket.setKeepAlive(true);                 if (isLocalDC(poolReference.endPoint()))                 {                     socket.setTcpNoDelay(true);                 }                 else                 {                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());                 }                 if (DatabaseDescriptor.getInternodeSendBufferSize() != null)                 {                     try                     {                         socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize());                     }                     catch (SocketException se)                     {                         logger.warn("Failed to set send buffer size on internode socket.", se);                     }                 }                 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));                  out.writeInt(MessagingService.PROTOCOL_MAGIC);                 writeHeader(out, targetVersion, shouldCompressConnection());                 out.flush();                  DataInputStream in = new DataInputStream(socket.getInputStream());                 int maxTargetVersion = in.readInt();                 if (targetVersion > maxTargetVersion)                 {                     logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);                     MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);                     disconnect();                     return false;                 }                  if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)                 {                     logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",                                  maxTargetVersion, targetVersion);                     MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));                     softCloseSocket();                 }                  out.writeInt(MessagingService.current_version);                 CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(), out);                 if (shouldCompressConnection())                 {                     out.flush();                     logger.trace("Upgrading OutputStream to be compressed");                     out = new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));                 }                  return true;             }             catch (IOException e)             {                 socket = null;                 if (logger.isTraceEnabled())                     logger.trace("unable to connect to " + poolReference.endPoint(), e);                 Uninterruptibles.sleepUninterruptibly(OPEN_RETRY_DELAY, TimeUnit.MILLISECONDS);             }         }         return false;     }" compose:Replacement merge: LineBased]
										[T -> expireMessages({FormalParametersInternal}) : MethodDecl "private void expireMessages()     {         while (true)         {             QueuedMessage qm = backlog.peek();             if (qm == null || qm.timestamp >= System.currentTimeMillis() - qm.message.getTimeout())                 break;              QueuedMessage qm2 = backlog.poll();             if (qm2 != qm)             {                 // sending thread switched queues.  add this entry (from the "new" backlog)                 // at the end of the active queue, which keeps it in the same position relative to the other entries                 // without having to contend with other clients for the head-of-backlog lock.                 if (qm2 != null)                     active.add(qm2);                 break;             }              dropped.incrementAndGet();         }     }" compose:Replacement merge: LineBased]
										[NT -> QueuedMessage : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> QueuedMessage : Id "QueuedMessage" compose:Replacement merge: Default]
											[T -> message : FieldDecl "final MessageOut<?> message;" compose:Replacement merge: SemanticConflict]
											[T -> id : FieldDecl "final int id;" compose:Replacement merge: SemanticConflict]
											[T -> timestamp : FieldDecl "final long timestamp;" compose:Replacement merge: SemanticConflict]
											[T -> QueuedMessage(MessageOut<?>-MessageOut<?>-int-int) : ConstructorDecl "QueuedMessage(MessageOut<?> message, int id)         {             this.message = message;             this.id = id;             this.timestamp = System.currentTimeMillis();         }" compose:Replacement merge: LineBased]
											[T -> shouldRetry({FormalParametersInternal}) : MethodDecl "boolean shouldRetry()         {             return !MessagingService.DROPPABLE_VERBS.contains(message.verb);         }" compose:Replacement merge: LineBased]
										[NT -> RetriedQueuedMessage : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> RetriedQueuedMessage : Id "RetriedQueuedMessage" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends QueuedMessage" compose:Replacement merge: Default]
											[T -> RetriedQueuedMessage(QueuedMessage-QueuedMessage) : ConstructorDecl "RetriedQueuedMessage(QueuedMessage msg)         {             super(msg.message, msg.id);         }" compose:Replacement merge: LineBased]
											[T -> shouldRetry({FormalParametersInternal}) : MethodDecl "boolean shouldRetry()         {             return false;         }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> java : Folder]
			[NT -> org : Folder]
				[NT -> apache : Folder]
					[NT -> cassandra : Folder]
						[NT -> net : Folder]
							[NT -> OutboundTcpConnection.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package org.apache.cassandra.net;" compose:Replacement merge: Default]
									[T -> java.io.BufferedOutputStream{ImportPackage} : ImportDeclaration "import java.io.BufferedOutputStream;" compose:Replacement merge: Default]
									[T -> java.io.DataInputStream{ImportPackage} : ImportDeclaration "import java.io.DataInputStream;" compose:Replacement merge: Default]
									[T -> java.io.DataOutputStream{ImportPackage} : ImportDeclaration "import java.io.DataOutputStream;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
									[T -> java.net.InetAddress{ImportPackage} : ImportDeclaration "import java.net.InetAddress;" compose:Replacement merge: Default]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: Default]
									[T -> java.net.SocketException{ImportPackage} : ImportDeclaration "import java.net.SocketException;" compose:Replacement merge: Default]
									[T -> java.nio.ByteBuffer{ImportPackage} : ImportDeclaration "import java.nio.ByteBuffer;" compose:Replacement merge: Default]
									[T -> java.util.UUID{ImportPackage} : ImportDeclaration "import java.util.UUID;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.BlockingQueue{ImportPackage} : ImportDeclaration "import java.util.concurrent.BlockingQueue;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.LinkedBlockingQueue{ImportPackage} : ImportDeclaration "import java.util.concurrent.LinkedBlockingQueue;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.atomic.AtomicLong{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicLong;" compose:Replacement merge: Default]
									[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
									[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.tracing.TraceState{ImportPackage} : ImportDeclaration "import org.apache.cassandra.tracing.TraceState;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.tracing.Tracing{ImportPackage} : ImportDeclaration "import org.apache.cassandra.tracing.Tracing;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.utils.FBUtilities{ImportPackage} : ImportDeclaration "import org.apache.cassandra.utils.FBUtilities;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.utils.UUIDGen{ImportPackage} : ImportDeclaration "import org.apache.cassandra.utils.UUIDGen;" compose:Replacement merge: Default]
									[T -> org.xerial.snappy.SnappyOutputStream{ImportPackage} : ImportDeclaration "import org.xerial.snappy.SnappyOutputStream;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.config.Config{ImportPackage} : ImportDeclaration "import org.apache.cassandra.config.Config;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.config.DatabaseDescriptor{ImportPackage} : ImportDeclaration "import org.apache.cassandra.config.DatabaseDescriptor;" compose:Replacement merge: Default]
									[NT -> OutboundTcpConnection : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> OutboundTcpConnection : Id "OutboundTcpConnection" compose:Replacement merge: Default]
										[T -> - : ExtendsList "extends Thread" compose:Replacement merge: Default]
										[T -> logger : FieldDecl "private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);" compose:Replacement merge: SemanticConflict]
										[T -> CLOSE_SENTINEL : FieldDecl "private static final MessageOut CLOSE_SENTINEL = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE);" compose:Replacement merge: SemanticConflict]
										[T -> isStopped : FieldDecl "private volatile boolean isStopped = false;" compose:Replacement merge: SemanticConflict]
										[T -> OPEN_RETRY_DELAY : FieldDecl "private static final int OPEN_RETRY_DELAY = 100;" compose:Replacement merge: SemanticConflict]
										[T -> backlog : FieldDecl "private volatile BlockingQueue<QueuedMessage> backlog = new LinkedBlockingQueue<QueuedMessage>();" compose:Replacement merge: SemanticConflict]
										[T -> active : FieldDecl "private volatile BlockingQueue<QueuedMessage> active = new LinkedBlockingQueue<QueuedMessage>();" compose:Replacement merge: SemanticConflict]
										[T -> poolReference : FieldDecl "private final OutboundTcpConnectionPool poolReference;" compose:Replacement merge: SemanticConflict]
										[T -> out : FieldDecl "private DataOutputStream out;" compose:Replacement merge: SemanticConflict]
										[T -> socket : FieldDecl "private Socket socket;" compose:Replacement merge: SemanticConflict]
										[T -> completed : FieldDecl "private volatile long completed;" compose:Replacement merge: SemanticConflict]
										[T -> dropped : FieldDecl "private final AtomicLong dropped = new AtomicLong();" compose:Replacement merge: SemanticConflict]
										[T -> targetVersion : FieldDecl "private int targetVersion;" compose:Replacement merge: SemanticConflict]
										[T -> OutboundTcpConnection(OutboundTcpConnectionPool-OutboundTcpConnectionPool) : ConstructorDecl "public OutboundTcpConnection(OutboundTcpConnectionPool pool)     {         super("WRITE-" + pool.endPoint());         this.poolReference = pool;     }" compose:Replacement merge: LineBased]
										[T -> isLocalDC(InetAddress-InetAddress) : MethodDecl "private static boolean isLocalDC(InetAddress targetHost)     {         String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);         String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());         return remoteDC.equals(localDC);     }" compose:Replacement merge: LineBased]
										[T -> enqueue(MessageOut<?>-MessageOut<?>-String-String) : MethodDecl "public void enqueue(MessageOut<?> message, String id)     {         expireMessages();         try         {             backlog.put(new QueuedMessage(message, id));         }         catch (InterruptedException e)         {             throw new AssertionError(e);         }     }" compose:Replacement merge: LineBased]
										[T -> closeSocket(boolean-boolean) : MethodDecl "void closeSocket(boolean destroyThread)     {         active.clear();         backlog.clear();         isStopped = destroyThread; // Exit loop to stop the thread         enqueue(CLOSE_SENTINEL, null);     }" compose:Replacement merge: LineBased]
										[T -> softCloseSocket({FormalParametersInternal}) : MethodDecl "void softCloseSocket()     {         enqueue(CLOSE_SENTINEL, null);     }" compose:Replacement merge: LineBased]
										[T -> getTargetVersion({FormalParametersInternal}) : MethodDecl "public int getTargetVersion()     {         return targetVersion;     }" compose:Replacement merge: LineBased]
										[T -> run({FormalParametersInternal}) : MethodDecl "public void run()     {         while (true)         {             QueuedMessage qm = active.poll();             if (qm == null)             {                 // exhausted the active queue.  switch to backlog, once there's something to process there                 try                 {                     qm = backlog.take();                 }                 catch (InterruptedException e)                 {                     throw new AssertionError(e);                 }                  BlockingQueue<QueuedMessage> tmp = backlog;                 backlog = active;                 active = tmp;             }              MessageOut<?> m = qm.message;             if (m == CLOSE_SENTINEL)             {                 disconnect();                 if (isStopped)                     break;                 continue;             }             if (qm.timestamp < System.currentTimeMillis() - m.getTimeout())                 dropped.incrementAndGet();             else if (socket != null || connect())                 writeConnected(qm);             else                 // clear out the queue, else gossip messages back up.                 active.clear();         }     }" compose:Replacement merge: LineBased]
										[T -> getPendingMessages({FormalParametersInternal}) : MethodDecl "public int getPendingMessages()     {         return active.size() + backlog.size();     }" compose:Replacement merge: LineBased]
										[T -> getCompletedMesssages({FormalParametersInternal}) : MethodDecl "public long getCompletedMesssages()     {         return completed;     }" compose:Replacement merge: LineBased]
										[T -> getDroppedMessages({FormalParametersInternal}) : MethodDecl "public long getDroppedMessages()     {         return dropped.get();     }" compose:Replacement merge: LineBased]
										[T -> shouldCompressConnection({FormalParametersInternal}) : MethodDecl "private boolean shouldCompressConnection()     {         // assumes version >= 1.2         return DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all                || (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc && !isLocalDC(poolReference.endPoint()));     }" compose:Replacement merge: LineBased]
										[T -> writeConnected(QueuedMessage-QueuedMessage) : MethodDecl "private void writeConnected(QueuedMessage qm)     {         try         {             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);             if (sessionBytes != null)             {                 UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));                 TraceState state = Tracing.instance().get(sessionId);                 String message = String.format("Sending message to %s", poolReference.endPoint());                 // session may have already finished; see CASSANDRA-5668                 if (state == null)                 {                     TraceState.trace(ByteBuffer.wrap(sessionBytes), message, -1);                 }                 else                 {                     state.trace(message);                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)                         Tracing.instance().stopNonLocal(state);                 }             }              write(qm.message, qm.id, qm.timestamp, out, targetVersion);             completed++;             if (active.peek() == null)             {                 out.flush();             }         }         catch (Exception e)         {             disconnect();             if (e instanceof IOException)             {                 if (logger.isDebugEnabled())                     logger.debug("error writing to " + poolReference.endPoint(), e);                  // if the message was important, such as a repair acknowledgement, put it back on the queue                 // to retry after re-connecting.  See CASSANDRA-5393                 if (e instanceof SocketException && qm.shouldRetry())                 {                     try                     {                         backlog.put(new RetriedQueuedMessage(qm));                     }                     catch (InterruptedException e1)                     {                         throw new AssertionError(e1);                     }                 }             }             else             {                 // Non IO exceptions are likely a programming error so let's not silence them                 logger.error("error writing to " + poolReference.endPoint(), e);             }         }     }" compose:Replacement merge: LineBased]
										[T -> write(MessageOut-MessageOut-String-String-long-long-DataOutputStream-DataOutputStream-int-int) : MethodDecl "public static void write(MessageOut message, String id, long timestamp, DataOutputStream out, int version) throws IOException     {         out.writeInt(MessagingService.PROTOCOL_MAGIC);         if (version < MessagingService.VERSION_12)         {             writeHeader(out, version, false);             // 0.8 included a total message size int.  1.0 doesn't need it but expects it to be there.             out.writeInt(-1);         }          out.writeUTF(id);         if (version >= MessagingService.VERSION_12)         {             // int cast cuts off the high-order half of the timestamp, which we can assume remains             // the same between now and when the recipient reconstructs it.             out.writeInt((int) timestamp);         }         message.serialize(out, version);     }" compose:Replacement merge: LineBased]
										[T -> writeHeader(DataOutputStream-DataOutputStream-int-int-boolean-boolean) : MethodDecl "private static void writeHeader(DataOutputStream out, int version, boolean compressionEnabled) throws IOException     {         // 2 bits: unused.  used to be "serializer type," which was always Binary         // 1 bit: compression         // 1 bit: streaming mode         // 3 bits: unused         // 8 bits: version         // 15 bits: unused         int header = 0;         if (compressionEnabled)             header |= 4;         header |= (version << 8);         out.writeInt(header);     }" compose:Replacement merge: LineBased]
										[T -> disconnect({FormalParametersInternal}) : MethodDecl "private void disconnect()     {         if (socket != null)         {             try             {                 socket.close();             }             catch (IOException e)             {                 if (logger.isTraceEnabled())                     logger.trace("exception closing connection to " + poolReference.endPoint(), e);             }             out = null;             socket = null;         }     }" compose:Replacement merge: LineBased]
										[T -> connect({FormalParametersInternal}) : MethodDecl "private boolean connect()     {         if (logger.isDebugEnabled())             logger.debug("attempting to connect to " + poolReference.endPoint());          targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());          long start = System.currentTimeMillis();         while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())         {             try             {                 socket = poolReference.newSocket();                 socket.setKeepAlive(true);                 if (isLocalDC(poolReference.endPoint()))                 {                     socket.setTcpNoDelay(true);                 }                 else                 {                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());                 }                 if (DatabaseDescriptor.getInternodeSendBufferSize() != null)                 {                     try                     {                         socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize().intValue());                     }                     catch (SocketException se)                     {                         logger.warn("Failed to set send buffer size on internode socket.", se);                     }                 }                 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));                  if (targetVersion >= MessagingService.VERSION_12)                 {                     out.writeInt(MessagingService.PROTOCOL_MAGIC);                     writeHeader(out, targetVersion, shouldCompressConnection());                     out.flush();                      DataInputStream in = new DataInputStream(socket.getInputStream());                     int maxTargetVersion = in.readInt();                     if (targetVersion > maxTargetVersion)                     {                         logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);                         disconnect();                         return false;                     }                      if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)                     {                         logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",                                      maxTargetVersion, targetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));                         softCloseSocket();                     }                      out.writeInt(MessagingService.current_version);                     CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(), out);                     if (shouldCompressConnection())                     {                         out.flush();                         logger.trace("Upgrading OutputStream to be compressed");                         out = new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));                     }                 }                  return true;             }             catch (IOException e)             {                 socket = null;                 if (logger.isTraceEnabled())                     logger.trace("unable to connect to " + poolReference.endPoint(), e);                 try                 {                     Thread.sleep(OPEN_RETRY_DELAY);                 }                 catch (InterruptedException e1)                 {                     throw new AssertionError(e1);                 }             }         }         return false;     }" compose:Replacement merge: LineBased]
										[T -> expireMessages({FormalParametersInternal}) : MethodDecl "private void expireMessages()     {         while (true)         {             QueuedMessage qm = backlog.peek();             if (qm == null || qm.timestamp >= System.currentTimeMillis() - qm.message.getTimeout())                 break;              QueuedMessage qm2 = backlog.poll();             if (qm2 != qm)             {                 // sending thread switched queues.  add this entry (from the "new" backlog)                 // at the end of the active queue, which keeps it in the same position relative to the other entries                 // without having to contend with other clients for the head-of-backlog lock.                 if (qm2 != null)                     active.add(qm2);                 break;             }              dropped.incrementAndGet();         }     }" compose:Replacement merge: LineBased]
										[NT -> QueuedMessage : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> QueuedMessage : Id "QueuedMessage" compose:Replacement merge: Default]
											[T -> message : FieldDecl "final MessageOut<?> message;" compose:Replacement merge: SemanticConflict]
											[T -> id : FieldDecl "final String id;" compose:Replacement merge: SemanticConflict]
											[T -> timestamp : FieldDecl "final long timestamp;" compose:Replacement merge: SemanticConflict]
											[T -> QueuedMessage(MessageOut<?>-MessageOut<?>-String-String) : ConstructorDecl "QueuedMessage(MessageOut<?> message, String id)         {             this.message = message;             this.id = id;             this.timestamp = System.currentTimeMillis();         }" compose:Replacement merge: LineBased]
											[T -> shouldRetry({FormalParametersInternal}) : MethodDecl "boolean shouldRetry()         {             return !MessagingService.DROPPABLE_VERBS.contains(message.verb);         }" compose:Replacement merge: LineBased]
										[NT -> RetriedQueuedMessage : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> RetriedQueuedMessage : Id "RetriedQueuedMessage" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends QueuedMessage" compose:Replacement merge: Default]
											[T -> RetriedQueuedMessage(QueuedMessage-QueuedMessage) : ConstructorDecl "RetriedQueuedMessage(QueuedMessage msg)         {             super(msg.message, msg.id);         }" compose:Replacement merge: LineBased]
											[T -> shouldRetry({FormalParametersInternal}) : MethodDecl "boolean shouldRetry()         {             return false;         }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> java : Folder]
			[NT -> org : Folder]
				[NT -> apache : Folder]
					[NT -> cassandra : Folder]
						[NT -> net : Folder]
							[NT -> OutboundTcpConnection.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package org.apache.cassandra.net;" compose:Replacement merge: Default]
									[T -> java.io.BufferedOutputStream{ImportPackage} : ImportDeclaration "import java.io.BufferedOutputStream;" compose:Replacement merge: Default]
									[T -> java.io.DataInputStream{ImportPackage} : ImportDeclaration "import java.io.DataInputStream;" compose:Replacement merge: Default]
									[T -> java.io.DataOutputStream{ImportPackage} : ImportDeclaration "import java.io.DataOutputStream;" compose:Replacement merge: Default]
									[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
									[T -> java.net.InetAddress{ImportPackage} : ImportDeclaration "import java.net.InetAddress;" compose:Replacement merge: Default]
									[T -> java.net.Socket{ImportPackage} : ImportDeclaration "import java.net.Socket;" compose:Replacement merge: Default]
									[T -> java.net.SocketException{ImportPackage} : ImportDeclaration "import java.net.SocketException;" compose:Replacement merge: Default]
									[T -> java.nio.ByteBuffer{ImportPackage} : ImportDeclaration "import java.nio.ByteBuffer;" compose:Replacement merge: Default]
									[T -> java.util.UUID{ImportPackage} : ImportDeclaration "import java.util.UUID;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.BlockingQueue{ImportPackage} : ImportDeclaration "import java.util.concurrent.BlockingQueue;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.CountDownLatch{ImportPackage} : ImportDeclaration "import java.util.concurrent.CountDownLatch;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.LinkedBlockingQueue{ImportPackage} : ImportDeclaration "import java.util.concurrent.LinkedBlockingQueue;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.TimeUnit{ImportPackage} : ImportDeclaration "import java.util.concurrent.TimeUnit;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.atomic.AtomicInteger{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicInteger;" compose:Replacement merge: Default]
									[T -> java.util.concurrent.atomic.AtomicLong{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicLong;" compose:Replacement merge: Default]
									[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
									[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.tracing.TraceState{ImportPackage} : ImportDeclaration "import org.apache.cassandra.tracing.TraceState;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.tracing.Tracing{ImportPackage} : ImportDeclaration "import org.apache.cassandra.tracing.Tracing;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.utils.FBUtilities{ImportPackage} : ImportDeclaration "import org.apache.cassandra.utils.FBUtilities;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.utils.UUIDGen{ImportPackage} : ImportDeclaration "import org.apache.cassandra.utils.UUIDGen;" compose:Replacement merge: Default]
									[T -> org.xerial.snappy.SnappyOutputStream{ImportPackage} : ImportDeclaration "import org.xerial.snappy.SnappyOutputStream;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.config.Config{ImportPackage} : ImportDeclaration "import org.apache.cassandra.config.Config;" compose:Replacement merge: Default]
									[T -> org.apache.cassandra.config.DatabaseDescriptor{ImportPackage} : ImportDeclaration "import org.apache.cassandra.config.DatabaseDescriptor;" compose:Replacement merge: Default]
									[NT -> OutboundTcpConnection : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> OutboundTcpConnection : Id "OutboundTcpConnection" compose:Replacement merge: Default]
										[T -> - : ExtendsList "extends Thread" compose:Replacement merge: Default]
										[T -> logger : FieldDecl "private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);" compose:Replacement merge: SemanticConflict]
										[T -> CLOSE_SENTINEL : FieldDecl "private static final MessageOut CLOSE_SENTINEL = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE);" compose:Replacement merge: SemanticConflict]
										[T -> isStopped : FieldDecl "private volatile boolean isStopped = false;" compose:Replacement merge: SemanticConflict]
										[T -> OPEN_RETRY_DELAY : FieldDecl "private static final int OPEN_RETRY_DELAY = 100;" compose:Replacement merge: SemanticConflict]
										[T -> WAIT_FOR_VERSION_MAX_TIME : FieldDecl "private static final int WAIT_FOR_VERSION_MAX_TIME = 5000;" compose:Replacement merge: SemanticConflict]
										[T -> NO_VERSION : FieldDecl "private static final int NO_VERSION = Integer.MIN_VALUE;" compose:Replacement merge: SemanticConflict]
										[T -> backlog : FieldDecl "private volatile BlockingQueue<QueuedMessage> backlog = new LinkedBlockingQueue<QueuedMessage>();" compose:Replacement merge: SemanticConflict]
										[T -> active : FieldDecl "private volatile BlockingQueue<QueuedMessage> active = new LinkedBlockingQueue<QueuedMessage>();" compose:Replacement merge: SemanticConflict]
										[T -> poolReference : FieldDecl "private final OutboundTcpConnectionPool poolReference;" compose:Replacement merge: SemanticConflict]
										[T -> out : FieldDecl "private DataOutputStream out;" compose:Replacement merge: SemanticConflict]
										[T -> socket : FieldDecl "private Socket socket;" compose:Replacement merge: SemanticConflict]
										[T -> completed : FieldDecl "private volatile long completed;" compose:Replacement merge: SemanticConflict]
										[T -> dropped : FieldDecl "private final AtomicLong dropped = new AtomicLong();" compose:Replacement merge: SemanticConflict]
										[T -> targetVersion : FieldDecl "private int targetVersion;" compose:Replacement merge: SemanticConflict]
										[T -> OutboundTcpConnection(OutboundTcpConnectionPool-OutboundTcpConnectionPool) : ConstructorDecl "public OutboundTcpConnection(OutboundTcpConnectionPool pool)     {         super("WRITE-" + pool.endPoint());         this.poolReference = pool;     }" compose:Replacement merge: LineBased]
										[T -> isLocalDC(InetAddress-InetAddress) : MethodDecl "private static boolean isLocalDC(InetAddress targetHost)     {         String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);         String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());         return remoteDC.equals(localDC);     }" compose:Replacement merge: LineBased]
										[T -> enqueue(MessageOut<?>-MessageOut<?>-String-String) : MethodDecl "public void enqueue(MessageOut<?> message, String id)     {         expireMessages();         try         {             backlog.put(new QueuedMessage(message, id));         }         catch (InterruptedException e)         {             throw new AssertionError(e);         }     }" compose:Replacement merge: LineBased]
										[T -> closeSocket(boolean-boolean) : MethodDecl "void closeSocket(boolean destroyThread)     {         active.clear();         backlog.clear();         isStopped = destroyThread; // Exit loop to stop the thread         enqueue(CLOSE_SENTINEL, null);     }" compose:Replacement merge: LineBased]
										[T -> softCloseSocket({FormalParametersInternal}) : MethodDecl "void softCloseSocket()     {         enqueue(CLOSE_SENTINEL, null);     }" compose:Replacement merge: LineBased]
										[T -> getTargetVersion({FormalParametersInternal}) : MethodDecl "public int getTargetVersion()     {         return targetVersion;     }" compose:Replacement merge: LineBased]
										[T -> run({FormalParametersInternal}) : MethodDecl "public void run()     {         while (true)         {             QueuedMessage qm = active.poll();             if (qm == null)             {                 // exhausted the active queue.  switch to backlog, once there's something to process there                 try                 {                     qm = backlog.take();                 }                 catch (InterruptedException e)                 {                     throw new AssertionError(e);                 }                  BlockingQueue<QueuedMessage> tmp = backlog;                 backlog = active;                 active = tmp;             }              MessageOut<?> m = qm.message;             if (m == CLOSE_SENTINEL)             {                 disconnect();                 if (isStopped)                     break;                 continue;             }             if (qm.timestamp < System.currentTimeMillis() - m.getTimeout())                 dropped.incrementAndGet();             else if (socket != null || connect())                 writeConnected(qm);             else                 // clear out the queue, else gossip messages back up.                 active.clear();         }     }" compose:Replacement merge: LineBased]
										[T -> getPendingMessages({FormalParametersInternal}) : MethodDecl "public int getPendingMessages()     {         return active.size() + backlog.size();     }" compose:Replacement merge: LineBased]
										[T -> getCompletedMesssages({FormalParametersInternal}) : MethodDecl "public long getCompletedMesssages()     {         return completed;     }" compose:Replacement merge: LineBased]
										[T -> getDroppedMessages({FormalParametersInternal}) : MethodDecl "public long getDroppedMessages()     {         return dropped.get();     }" compose:Replacement merge: LineBased]
										[T -> shouldCompressConnection({FormalParametersInternal}) : MethodDecl "private boolean shouldCompressConnection()     {         // assumes version >= 1.2         return DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all                || (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc && !isLocalDC(poolReference.endPoint()));     }" compose:Replacement merge: LineBased]
										[T -> writeConnected(QueuedMessage-QueuedMessage) : MethodDecl "private void writeConnected(QueuedMessage qm)     {         try         {             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);             if (sessionBytes != null)             {                 UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));                 TraceState state = Tracing.instance().get(sessionId);                 String message = String.format("Sending message to %s", poolReference.endPoint());                 // session may have already finished; see CASSANDRA-5668                 if (state == null)                 {                     TraceState.trace(ByteBuffer.wrap(sessionBytes), message, -1);                 }                 else                 {                     state.trace(message);                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)                         Tracing.instance().stopNonLocal(state);                 }             }              write(qm.message, qm.id, qm.timestamp, out, targetVersion);             completed++;             if (active.peek() == null)             {                 out.flush();             }         }         catch (Exception e)         {             disconnect();             if (e instanceof IOException)             {                 if (logger.isDebugEnabled())                     logger.debug("error writing to " + poolReference.endPoint(), e);                  // if the message was important, such as a repair acknowledgement, put it back on the queue                 // to retry after re-connecting.  See CASSANDRA-5393                 if (e instanceof SocketException && qm.shouldRetry())                 {                     try                     {                         backlog.put(new RetriedQueuedMessage(qm));                     }                     catch (InterruptedException e1)                     {                         throw new AssertionError(e1);                     }                 }             }             else             {                 // Non IO exceptions are likely a programming error so let's not silence them                 logger.error("error writing to " + poolReference.endPoint(), e);             }         }     }" compose:Replacement merge: LineBased]
										[T -> write(MessageOut-MessageOut-String-String-long-long-DataOutputStream-DataOutputStream-int-int) : MethodDecl "public static void write(MessageOut message, String id, long timestamp, DataOutputStream out, int version) throws IOException     {         out.writeInt(MessagingService.PROTOCOL_MAGIC);         if (version < MessagingService.VERSION_12)         {             writeHeader(out, version, false);             // 0.8 included a total message size int.  1.0 doesn't need it but expects it to be there.             out.writeInt(-1);         }          out.writeUTF(id);         if (version >= MessagingService.VERSION_12)         {             // int cast cuts off the high-order half of the timestamp, which we can assume remains             // the same between now and when the recipient reconstructs it.             out.writeInt((int) timestamp);         }         message.serialize(out, version);     }" compose:Replacement merge: LineBased]
										[T -> writeHeader(DataOutputStream-DataOutputStream-int-int-boolean-boolean) : MethodDecl "private static void writeHeader(DataOutputStream out, int version, boolean compressionEnabled) throws IOException     {         // 2 bits: unused.  used to be "serializer type," which was always Binary         // 1 bit: compression         // 1 bit: streaming mode         // 3 bits: unused         // 8 bits: version         // 15 bits: unused         int header = 0;         if (compressionEnabled)             header |= 4;         header |= (version << 8);         out.writeInt(header);     }" compose:Replacement merge: LineBased]
										[T -> disconnect({FormalParametersInternal}) : MethodDecl "private void disconnect()     {         if (socket != null)         {             try             {                 socket.close();             }             catch (IOException e)             {                 if (logger.isTraceEnabled())                     logger.trace("exception closing connection to " + poolReference.endPoint(), e);             }             out = null;             socket = null;         }     }" compose:Replacement merge: LineBased]
										[T -> connect({FormalParametersInternal}) : MethodDecl "private boolean connect()     {         if (logger.isDebugEnabled())             logger.debug("attempting to connect to " + poolReference.endPoint());          long start = System.currentTimeMillis();         while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())         {             targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());             try             {                 socket = poolReference.newSocket();                 socket.setKeepAlive(true);                 if (isLocalDC(poolReference.endPoint()))                 {                     socket.setTcpNoDelay(true);                 }                 else                 {                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());                 }                 if (DatabaseDescriptor.getInternodeSendBufferSize() != null)                 {                     try                     {                         socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize().intValue());                     }                     catch (SocketException se)                     {                         logger.warn("Failed to set send buffer size on internode socket.", se);                     }                 }                 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));                  if (targetVersion >= MessagingService.VERSION_12)                 {                     out.writeInt(MessagingService.PROTOCOL_MAGIC);                     writeHeader(out, targetVersion, shouldCompressConnection());                     out.flush();                      DataInputStream in = new DataInputStream(socket.getInputStream());                     int maxTargetVersion = handshakeVersion(in);                     if (maxTargetVersion == NO_VERSION)                      {                         // no version is returned, so disconnect an try again: we will either get                         // a different target version (targetVersion < MessagingService.VERSION_12)                         // or if the same version the handshake will finally succeed                         logger.debug("Target max version is {}; no version information yet, will retry", maxTargetVersion);                         disconnect();                         continue;                     }                     if (targetVersion > maxTargetVersion)                     {                         logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);                         disconnect();                         return false;                     }                      if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)                     {                         logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",                                      maxTargetVersion, targetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));                         softCloseSocket();                     }                      out.writeInt(MessagingService.current_version);                     CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(), out);                     if (shouldCompressConnection())                     {                         out.flush();                         logger.trace("Upgrading OutputStream to be compressed");                         out = new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));                     }                 }                  return true;             }             catch (IOException e)             {                 socket = null;                 if (logger.isTraceEnabled())                     logger.trace("unable to connect to " + poolReference.endPoint(), e);                 try                 {                     Thread.sleep(OPEN_RETRY_DELAY);                 }                 catch (InterruptedException e1)                 {                     throw new AssertionError(e1);                 }             }         }         return false;     }" compose:Replacement merge: LineBased]
										[T -> handshakeVersion(DataInputStream-DataInputStream) : MethodDecl "private int handshakeVersion(final DataInputStream inputStream)     {         final AtomicInteger version = new AtomicInteger(NO_VERSION);         final CountDownLatch versionLatch = new CountDownLatch(1);         new Thread("HANDSHAKE-" + poolReference.endPoint())         {             @Override             public void run()             {                 try                 {                     logger.info("Handshaking version with {}", poolReference.endPoint());                     version.set(inputStream.readInt());                 }                 catch (IOException ex)                  {                     final String msg = "Cannot handshake version with " + poolReference.endPoint();                     if (logger.isTraceEnabled())                         logger.trace(msg, ex);                     else                         logger.info(msg);                 }                 finally                 {                     //unblock the waiting thread on either success or fail                     versionLatch.countDown();                 }             }         }.start();          try         {             versionLatch.await(WAIT_FOR_VERSION_MAX_TIME, TimeUnit.MILLISECONDS);         }         catch (InterruptedException ex)         {             throw new AssertionError(ex);         }         return version.get();     }" compose:Replacement merge: LineBased]
										[T -> expireMessages({FormalParametersInternal}) : MethodDecl "private void expireMessages()     {         while (true)         {             QueuedMessage qm = backlog.peek();             if (qm == null || qm.timestamp >= System.currentTimeMillis() - qm.message.getTimeout())                 break;              QueuedMessage qm2 = backlog.poll();             if (qm2 != qm)             {                 // sending thread switched queues.  add this entry (from the "new" backlog)                 // at the end of the active queue, which keeps it in the same position relative to the other entries                 // without having to contend with other clients for the head-of-backlog lock.                 if (qm2 != null)                     active.add(qm2);                 break;             }              dropped.incrementAndGet();         }     }" compose:Replacement merge: LineBased]
										[NT -> QueuedMessage : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> QueuedMessage : Id "QueuedMessage" compose:Replacement merge: Default]
											[T -> message : FieldDecl "final MessageOut<?> message;" compose:Replacement merge: SemanticConflict]
											[T -> id : FieldDecl "final String id;" compose:Replacement merge: SemanticConflict]
											[T -> timestamp : FieldDecl "final long timestamp;" compose:Replacement merge: SemanticConflict]
											[T -> QueuedMessage(MessageOut<?>-MessageOut<?>-String-String) : ConstructorDecl "QueuedMessage(MessageOut<?> message, String id)         {             this.message = message;             this.id = id;             this.timestamp = System.currentTimeMillis();         }" compose:Replacement merge: LineBased]
											[T -> shouldRetry({FormalParametersInternal}) : MethodDecl "boolean shouldRetry()         {             return !MessagingService.DROPPABLE_VERBS.contains(message.verb);         }" compose:Replacement merge: LineBased]
										[NT -> RetriedQueuedMessage : InnerClassDecl]
											[T -> - : Modifiers "private static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> RetriedQueuedMessage : Id "RetriedQueuedMessage" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends QueuedMessage" compose:Replacement merge: Default]
											[T -> RetriedQueuedMessage(QueuedMessage-QueuedMessage) : ConstructorDecl "RetriedQueuedMessage(QueuedMessage msg)         {             super(msg.message, msg.id);         }" compose:Replacement merge: LineBased]
											[T -> shouldRetry({FormalParametersInternal}) : MethodDecl "boolean shouldRetry()         {             return false;         }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> java : Folder]
			[NT -> org : Folder]
				[NT -> apache : Folder]
					[NT -> cassandra : Folder]
						[NT -> net : Folder]
							[NT -> OutboundTcpConnection.java.merge : .java.merge-File]
								[T -> OutboundTcpConnection.java : .java-Content "/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.cassandra.net;  import java.io.BufferedOutputStream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.InetAddress; import java.net.Socket; import java.net.SocketException; import java.nio.ByteBuffer; import java.util.UUID; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicLong;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import org.apache.cassandra.tracing.TraceState; import org.apache.cassandra.tracing.Tracing; import org.apache.cassandra.utils.FBUtilities; import org.apache.cassandra.utils.UUIDGen; import org.xerial.snappy.SnappyOutputStream;  import org.apache.cassandra.config.Config; import org.apache.cassandra.config.DatabaseDescriptor;  import com.google.common.util.concurrent.Uninterruptibles;  public class OutboundTcpConnection extends Thread {     private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);      private static final MessageOut CLOSE_SENTINEL = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE);     private volatile boolean isStopped = false;      private static final int OPEN_RETRY_DELAY = 100; // ms between retries      // sending thread reads from "active" (one of queue1, queue2) until it is empty.     // then it swaps it with "backlog."     private volatile BlockingQueue<QueuedMessage> backlog = new LinkedBlockingQueue<QueuedMessage>();     private volatile BlockingQueue<QueuedMessage> active = new LinkedBlockingQueue<QueuedMessage>();      private final OutboundTcpConnectionPool poolReference;      private DataOutputStream out;     private Socket socket;     private volatile long completed;     private final AtomicLong dropped = new AtomicLong();     private int targetVersion;      public OutboundTcpConnection(OutboundTcpConnectionPool pool)     {         super("WRITE-" + pool.endPoint());         this.poolReference = pool;     }      private static boolean isLocalDC(InetAddress targetHost)     {         String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);         String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());         return remoteDC.equals(localDC);     }      public void enqueue(MessageOut<?> message, int id)     {         expireMessages();         try         {             backlog.put(new QueuedMessage(message, id));         }         catch (InterruptedException e)         {             throw new AssertionError(e);         }     }      void closeSocket(boolean destroyThread)     {         active.clear();         backlog.clear();         isStopped = destroyThread; // Exit loop to stop the thread         enqueue(CLOSE_SENTINEL, -1);     }      void softCloseSocket()     {         enqueue(CLOSE_SENTINEL, -1);     }      public int getTargetVersion()     {         return targetVersion;     }      public void run()     {         while (true)         {             QueuedMessage qm = active.poll();             if (qm == null)             {                 // exhausted the active queue.  switch to backlog, once there's something to process there                 try                 {                     qm = backlog.take();                 }                 catch (InterruptedException e)                 {                     throw new AssertionError(e);                 }                  BlockingQueue<QueuedMessage> tmp = backlog;                 backlog = active;                 active = tmp;             }              MessageOut<?> m = qm.message;             if (m == CLOSE_SENTINEL)             {                 disconnect();                 if (isStopped)                     break;                 continue;             }             if (qm.timestamp < System.currentTimeMillis() - m.getTimeout())                 dropped.incrementAndGet();             else if (socket != null || connect())                 writeConnected(qm);             else                 // clear out the queue, else gossip messages back up.                 active.clear();         }     }      public int getPendingMessages()     {         return active.size() + backlog.size();     }      public long getCompletedMesssages()     {         return completed;     }      public long getDroppedMessages()     {         return dropped.get();     }      private boolean shouldCompressConnection()     {         // assumes version >= 1.2         return DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all                || (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc && !isLocalDC(poolReference.endPoint()));     }      private void writeConnected(QueuedMessage qm)     {         try         {             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);             if (sessionBytes != null)             {                 UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));                 TraceState state = Tracing.instance.get(sessionId);                 String message = String.format("Sending message to %s", poolReference.endPoint());                 // session may have already finished; see CASSANDRA-5668                 if (state == null)                 {                     TraceState.trace(ByteBuffer.wrap(sessionBytes), message, -1);                 }                 else                 {                     state.trace(message);                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)                         Tracing.instance.stopNonLocal(state);                 }             }              writeInternal(qm.message, qm.id, qm.timestamp);              completed++;             if (active.peek() == null)                 out.flush();         }         catch (Exception e)         {             disconnect();             if (e instanceof IOException)             {                 if (logger.isDebugEnabled())                     logger.debug("error writing to " + poolReference.endPoint(), e);                  // if the message was important, such as a repair acknowledgement, put it back on the queue                 // to retry after re-connecting.  See CASSANDRA-5393                 if (e instanceof SocketException && qm.shouldRetry())                 {                     try                     {                         backlog.put(new RetriedQueuedMessage(qm));                     }                     catch (InterruptedException e1)                     {                         throw new AssertionError(e1);                     }                 }             }             else             {                 // Non IO exceptions are likely a programming error so let's not silence them                 logger.error("error writing to " + poolReference.endPoint(), e);             }         }     }      private void writeInternal(MessageOut message, int id, long timestamp) throws IOException     {         out.writeInt(MessagingService.PROTOCOL_MAGIC);          if (targetVersion < MessagingService.VERSION_20)             out.writeUTF(String.valueOf(id));         else             out.writeInt(id);          // int cast cuts off the high-order half of the timestamp, which we can assume remains         // the same between now and when the recipient reconstructs it.         out.writeInt((int) timestamp);         message.serialize(out, targetVersion);     }      private static void writeHeader(DataOutputStream out, int version, boolean compressionEnabled) throws IOException     {         // 2 bits: unused.  used to be "serializer type," which was always Binary         // 1 bit: compression         // 1 bit: streaming mode         // 3 bits: unused         // 8 bits: version         // 15 bits: unused         int header = 0;         if (compressionEnabled)             header |= 4;         header |= (version << 8);         out.writeInt(header);     }      private void disconnect()     {         if (socket != null)         {             try             {                 socket.close();             }             catch (IOException e)             {                 if (logger.isTraceEnabled())                     logger.trace("exception closing connection to " + poolReference.endPoint(), e);             }             out = null;             socket = null;         }     }      private boolean connect()     {         if (logger.isDebugEnabled())             logger.debug("attempting to connect to " + poolReference.endPoint());          targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());          long start = System.nanoTime();         long timeout = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getRpcTimeout());         while (System.nanoTime() - start < timeout)         {             try             {                 socket = poolReference.newSocket();                 socket.setKeepAlive(true);                 if (isLocalDC(poolReference.endPoint()))                 {                     socket.setTcpNoDelay(true);                 }                 else                 {                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());                 }                 if (DatabaseDescriptor.getInternodeSendBufferSize() != null)                 {                     try                     {                         socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize());                     }                     catch (SocketException se)                     {                         logger.warn("Failed to set send buffer size on internode socket.", se);                     }                 }                 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));                  out.writeInt(MessagingService.PROTOCOL_MAGIC);                 writeHeader(out, targetVersion, shouldCompressConnection());                 out.flush();                  DataInputStream in = new DataInputStream(socket.getInputStream());                 int maxTargetVersion = in.readInt();                 if (targetVersion > maxTargetVersion)                 {                     logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);                     MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);                     disconnect();                     return false;                 }                  if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)                 {                     logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",                                  maxTargetVersion, targetVersion);                     MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));                     softCloseSocket();                 }                  out.writeInt(MessagingService.current_version);                 CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(), out);                 if (shouldCompressConnection())                 {                     out.flush();                     logger.trace("Upgrading OutputStream to be compressed");                     out = new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));                 }                  return true;             }             catch (IOException e)             {                 socket = null;                 if (logger.isTraceEnabled())                     logger.trace("unable to connect to " + poolReference.endPoint(), e);                 Uninterruptibles.sleepUninterruptibly(OPEN_RETRY_DELAY, TimeUnit.MILLISECONDS);             }         }         return false;     }      private void expireMessages()     {         while (true)         {             QueuedMessage qm = backlog.peek();             if (qm == null || qm.timestamp >= System.currentTimeMillis() - qm.message.getTimeout())                 break;              QueuedMessage qm2 = backlog.poll();             if (qm2 != qm)             {                 // sending thread switched queues.  add this entry (from the "new" backlog)                 // at the end of the active queue, which keeps it in the same position relative to the other entries                 // without having to contend with other clients for the head-of-backlog lock.                 if (qm2 != null)                     active.add(qm2);                 break;             }              dropped.incrementAndGet();         }     }      /** messages that have not been retried yet */     private static class QueuedMessage     {         final MessageOut<?> message;         final int id;         final long timestamp;          QueuedMessage(MessageOut<?> message, int id)         {             this.message = message;             this.id = id;             this.timestamp = System.currentTimeMillis();         }          boolean shouldRetry()         {             return !MessagingService.DROPPABLE_VERBS.contains(message.verb);         }     }      private static class RetriedQueuedMessage extends QueuedMessage     {         RetriedQueuedMessage(QueuedMessage msg)         {             super(msg.message, msg.id);         }          boolean shouldRetry()         {             return false;         }     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> java : Folder]
			[NT -> org : Folder]
				[NT -> apache : Folder]
					[NT -> cassandra : Folder]
						[NT -> net : Folder]
							[NT -> OutboundTcpConnection.java.merge : .java.merge-File]
								[T -> OutboundTcpConnection.java : .java-Content "/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.cassandra.net;  import java.io.BufferedOutputStream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.InetAddress; import java.net.Socket; import java.net.SocketException; import java.nio.ByteBuffer; import java.util.UUID; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.atomic.AtomicLong;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import org.apache.cassandra.tracing.TraceState; import org.apache.cassandra.tracing.Tracing; import org.apache.cassandra.utils.FBUtilities; import org.apache.cassandra.utils.UUIDGen; import org.xerial.snappy.SnappyOutputStream;  import org.apache.cassandra.config.Config; import org.apache.cassandra.config.DatabaseDescriptor;  public class OutboundTcpConnection extends Thread {     private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);      private static final MessageOut CLOSE_SENTINEL = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE);     private volatile boolean isStopped = false;      private static final int OPEN_RETRY_DELAY = 100; // ms between retries      // sending thread reads from "active" (one of queue1, queue2) until it is empty.     // then it swaps it with "backlog."     private volatile BlockingQueue<QueuedMessage> backlog = new LinkedBlockingQueue<QueuedMessage>();     private volatile BlockingQueue<QueuedMessage> active = new LinkedBlockingQueue<QueuedMessage>();      private final OutboundTcpConnectionPool poolReference;      private DataOutputStream out;     private Socket socket;     private volatile long completed;     private final AtomicLong dropped = new AtomicLong();     private int targetVersion;      public OutboundTcpConnection(OutboundTcpConnectionPool pool)     {         super("WRITE-" + pool.endPoint());         this.poolReference = pool;     }      private static boolean isLocalDC(InetAddress targetHost)     {         String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);         String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());         return remoteDC.equals(localDC);     }      public void enqueue(MessageOut<?> message, String id)     {         expireMessages();         try         {             backlog.put(new QueuedMessage(message, id));         }         catch (InterruptedException e)         {             throw new AssertionError(e);         }     }      void closeSocket(boolean destroyThread)     {         active.clear();         backlog.clear();         isStopped = destroyThread; // Exit loop to stop the thread         enqueue(CLOSE_SENTINEL, null);     }      void softCloseSocket()     {         enqueue(CLOSE_SENTINEL, null);     }      public int getTargetVersion()     {         return targetVersion;     }      public void run()     {         while (true)         {             QueuedMessage qm = active.poll();             if (qm == null)             {                 // exhausted the active queue.  switch to backlog, once there's something to process there                 try                 {                     qm = backlog.take();                 }                 catch (InterruptedException e)                 {                     throw new AssertionError(e);                 }                  BlockingQueue<QueuedMessage> tmp = backlog;                 backlog = active;                 active = tmp;             }              MessageOut<?> m = qm.message;             if (m == CLOSE_SENTINEL)             {                 disconnect();                 if (isStopped)                     break;                 continue;             }             if (qm.timestamp < System.currentTimeMillis() - m.getTimeout())                 dropped.incrementAndGet();             else if (socket != null || connect())                 writeConnected(qm);             else                 // clear out the queue, else gossip messages back up.                 active.clear();         }     }      public int getPendingMessages()     {         return active.size() + backlog.size();     }      public long getCompletedMesssages()     {         return completed;     }      public long getDroppedMessages()     {         return dropped.get();     }      private boolean shouldCompressConnection()     {         // assumes version >= 1.2         return DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all                || (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc && !isLocalDC(poolReference.endPoint()));     }      private void writeConnected(QueuedMessage qm)     {         try         {             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);             if (sessionBytes != null)             {                 UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));                 TraceState state = Tracing.instance().get(sessionId);                 String message = String.format("Sending message to %s", poolReference.endPoint());                 // session may have already finished; see CASSANDRA-5668                 if (state == null)                 {                     TraceState.trace(ByteBuffer.wrap(sessionBytes), message, -1);                 }                 else                 {                     state.trace(message);                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)                         Tracing.instance().stopNonLocal(state);                 }             }              write(qm.message, qm.id, qm.timestamp, out, targetVersion);             completed++;             if (active.peek() == null)             {                 out.flush();             }         }         catch (Exception e)         {             disconnect();             if (e instanceof IOException)             {                 if (logger.isDebugEnabled())                     logger.debug("error writing to " + poolReference.endPoint(), e);                  // if the message was important, such as a repair acknowledgement, put it back on the queue                 // to retry after re-connecting.  See CASSANDRA-5393                 if (e instanceof SocketException && qm.shouldRetry())                 {                     try                     {                         backlog.put(new RetriedQueuedMessage(qm));                     }                     catch (InterruptedException e1)                     {                         throw new AssertionError(e1);                     }                 }             }             else             {                 // Non IO exceptions are likely a programming error so let's not silence them                 logger.error("error writing to " + poolReference.endPoint(), e);             }         }     }      public static void write(MessageOut message, String id, long timestamp, DataOutputStream out, int version) throws IOException     {         out.writeInt(MessagingService.PROTOCOL_MAGIC);         if (version < MessagingService.VERSION_12)         {             writeHeader(out, version, false);             // 0.8 included a total message size int.  1.0 doesn't need it but expects it to be there.             out.writeInt(-1);         }          out.writeUTF(id);         if (version >= MessagingService.VERSION_12)         {             // int cast cuts off the high-order half of the timestamp, which we can assume remains             // the same between now and when the recipient reconstructs it.             out.writeInt((int) timestamp);         }         message.serialize(out, version);     }      private static void writeHeader(DataOutputStream out, int version, boolean compressionEnabled) throws IOException     {         // 2 bits: unused.  used to be "serializer type," which was always Binary         // 1 bit: compression         // 1 bit: streaming mode         // 3 bits: unused         // 8 bits: version         // 15 bits: unused         int header = 0;         if (compressionEnabled)             header |= 4;         header |= (version << 8);         out.writeInt(header);     }      private void disconnect()     {         if (socket != null)         {             try             {                 socket.close();             }             catch (IOException e)             {                 if (logger.isTraceEnabled())                     logger.trace("exception closing connection to " + poolReference.endPoint(), e);             }             out = null;             socket = null;         }     }      private boolean connect()     {         if (logger.isDebugEnabled())             logger.debug("attempting to connect to " + poolReference.endPoint());          targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());          long start = System.currentTimeMillis();         while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())         {             try             {                 socket = poolReference.newSocket();                 socket.setKeepAlive(true);                 if (isLocalDC(poolReference.endPoint()))                 {                     socket.setTcpNoDelay(true);                 }                 else                 {                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());                 }                 if (DatabaseDescriptor.getInternodeSendBufferSize() != null)                 {                     try                     {                         socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize().intValue());                     }                     catch (SocketException se)                     {                         logger.warn("Failed to set send buffer size on internode socket.", se);                     }                 }                 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));                  if (targetVersion >= MessagingService.VERSION_12)                 {                     out.writeInt(MessagingService.PROTOCOL_MAGIC);                     writeHeader(out, targetVersion, shouldCompressConnection());                     out.flush();                      DataInputStream in = new DataInputStream(socket.getInputStream());                     int maxTargetVersion = in.readInt();                     if (targetVersion > maxTargetVersion)                     {                         logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);                         disconnect();                         return false;                     }                      if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)                     {                         logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",                                      maxTargetVersion, targetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));                         softCloseSocket();                     }                      out.writeInt(MessagingService.current_version);                     CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(), out);                     if (shouldCompressConnection())                     {                         out.flush();                         logger.trace("Upgrading OutputStream to be compressed");                         out = new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));                     }                 }                  return true;             }             catch (IOException e)             {                 socket = null;                 if (logger.isTraceEnabled())                     logger.trace("unable to connect to " + poolReference.endPoint(), e);                 try                 {                     Thread.sleep(OPEN_RETRY_DELAY);                 }                 catch (InterruptedException e1)                 {                     throw new AssertionError(e1);                 }             }         }         return false;     }      private void expireMessages()     {         while (true)         {             QueuedMessage qm = backlog.peek();             if (qm == null || qm.timestamp >= System.currentTimeMillis() - qm.message.getTimeout())                 break;              QueuedMessage qm2 = backlog.poll();             if (qm2 != qm)             {                 // sending thread switched queues.  add this entry (from the "new" backlog)                 // at the end of the active queue, which keeps it in the same position relative to the other entries                 // without having to contend with other clients for the head-of-backlog lock.                 if (qm2 != null)                     active.add(qm2);                 break;             }              dropped.incrementAndGet();         }     }      /** messages that have not been retried yet */     private static class QueuedMessage     {         final MessageOut<?> message;         final String id;         final long timestamp;          QueuedMessage(MessageOut<?> message, String id)         {             this.message = message;             this.id = id;             this.timestamp = System.currentTimeMillis();         }          boolean shouldRetry()         {             return !MessagingService.DROPPABLE_VERBS.contains(message.verb);         }     }      private static class RetriedQueuedMessage extends QueuedMessage     {         RetriedQueuedMessage(QueuedMessage msg)         {             super(msg.message, msg.id);         }          boolean shouldRetry()         {             return false;         }     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> java : Folder]
			[NT -> org : Folder]
				[NT -> apache : Folder]
					[NT -> cassandra : Folder]
						[NT -> net : Folder]
							[NT -> OutboundTcpConnection.java.merge : .java.merge-File]
								[T -> OutboundTcpConnection.java : .java-Content "/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.cassandra.net;  import java.io.BufferedOutputStream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.InetAddress; import java.net.Socket; import java.net.SocketException; import java.nio.ByteBuffer; import java.util.UUID; import java.util.concurrent.BlockingQueue; import java.util.concurrent.CountDownLatch; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import org.apache.cassandra.tracing.TraceState; import org.apache.cassandra.tracing.Tracing; import org.apache.cassandra.utils.FBUtilities; import org.apache.cassandra.utils.UUIDGen; import org.xerial.snappy.SnappyOutputStream;  import org.apache.cassandra.config.Config; import org.apache.cassandra.config.DatabaseDescriptor;  public class OutboundTcpConnection extends Thread {     private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);      private static final MessageOut CLOSE_SENTINEL = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE);     private volatile boolean isStopped = false;      private static final int OPEN_RETRY_DELAY = 100; // ms between retries     private static final int WAIT_FOR_VERSION_MAX_TIME = 5000;     private static final int NO_VERSION = Integer.MIN_VALUE;      // sending thread reads from "active" (one of queue1, queue2) until it is empty.     // then it swaps it with "backlog."     private volatile BlockingQueue<QueuedMessage> backlog = new LinkedBlockingQueue<QueuedMessage>();     private volatile BlockingQueue<QueuedMessage> active = new LinkedBlockingQueue<QueuedMessage>();      private final OutboundTcpConnectionPool poolReference;      private DataOutputStream out;     private Socket socket;     private volatile long completed;     private final AtomicLong dropped = new AtomicLong();     private int targetVersion;      public OutboundTcpConnection(OutboundTcpConnectionPool pool)     {         super("WRITE-" + pool.endPoint());         this.poolReference = pool;     }      private static boolean isLocalDC(InetAddress targetHost)     {         String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);         String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());         return remoteDC.equals(localDC);     }      public void enqueue(MessageOut<?> message, String id)     {         expireMessages();         try         {             backlog.put(new QueuedMessage(message, id));         }         catch (InterruptedException e)         {             throw new AssertionError(e);         }     }      void closeSocket(boolean destroyThread)     {         active.clear();         backlog.clear();         isStopped = destroyThread; // Exit loop to stop the thread         enqueue(CLOSE_SENTINEL, null);     }      void softCloseSocket()     {         enqueue(CLOSE_SENTINEL, null);     }      public int getTargetVersion()     {         return targetVersion;     }      public void run()     {         while (true)         {             QueuedMessage qm = active.poll();             if (qm == null)             {                 // exhausted the active queue.  switch to backlog, once there's something to process there                 try                 {                     qm = backlog.take();                 }                 catch (InterruptedException e)                 {                     throw new AssertionError(e);                 }                  BlockingQueue<QueuedMessage> tmp = backlog;                 backlog = active;                 active = tmp;             }              MessageOut<?> m = qm.message;             if (m == CLOSE_SENTINEL)             {                 disconnect();                 if (isStopped)                     break;                 continue;             }             if (qm.timestamp < System.currentTimeMillis() - m.getTimeout())                 dropped.incrementAndGet();             else if (socket != null || connect())                 writeConnected(qm);             else                 // clear out the queue, else gossip messages back up.                 active.clear();         }     }      public int getPendingMessages()     {         return active.size() + backlog.size();     }      public long getCompletedMesssages()     {         return completed;     }      public long getDroppedMessages()     {         return dropped.get();     }      private boolean shouldCompressConnection()     {         // assumes version >= 1.2         return DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all                || (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc && !isLocalDC(poolReference.endPoint()));     }      private void writeConnected(QueuedMessage qm)     {         try         {             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);             if (sessionBytes != null)             {                 UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));                 TraceState state = Tracing.instance().get(sessionId);                 String message = String.format("Sending message to %s", poolReference.endPoint());                 // session may have already finished; see CASSANDRA-5668                 if (state == null)                 {                     TraceState.trace(ByteBuffer.wrap(sessionBytes), message, -1);                 }                 else                 {                     state.trace(message);                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)                         Tracing.instance().stopNonLocal(state);                 }             }              write(qm.message, qm.id, qm.timestamp, out, targetVersion);             completed++;             if (active.peek() == null)             {                 out.flush();             }         }         catch (Exception e)         {             disconnect();             if (e instanceof IOException)             {                 if (logger.isDebugEnabled())                     logger.debug("error writing to " + poolReference.endPoint(), e);                  // if the message was important, such as a repair acknowledgement, put it back on the queue                 // to retry after re-connecting.  See CASSANDRA-5393                 if (e instanceof SocketException && qm.shouldRetry())                 {                     try                     {                         backlog.put(new RetriedQueuedMessage(qm));                     }                     catch (InterruptedException e1)                     {                         throw new AssertionError(e1);                     }                 }             }             else             {                 // Non IO exceptions are likely a programming error so let's not silence them                 logger.error("error writing to " + poolReference.endPoint(), e);             }         }     }      public static void write(MessageOut message, String id, long timestamp, DataOutputStream out, int version) throws IOException     {         out.writeInt(MessagingService.PROTOCOL_MAGIC);         if (version < MessagingService.VERSION_12)         {             writeHeader(out, version, false);             // 0.8 included a total message size int.  1.0 doesn't need it but expects it to be there.             out.writeInt(-1);         }          out.writeUTF(id);         if (version >= MessagingService.VERSION_12)         {             // int cast cuts off the high-order half of the timestamp, which we can assume remains             // the same between now and when the recipient reconstructs it.             out.writeInt((int) timestamp);         }         message.serialize(out, version);     }      private static void writeHeader(DataOutputStream out, int version, boolean compressionEnabled) throws IOException     {         // 2 bits: unused.  used to be "serializer type," which was always Binary         // 1 bit: compression         // 1 bit: streaming mode         // 3 bits: unused         // 8 bits: version         // 15 bits: unused         int header = 0;         if (compressionEnabled)             header |= 4;         header |= (version << 8);         out.writeInt(header);     }      private void disconnect()     {         if (socket != null)         {             try             {                 socket.close();             }             catch (IOException e)             {                 if (logger.isTraceEnabled())                     logger.trace("exception closing connection to " + poolReference.endPoint(), e);             }             out = null;             socket = null;         }     }      private boolean connect()     {         if (logger.isDebugEnabled())             logger.debug("attempting to connect to " + poolReference.endPoint());          long start = System.currentTimeMillis();         while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())         {             targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());             try             {                 socket = poolReference.newSocket();                 socket.setKeepAlive(true);                 if (isLocalDC(poolReference.endPoint()))                 {                     socket.setTcpNoDelay(true);                 }                 else                 {                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());                 }                 if (DatabaseDescriptor.getInternodeSendBufferSize() != null)                 {                     try                     {                         socket.setSendBufferSize(DatabaseDescriptor.getInternodeSendBufferSize().intValue());                     }                     catch (SocketException se)                     {                         logger.warn("Failed to set send buffer size on internode socket.", se);                     }                 }                 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));                  if (targetVersion >= MessagingService.VERSION_12)                 {                     out.writeInt(MessagingService.PROTOCOL_MAGIC);                     writeHeader(out, targetVersion, shouldCompressConnection());                     out.flush();                      DataInputStream in = new DataInputStream(socket.getInputStream());                     int maxTargetVersion = handshakeVersion(in);                     if (maxTargetVersion == NO_VERSION)                      {                         // no version is returned, so disconnect an try again: we will either get                         // a different target version (targetVersion < MessagingService.VERSION_12)                         // or if the same version the handshake will finally succeed                         logger.debug("Target max version is {}; no version information yet, will retry", maxTargetVersion);                         disconnect();                         continue;                     }                     if (targetVersion > maxTargetVersion)                     {                         logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);                         disconnect();                         return false;                     }                      if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)                     {                         logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",                                      maxTargetVersion, targetVersion);                         MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));                         softCloseSocket();                     }                      out.writeInt(MessagingService.current_version);                     CompactEndpointSerializationHelper.serialize(FBUtilities.getBroadcastAddress(), out);                     if (shouldCompressConnection())                     {                         out.flush();                         logger.trace("Upgrading OutputStream to be compressed");                         out = new DataOutputStream(new SnappyOutputStream(new BufferedOutputStream(socket.getOutputStream())));                     }                 }                  return true;             }             catch (IOException e)             {                 socket = null;                 if (logger.isTraceEnabled())                     logger.trace("unable to connect to " + poolReference.endPoint(), e);                 try                 {                     Thread.sleep(OPEN_RETRY_DELAY);                 }                 catch (InterruptedException e1)                 {                     throw new AssertionError(e1);                 }             }         }         return false;     }          private int handshakeVersion(final DataInputStream inputStream)     {         final AtomicInteger version = new AtomicInteger(NO_VERSION);         final CountDownLatch versionLatch = new CountDownLatch(1);         new Thread("HANDSHAKE-" + poolReference.endPoint())         {             @Override             public void run()             {                 try                 {                     logger.info("Handshaking version with {}", poolReference.endPoint());                     version.set(inputStream.readInt());                 }                 catch (IOException ex)                  {                     final String msg = "Cannot handshake version with " + poolReference.endPoint();                     if (logger.isTraceEnabled())                         logger.trace(msg, ex);                     else                         logger.info(msg);                 }                 finally                 {                     //unblock the waiting thread on either success or fail                     versionLatch.countDown();                 }             }         }.start();          try         {             versionLatch.await(WAIT_FOR_VERSION_MAX_TIME, TimeUnit.MILLISECONDS);         }         catch (InterruptedException ex)         {             throw new AssertionError(ex);         }         return version.get();     }      private void expireMessages()     {         while (true)         {             QueuedMessage qm = backlog.peek();             if (qm == null || qm.timestamp >= System.currentTimeMillis() - qm.message.getTimeout())                 break;              QueuedMessage qm2 = backlog.poll();             if (qm2 != qm)             {                 // sending thread switched queues.  add this entry (from the "new" backlog)                 // at the end of the active queue, which keeps it in the same position relative to the other entries                 // without having to contend with other clients for the head-of-backlog lock.                 if (qm2 != null)                     active.add(qm2);                 break;             }              dropped.incrementAndGet();         }     }      /** messages that have not been retried yet */     private static class QueuedMessage     {         final MessageOut<?> message;         final String id;         final long timestamp;          QueuedMessage(MessageOut<?> message, String id)         {             this.message = message;             this.id = id;             this.timestamp = System.currentTimeMillis();         }          boolean shouldRetry()         {             return !MessagingService.DROPPABLE_VERBS.contains(message.verb);         }     }      private static class RetriedQueuedMessage extends QueuedMessage     {         RetriedQueuedMessage(QueuedMessage msg)         {             super(msg.message, msg.id);         }          boolean shouldRetry()         {             return false;         }     } } " compose:StringConcatenation merge: LineBased]
