Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java
[NT -> left : Feature]
	[NT -> json-path : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> jayway : Folder]
							[NT -> jsonpath : Folder]
								[NT -> internal : Folder]
									[NT -> Utils.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.jayway.jsonpath.internal;" compose:Replacement merge: Default]
											[T -> com.jayway.jsonpath.JsonPathException{ImportPackage} : ImportDeclaration "import com.jayway.jsonpath.JsonPathException;" compose:Replacement merge: Default]
											[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: Default]
											[T -> java.io.ByteArrayOutputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayOutputStream;" compose:Replacement merge: Default]
											[T -> java.io.Closeable{ImportPackage} : ImportDeclaration "import java.io.Closeable;" compose:Replacement merge: Default]
											[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
											[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectInputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectInputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectOutputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectOutputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectStreamClass{ImportPackage} : ImportDeclaration "import java.io.ObjectStreamClass;" compose:Replacement merge: Default]
											[T -> java.io.OutputStream{ImportPackage} : ImportDeclaration "import java.io.OutputStream;" compose:Replacement merge: Default]
											[T -> java.io.Serializable{ImportPackage} : ImportDeclaration "import java.io.Serializable;" compose:Replacement merge: Default]
											[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
											[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
											[T -> java.util.Iterator{ImportPackage} : ImportDeclaration "import java.util.Iterator;" compose:Replacement merge: Default]
											[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
											[NT -> Utils : ClassDeclaration]
												[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> Utils : Id "Utils" compose:Replacement merge: Default]
												[T -> CR : FieldDecl "public static final String CR = System.getProperty("line.separator");" compose:Replacement merge: SemanticConflict]
												[T -> createRange(int-int-int-int) : MethodDecl "public static List<Integer> createRange(int start, int end) {         if (end <= start) {             throw new IllegalArgumentException("Cannot create range from " + start + " to " + end + ", end must be greater than start.");         }         if (start == end-1) {             return Collections.emptyList();         }         List<Integer> range = new ArrayList<Integer>(end-start-1);         for (int i = start; i < end; i++) {             range.add(i);         }         return range;     }" compose:Replacement merge: LineBased]
												[T -> join(String-String-String-String-Iterable<?extendsObject>-Iterable<?extendsObject>) : MethodDecl "public static String join(String delimiter, String wrap, Iterable<? extends Object> objs) {         Iterator<? extends Object> iter = objs.iterator();         if (!iter.hasNext()) {             return "";         }         StringBuilder buffer = new StringBuilder();         buffer.append(wrap).append(iter.next()).append(wrap);         while (iter.hasNext()) {             buffer.append(delimiter).append(wrap).append(iter.next()).append(wrap);         }         return buffer.toString();     }" compose:Replacement merge: LineBased]
												[T -> join(String-String-Iterable<?extendsObject>-Iterable<?extendsObject>) : MethodDecl "public static String join(String delimiter, Iterable<? extends Object> objs) {         return join(delimiter, "", objs);     }" compose:Replacement merge: LineBased]
												[T -> closeQuietly(Closeable-Closeable) : MethodDecl "public static void closeQuietly(Closeable closeable) {         try {             if (closeable != null) {                 closeable.close();             }         } catch (IOException ignore) {         }     }" compose:Replacement merge: LineBased]
												[T -> isInt(String-String) : MethodDecl "public static boolean isInt(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false) {                 return false;             }         }         return true;     }" compose:Replacement merge: LineBased]
												[T -> isNumeric(String-String) : MethodDecl "public static boolean isNumeric(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false && !(str.charAt(i) == '.')) {                 return false;             }         }         return true;     }" compose:Replacement merge: LineBased]
												[T -> isEmpty(CharSequence-CharSequence) : MethodDecl "public static boolean isEmpty(CharSequence cs) {         return cs == null || cs.length() == 0;     }" compose:Replacement merge: LineBased]
												[T -> indexOf(CharSequence-CharSequence-CharSequence-CharSequence-int-int) : MethodDecl "static int indexOf(CharSequence cs, CharSequence searchChar, int start) {         return cs.toString().indexOf(searchChar.toString(), start);     }" compose:Replacement merge: LineBased]
												[T -> countMatches(CharSequence-CharSequence-CharSequence-CharSequence) : MethodDecl "public static int countMatches(CharSequence str, CharSequence sub) {         if (isEmpty(str) || isEmpty(sub)) {             return 0;         }         int count = 0;         int idx = 0;         while ((idx = indexOf(str, sub, idx)) != -1) {             count++;             idx += sub.length();         }         return count;     }" compose:Replacement merge: LineBased]
												[T -> notNull(T-T-String-String-Object-Object) : MethodDecl "public static <T> T notNull(T object, String message, Object... values) {         if (object == null) {             throw new IllegalArgumentException(String.format(message, values));         }         return object;     }" compose:Replacement merge: LineBased]
												[T -> isTrue(boolean-boolean-String-String) : MethodDecl "public static void isTrue(boolean expression, String message) {         if (expression == false) {             throw new IllegalArgumentException(message);         }     }" compose:Replacement merge: LineBased]
												[T -> notEmpty(T-T-String-String-Object-Object) : MethodDecl "public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {         if (chars == null) {             throw new IllegalArgumentException(String.format(message, values));         }         if (chars.length() == 0) {             throw new IllegalArgumentException(String.format(message, values));         }         return chars;     }" compose:Replacement merge: LineBased]
												[T -> toString(Object-Object) : MethodDecl "public static String toString(Object o) {         if (null == o) {             return null;         }          return o.toString();     }" compose:Replacement merge: LineBased]
												[T -> serialize(Serializable-Serializable-OutputStream-OutputStream) : MethodDecl "public static void serialize(Serializable obj, OutputStream outputStream) {         if (outputStream == null) {             throw new IllegalArgumentException("The OutputStream must not be null");         }         ObjectOutputStream out = null;         try {             // stream closed in the finally             out = new ObjectOutputStream(outputStream);             out.writeObject(obj);          } catch (IOException ex) {             throw new JsonPathException(ex);         } finally {             try {                 if (out != null) {                     out.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }" compose:Replacement merge: LineBased]
												[T -> serialize(Serializable-Serializable) : MethodDecl "public static byte[] serialize(Serializable obj) {         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);         serialize(obj, baos);         return baos.toByteArray();     }" compose:Replacement merge: LineBased]
												[T -> deserialize(InputStream-InputStream) : MethodDecl "public static Object deserialize(InputStream inputStream) {         if (inputStream == null) {             throw new IllegalArgumentException("The InputStream must not be null");         }         ObjectInputStream in = null;         try {             // stream closed in the finally             in = new ObjectInputStream(inputStream);             return in.readObject();          } catch (ClassNotFoundException ex) {             throw new JsonPathException(ex);         } catch (IOException ex) {             throw new JsonPathException(ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }" compose:Replacement merge: LineBased]
												[T -> deserialize(byte[]-byte[]) : MethodDecl "public static Object deserialize(byte[] objectData) {         if (objectData == null) {             throw new IllegalArgumentException("The byte[] must not be null");         }         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);         return deserialize(bais);     }" compose:Replacement merge: LineBased]
												[NT -> ClassLoaderAwareObjectInputStream : InnerClassDecl]
													[T -> - : Modifiers "static" compose:Replacement merge: SemanticConflict]
													[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
													[T -> ClassLoaderAwareObjectInputStream : Id "ClassLoaderAwareObjectInputStream" compose:Replacement merge: Default]
													[T -> - : ExtendsList "extends ObjectInputStream" compose:Replacement merge: Default]
													[T -> classLoader : FieldDecl "private ClassLoader classLoader;" compose:Replacement merge: SemanticConflict]
													[T -> ClassLoaderAwareObjectInputStream(InputStream-InputStream-ClassLoader-ClassLoader) : ConstructorDecl "public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {             super(in);             this.classLoader = classLoader;         }" compose:Replacement merge: LineBased]
													[T -> resolveClass(ObjectStreamClass-ObjectStreamClass) : MethodDecl "@Override         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             }         }" compose:Replacement merge: LineBased]
												[T -> Utils({FormalParametersInternal}) : ConstructorDecl "private Utils () {}" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> json-path : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> jayway : Folder]
							[NT -> jsonpath : Folder]
								[NT -> internal : Folder]
									[NT -> Utils.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.jayway.jsonpath.internal;" compose:Replacement merge: Default]
											[T -> com.jayway.jsonpath.InvalidConversionException{ImportPackage} : ImportDeclaration "import com.jayway.jsonpath.InvalidConversionException;" compose:Replacement merge: Default]
											[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: Default]
											[T -> java.io.ByteArrayOutputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayOutputStream;" compose:Replacement merge: Default]
											[T -> java.io.Closeable{ImportPackage} : ImportDeclaration "import java.io.Closeable;" compose:Replacement merge: Default]
											[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
											[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectInputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectInputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectOutputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectOutputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectStreamClass{ImportPackage} : ImportDeclaration "import java.io.ObjectStreamClass;" compose:Replacement merge: Default]
											[T -> java.io.OutputStream{ImportPackage} : ImportDeclaration "import java.io.OutputStream;" compose:Replacement merge: Default]
											[T -> java.io.Serializable{ImportPackage} : ImportDeclaration "import java.io.Serializable;" compose:Replacement merge: Default]
											[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
											[T -> java.util.Iterator{ImportPackage} : ImportDeclaration "import java.util.Iterator;" compose:Replacement merge: Default]
											[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
											[NT -> Utils : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> Utils : Id "Utils" compose:Replacement merge: Default]
												[T -> CR : FieldDecl "public static final String CR = System.getProperty("line.separator");" compose:Replacement merge: SemanticConflict]
												[T -> createRange(int-int-int-int) : MethodDecl "public static List<Integer> createRange(int start, int end) {         List<Integer> range = new ArrayList<Integer>();         for (int i = start; i < end; i++) {             range.add(i);         }         return range;     }" compose:Replacement merge: LineBased]
												[T -> join(String-String-String-String-Iterable<?extendsObject>-Iterable<?extendsObject>) : MethodDecl "public static String join(String delimiter, String wrap, Iterable<? extends Object> objs) {         Iterator<? extends Object> iter = objs.iterator();         if (!iter.hasNext()) {             return "";         }          StringBuilder buffer = new StringBuilder();         buffer.append(wrap).append(iter.next()).append(wrap);         while (iter.hasNext()) {             buffer.append(delimiter).append(wrap).append(iter.next()).append(wrap);         }         return buffer.toString();     }" compose:Replacement merge: LineBased]
												[T -> join(String-String-Iterable<?extendsObject>-Iterable<?extendsObject>) : MethodDecl "public static String join(String delimiter, Iterable<? extends Object> objs) {         return join(delimiter, "", objs);     }" compose:Replacement merge: LineBased]
												[T -> closeQuietly(Closeable-Closeable) : MethodDecl "public static void closeQuietly(Closeable closeable) {         try {             if (closeable != null) {                 closeable.close();             }         } catch (IOException ignore) {         }     }" compose:Replacement merge: LineBased]
												[T -> isInt(String-String) : MethodDecl "public static boolean isInt(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false) {                 return false;             }         }         return true;     }" compose:Replacement merge: LineBased]
												[T -> isNumeric(String-String) : MethodDecl "public static boolean isNumeric(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false && !(str.charAt(i) == '.')) {                 return false;             }         }         return true;     }" compose:Replacement merge: LineBased]
												[T -> isEmpty(CharSequence-CharSequence) : MethodDecl "public static boolean isEmpty(CharSequence cs) {         return cs == null || cs.length() == 0;     }" compose:Replacement merge: LineBased]
												[T -> indexOf(CharSequence-CharSequence-CharSequence-CharSequence-int-int) : MethodDecl "static int indexOf(CharSequence cs, CharSequence searchChar, int start) {         return cs.toString().indexOf(searchChar.toString(), start);     }" compose:Replacement merge: LineBased]
												[T -> countMatches(CharSequence-CharSequence-CharSequence-CharSequence) : MethodDecl "public static int countMatches(CharSequence str, CharSequence sub) {         if (isEmpty(str) || isEmpty(sub)) {             return 0;         }         int count = 0;         int idx = 0;         while ((idx = indexOf(str, sub, idx)) != -1) {             count++;             idx += sub.length();         }         return count;     }" compose:Replacement merge: LineBased]
												[T -> notNull(T-T-String-String-Object-Object) : MethodDecl "public static <T> T notNull(T object, String message, Object... values) {         if (object == null) {             throw new IllegalArgumentException(String.format(message, values));         }         return object;     }" compose:Replacement merge: LineBased]
												[T -> isTrue(boolean-boolean-String-String) : MethodDecl "public static void isTrue(boolean expression, String message) {         if (expression == false) {             throw new IllegalArgumentException(message);         }     }" compose:Replacement merge: LineBased]
												[T -> notEmpty(T-T-String-String-Object-Object) : MethodDecl "public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {         if (chars == null) {             throw new IllegalArgumentException(String.format(message, values));         }         if (chars.length() == 0) {             throw new IllegalArgumentException(String.format(message, values));         }         return chars;     }" compose:Replacement merge: LineBased]
												[T -> toString(Object-Object) : MethodDecl "public static String toString(Object o) {         if (null == o) {             return null;         }          return o.toString();     }" compose:Replacement merge: LineBased]
												[T -> clone(T-T) : MethodDecl "public static <T extends Serializable> T clone(T object) {         if (object == null) {             return null;         }         byte[] objectData = serialize(object);         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);          ClassLoaderAwareObjectInputStream in = null;         try {             // stream closed in the finally             in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());             /*              * when we serialize and deserialize an object,              * it is reasonable to assume the deserialized object              * is of the same type as the original serialized object              */             @SuppressWarnings("unchecked") // see above                     T readObject = (T) in.readObject();             return readObject;          } catch (ClassNotFoundException ex) {             throw new RuntimeException("ClassNotFoundException while reading cloned object data", ex);         } catch (IOException ex) {             throw new RuntimeException("IOException while reading cloned object data", ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) {                 throw new RuntimeException("IOException on closing cloned object data InputStream.", ex);             }         }     }" compose:Replacement merge: LineBased]
												[T -> serialize(Serializable-Serializable-OutputStream-OutputStream) : MethodDecl "public static void serialize(Serializable obj, OutputStream outputStream) {         if (outputStream == null) {             throw new IllegalArgumentException("The OutputStream must not be null");         }         ObjectOutputStream out = null;         try {             // stream closed in the finally             out = new ObjectOutputStream(outputStream);             out.writeObject(obj);          } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (out != null) {                     out.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }" compose:Replacement merge: LineBased]
												[T -> serialize(Serializable-Serializable) : MethodDecl "public static byte[] serialize(Serializable obj) {         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);         serialize(obj, baos);         return baos.toByteArray();     }" compose:Replacement merge: LineBased]
												[T -> deserialize(InputStream-InputStream) : MethodDecl "public static Object deserialize(InputStream inputStream) {         if (inputStream == null) {             throw new IllegalArgumentException("The InputStream must not be null");         }         ObjectInputStream in = null;         try {             // stream closed in the finally             in = new ObjectInputStream(inputStream);             return in.readObject();          } catch (ClassNotFoundException ex) {             throw new RuntimeException(ex);         } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }" compose:Replacement merge: LineBased]
												[T -> deserialize(byte[]-byte[]) : MethodDecl "public static Object deserialize(byte[] objectData) {         if (objectData == null) {             throw new IllegalArgumentException("The byte[] must not be null");         }         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);         return deserialize(bais);     }" compose:Replacement merge: LineBased]
												[NT -> ClassLoaderAwareObjectInputStream : InnerClassDecl]
													[T -> - : Modifiers "static" compose:Replacement merge: SemanticConflict]
													[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
													[T -> ClassLoaderAwareObjectInputStream : Id "ClassLoaderAwareObjectInputStream" compose:Replacement merge: Default]
													[T -> - : ExtendsList "extends ObjectInputStream" compose:Replacement merge: Default]
													[T -> classLoader : FieldDecl "private ClassLoader classLoader;" compose:Replacement merge: SemanticConflict]
													[T -> ClassLoaderAwareObjectInputStream(InputStream-InputStream-ClassLoader-ClassLoader) : ConstructorDecl "public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {             super(in);             this.classLoader = classLoader;         }" compose:Replacement merge: LineBased]
													[T -> resolveClass(ObjectStreamClass-ObjectStreamClass) : MethodDecl "@Override         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             }         }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> json-path : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> jayway : Folder]
							[NT -> jsonpath : Folder]
								[NT -> internal : Folder]
									[NT -> Utils.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.jayway.jsonpath.internal;" compose:Replacement merge: Default]
											[T -> java.io.ByteArrayInputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayInputStream;" compose:Replacement merge: Default]
											[T -> java.io.ByteArrayOutputStream{ImportPackage} : ImportDeclaration "import java.io.ByteArrayOutputStream;" compose:Replacement merge: Default]
											[T -> java.io.Closeable{ImportPackage} : ImportDeclaration "import java.io.Closeable;" compose:Replacement merge: Default]
											[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
											[T -> java.io.InputStream{ImportPackage} : ImportDeclaration "import java.io.InputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectInputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectInputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectOutputStream{ImportPackage} : ImportDeclaration "import java.io.ObjectOutputStream;" compose:Replacement merge: Default]
											[T -> java.io.ObjectStreamClass{ImportPackage} : ImportDeclaration "import java.io.ObjectStreamClass;" compose:Replacement merge: Default]
											[T -> java.io.OutputStream{ImportPackage} : ImportDeclaration "import java.io.OutputStream;" compose:Replacement merge: Default]
											[T -> java.io.Serializable{ImportPackage} : ImportDeclaration "import java.io.Serializable;" compose:Replacement merge: Default]
											[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
											[T -> java.util.Iterator{ImportPackage} : ImportDeclaration "import java.util.Iterator;" compose:Replacement merge: Default]
											[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
											[NT -> Utils : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> Utils : Id "Utils" compose:Replacement merge: Default]
												[T -> CR : FieldDecl "public static final String CR = System.getProperty("line.separator");" compose:Replacement merge: SemanticConflict]
												[T -> createRange(int-int-int-int) : MethodDecl "public static List<Integer> createRange(int start, int end) {         List<Integer> range = new ArrayList<Integer>();         for (int i = start; i < end; i++) {             range.add(i);         }         return range;     }" compose:Replacement merge: LineBased]
												[T -> join(String-String-String-String-Iterable<?extendsObject>-Iterable<?extendsObject>) : MethodDecl "public static String join(String delimiter, String wrap, Iterable<? extends Object> objs) {         Iterator<? extends Object> iter = objs.iterator();         if (!iter.hasNext()) {             return "";         }          StringBuilder buffer = new StringBuilder();         buffer.append(wrap).append(iter.next()).append(wrap);         while (iter.hasNext()) {             buffer.append(delimiter).append(wrap).append(iter.next()).append(wrap);         }         return buffer.toString();     }" compose:Replacement merge: LineBased]
												[T -> join(String-String-Iterable<?extendsObject>-Iterable<?extendsObject>) : MethodDecl "public static String join(String delimiter, Iterable<? extends Object> objs) {         return join(delimiter, "", objs);     }" compose:Replacement merge: LineBased]
												[T -> closeQuietly(Closeable-Closeable) : MethodDecl "public static void closeQuietly(Closeable closeable) {         try {             if (closeable != null) {                 closeable.close();             }         } catch (IOException ignore) {         }     }" compose:Replacement merge: LineBased]
												[T -> isInt(String-String) : MethodDecl "public static boolean isInt(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false) {                 return false;             }         }         return true;     }" compose:Replacement merge: LineBased]
												[T -> isNumeric(String-String) : MethodDecl "public static boolean isNumeric(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false && !(str.charAt(i) == '.')) {                 return false;             }         }         return true;     }" compose:Replacement merge: LineBased]
												[T -> isEmpty(CharSequence-CharSequence) : MethodDecl "public static boolean isEmpty(CharSequence cs) {         return cs == null || cs.length() == 0;     }" compose:Replacement merge: LineBased]
												[T -> indexOf(CharSequence-CharSequence-CharSequence-CharSequence-int-int) : MethodDecl "static int indexOf(CharSequence cs, CharSequence searchChar, int start) {         return cs.toString().indexOf(searchChar.toString(), start);     }" compose:Replacement merge: LineBased]
												[T -> countMatches(CharSequence-CharSequence-CharSequence-CharSequence) : MethodDecl "public static int countMatches(CharSequence str, CharSequence sub) {         if (isEmpty(str) || isEmpty(sub)) {             return 0;         }         int count = 0;         int idx = 0;         while ((idx = indexOf(str, sub, idx)) != -1) {             count++;             idx += sub.length();         }         return count;     }" compose:Replacement merge: LineBased]
												[T -> notNull(T-T-String-String-Object-Object) : MethodDecl "public static <T> T notNull(T object, String message, Object... values) {         if (object == null) {             throw new IllegalArgumentException(String.format(message, values));         }         return object;     }" compose:Replacement merge: LineBased]
												[T -> isTrue(boolean-boolean-String-String) : MethodDecl "public static void isTrue(boolean expression, String message) {         if (expression == false) {             throw new IllegalArgumentException(message);         }     }" compose:Replacement merge: LineBased]
												[T -> notEmpty(T-T-String-String-Object-Object) : MethodDecl "public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {         if (chars == null) {             throw new IllegalArgumentException(String.format(message, values));         }         if (chars.length() == 0) {             throw new IllegalArgumentException(String.format(message, values));         }         return chars;     }" compose:Replacement merge: LineBased]
												[T -> toString(Object-Object) : MethodDecl "public static String toString(Object o) {         if (null == o) {             return null;         }          return o.toString();     }" compose:Replacement merge: LineBased]
												[T -> clone(T-T) : MethodDecl "public static <T extends Serializable> T clone(T object) {         if (object == null) {             return null;         }         byte[] objectData = serialize(object);         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);          ClassLoaderAwareObjectInputStream in = null;         try {             // stream closed in the finally             in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());             /*              * when we serialize and deserialize an object,              * it is reasonable to assume the deserialized object              * is of the same type as the original serialized object              */             @SuppressWarnings("unchecked") // see above                     T readObject = (T) in.readObject();             return readObject;          } catch (ClassNotFoundException ex) {             throw new RuntimeException("ClassNotFoundException while reading cloned object data", ex);         } catch (IOException ex) {             throw new RuntimeException("IOException while reading cloned object data", ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) {                 throw new RuntimeException("IOException on closing cloned object data InputStream.", ex);             }         }     }" compose:Replacement merge: LineBased]
												[T -> serialize(Serializable-Serializable-OutputStream-OutputStream) : MethodDecl "public static void serialize(Serializable obj, OutputStream outputStream) {         if (outputStream == null) {             throw new IllegalArgumentException("The OutputStream must not be null");         }         ObjectOutputStream out = null;         try {             // stream closed in the finally             out = new ObjectOutputStream(outputStream);             out.writeObject(obj);          } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (out != null) {                     out.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }" compose:Replacement merge: LineBased]
												[T -> serialize(Serializable-Serializable) : MethodDecl "public static byte[] serialize(Serializable obj) {         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);         serialize(obj, baos);         return baos.toByteArray();     }" compose:Replacement merge: LineBased]
												[T -> deserialize(InputStream-InputStream) : MethodDecl "public static Object deserialize(InputStream inputStream) {         if (inputStream == null) {             throw new IllegalArgumentException("The InputStream must not be null");         }         ObjectInputStream in = null;         try {             // stream closed in the finally             in = new ObjectInputStream(inputStream);             return in.readObject();          } catch (ClassNotFoundException ex) {             throw new RuntimeException(ex);         } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }" compose:Replacement merge: LineBased]
												[T -> deserialize(byte[]-byte[]) : MethodDecl "public static Object deserialize(byte[] objectData) {         if (objectData == null) {             throw new IllegalArgumentException("The byte[] must not be null");         }         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);         return deserialize(bais);     }" compose:Replacement merge: LineBased]
												[NT -> ClassLoaderAwareObjectInputStream : InnerClassDecl]
													[T -> - : Modifiers "static" compose:Replacement merge: SemanticConflict]
													[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
													[T -> ClassLoaderAwareObjectInputStream : Id "ClassLoaderAwareObjectInputStream" compose:Replacement merge: Default]
													[T -> - : ExtendsList "extends ObjectInputStream" compose:Replacement merge: Default]
													[T -> classLoader : FieldDecl "private ClassLoader classLoader;" compose:Replacement merge: SemanticConflict]
													[T -> ClassLoaderAwareObjectInputStream(InputStream-InputStream-ClassLoader-ClassLoader) : ConstructorDecl "public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {             super(in);             this.classLoader = classLoader;         }" compose:Replacement merge: LineBased]
													[T -> resolveClass(ObjectStreamClass-ObjectStreamClass) : MethodDecl "@Override         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             }         }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> json-path : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> jayway : Folder]
							[NT -> jsonpath : Folder]
								[NT -> internal : Folder]
									[NT -> Utils.java.merge : .java.merge-File]
										[T -> Utils.java : .java-Content "/*  * Copyright 2011 the original author or authors.  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package com.jayway.jsonpath.internal;  import com.jayway.jsonpath.JsonPathException;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.Closeable; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamClass; import java.io.OutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List;  public final class Utils {      public static final String CR = System.getProperty("line.separator");      /**      * Creates a range of integers from start (inclusive) to end (exclusive)      *      * @param start      * @param end      * @return      */     public static List<Integer> createRange(int start, int end) {         if (end <= start) {             throw new IllegalArgumentException("Cannot create range from " + start + " to " + end + ", end must be greater than start.");         }         if (start == end-1) {             return Collections.emptyList();         }         List<Integer> range = new ArrayList<Integer>(end-start-1);         for (int i = start; i < end; i++) {             range.add(i);         }         return range;     }      // accept a collection of objects, since all objects have toString()     public static String join(String delimiter, String wrap, Iterable<? extends Object> objs) {         Iterator<? extends Object> iter = objs.iterator();         if (!iter.hasNext()) {             return "";         }         StringBuilder buffer = new StringBuilder();         buffer.append(wrap).append(iter.next()).append(wrap);         while (iter.hasNext()) {             buffer.append(delimiter).append(wrap).append(iter.next()).append(wrap);         }         return buffer.toString();     }      // accept a collection of objects, since all objects have toString()     public static String join(String delimiter, Iterable<? extends Object> objs) {         return join(delimiter, "", objs);     }      //---------------------------------------------------------     //     // IO     //     //---------------------------------------------------------      public static void closeQuietly(Closeable closeable) {         try {             if (closeable != null) {                 closeable.close();             }         } catch (IOException ignore) {         }     }      //---------------------------------------------------------     //     // Strings     //     //---------------------------------------------------------     public static boolean isInt(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false) {                 return false;             }         }         return true;     }      public static boolean isNumeric(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false && !(str.charAt(i) == '.')) {                 return false;             }         }         return true;     }      /**      * <p>Checks if a CharSequence is empty ("") or null.</p>      * <p/>      * <pre>      * StringUtils.isEmpty(null)      = true      * StringUtils.isEmpty("")        = true      * StringUtils.isEmpty(" ")       = false      * StringUtils.isEmpty("bob")     = false      * StringUtils.isEmpty("  bob  ") = false      * </pre>      * <p/>      * <p>NOTE: This method changed in Lang version 2.0.      * It no longer trims the CharSequence.      * That functionality is available in isBlank().</p>      *      * @param cs the CharSequence to check, may be null      * @return {@code true} if the CharSequence is empty or null      * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)      */     public static boolean isEmpty(CharSequence cs) {         return cs == null || cs.length() == 0;     }      /**      * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.      *      * @param cs         the {@code CharSequence} to be processed      * @param searchChar the {@code CharSequence} to be searched for      * @param start      the start index      * @return the index where the search sequence was found      */     static int indexOf(CharSequence cs, CharSequence searchChar, int start) {         return cs.toString().indexOf(searchChar.toString(), start);     }      /**      * <p>Counts how many times the substring appears in the larger string.</p>      * <p/>      * <p>A {@code null} or empty ("") String input returns {@code 0}.</p>      * <p/>      * <pre>      * StringUtils.countMatches(null, *)       = 0      * StringUtils.countMatches("", *)         = 0      * StringUtils.countMatches("abba", null)  = 0      * StringUtils.countMatches("abba", "")    = 0      * StringUtils.countMatches("abba", "a")   = 2      * StringUtils.countMatches("abba", "ab")  = 1      * StringUtils.countMatches("abba", "xxx") = 0      * </pre>      *      * @param str the CharSequence to check, may be null      * @param sub the substring to count, may be null      * @return the number of occurrences, 0 if either CharSequence is {@code null}      * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)      */     public static int countMatches(CharSequence str, CharSequence sub) {         if (isEmpty(str) || isEmpty(sub)) {             return 0;         }         int count = 0;         int idx = 0;         while ((idx = indexOf(str, sub, idx)) != -1) {             count++;             idx += sub.length();         }         return count;     }      //---------------------------------------------------------     //     // Validators     //     //---------------------------------------------------------      /**      * <p>Validate that the specified argument is not {@code null};      * otherwise throwing an exception with the specified message.      * <p/>      * <pre>Validate.notNull(myObject, "The object must not be null");</pre>      *      * @param <T>     the object type      * @param object  the object to check      * @param message the {@link String#format(String, Object...)} exception message if invalid, not null      * @param values  the optional values for the formatted exception message      * @return the validated object (never {@code null} for method chaining)      * @throws NullPointerException if the object is {@code null}      */     public static <T> T notNull(T object, String message, Object... values) {         if (object == null) {             throw new IllegalArgumentException(String.format(message, values));         }         return object;     }      /**      * <p>Validate that the argument condition is {@code true}; otherwise      * throwing an exception with the specified message. This method is useful when      * validating according to an arbitrary boolean expression, such as validating a      * primitive number or using your own custom validation expression.</p>      * <p/>      * <pre>Validate.isTrue(i > 0.0, "The value must be greater than zero: %d", i);</pre>      * <p/>      * <p>For performance reasons, the long value is passed as a separate parameter and      * appended to the exception message only in the case of an error.</p>      *      * @param expression the boolean expression to check      * @param message      * @throws IllegalArgumentException if expression is {@code false}      */     public static void isTrue(boolean expression, String message) {         if (expression == false) {             throw new IllegalArgumentException(message);         }     }      /**      * <p>Validate that the specified argument character sequence is      * neither {@code null} nor a length of zero (no characters);      * otherwise throwing an exception with the specified message.      * <p/>      * <pre>Validate.notEmpty(myString, "The string must not be empty");</pre>      *      * @param <T>     the character sequence type      * @param chars   the character sequence to check, validated not null by this method      * @param message the {@link String#format(String, Object...)} exception message if invalid, not null      * @param values  the optional values for the formatted exception message, null array not recommended      * @return the validated character sequence (never {@code null} method for chaining)      * @throws NullPointerException     if the character sequence is {@code null}      * @throws IllegalArgumentException if the character sequence is empty      */     public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {         if (chars == null) {             throw new IllegalArgumentException(String.format(message, values));         }         if (chars.length() == 0) {             throw new IllegalArgumentException(String.format(message, values));         }         return chars;     }       //---------------------------------------------------------     //     // Converters     //     //---------------------------------------------------------     public static String toString(Object o) {         if (null == o) {             return null;         }          return o.toString();     }      //---------------------------------------------------------     //     // Serialization     //     //---------------------------------------------------------       /**      * <p>Serializes an {@code Object} to the specified stream.</p>      * <p/>      * <p>The stream will be closed once the object is written.      * This avoids the need for a finally clause, and maybe also exception      * handling, in the application code.</p>      * <p/>      * <p>The stream passed in is not buffered internally within this method.      * This is the responsibility of your application if desired.</p>      *      * @param obj          the object to serialize to bytes, may be null      * @param outputStream the stream to write to, must not be null      * @throws IllegalArgumentException if {@code outputStream} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static void serialize(Serializable obj, OutputStream outputStream) {         if (outputStream == null) {             throw new IllegalArgumentException("The OutputStream must not be null");         }         ObjectOutputStream out = null;         try {             // stream closed in the finally             out = new ObjectOutputStream(outputStream);             out.writeObject(obj);          } catch (IOException ex) {             throw new JsonPathException(ex);         } finally {             try {                 if (out != null) {                     out.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }      /**      * <p>Serializes an {@code Object} to a byte array for      * storage/serialization.</p>      *      * @param obj the object to serialize to bytes      * @return a byte[] with the converted Serializable      * @throws RuntimeException (runtime) if the serialization fails      */     public static byte[] serialize(Serializable obj) {         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);         serialize(obj, baos);         return baos.toByteArray();     }      // Deserialize     //-----------------------------------------------------------------------      /**      * <p>Deserializes an {@code Object} from the specified stream.</p>      * <p/>      * <p>The stream will be closed once the object is written. This      * avoids the need for a finally clause, and maybe also exception      * handling, in the application code.</p>      * <p/>      * <p>The stream passed in is not buffered internally within this method.      * This is the responsibility of your application if desired.</p>      *      * @param inputStream the serialized object input stream, must not be null      * @return the deserialized object      * @throws IllegalArgumentException if {@code inputStream} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static Object deserialize(InputStream inputStream) {         if (inputStream == null) {             throw new IllegalArgumentException("The InputStream must not be null");         }         ObjectInputStream in = null;         try {             // stream closed in the finally             in = new ObjectInputStream(inputStream);             return in.readObject();          } catch (ClassNotFoundException ex) {             throw new JsonPathException(ex);         } catch (IOException ex) {             throw new JsonPathException(ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }      /**      * <p>Deserializes a single {@code Object} from an array of bytes.</p>      *      * @param objectData the serialized object, must not be null      * @return the deserialized object      * @throws IllegalArgumentException if {@code objectData} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static Object deserialize(byte[] objectData) {         if (objectData == null) {             throw new IllegalArgumentException("The byte[] must not be null");         }         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);         return deserialize(bais);     }      /**      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}      * that uses a custom  <code>ClassLoader</code> to resolve a class.      * If the specified <code>ClassLoader</code> is not able to resolve the class,      * the context classloader of the current thread will be used.      * This way, the standard deserialization work also in web-application      * containers and application servers, no matter in which of the      * <code>ClassLoader</code> the particular class that encapsulates      * serialization/deserialization lives. </p>      * <p/>      * <p>For more in-depth information about the problem for which this      * class here is a workaround, see the JIRA issue LANG-626. </p>      */     static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {         private ClassLoader classLoader;          /**          * Constructor.          *          * @param in          The <code>InputStream</code>.          * @param classLoader classloader to use          * @throws IOException if an I/O error occurs while reading stream header.          * @see java.io.ObjectInputStream          */         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {             super(in);             this.classLoader = classLoader;         }          /**          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>          * of the current <code>Thread</code> to resolve the class.          *          * @param desc An instance of class <code>ObjectStreamClass</code>.          * @return A <code>Class</code> object corresponding to <code>desc</code>.          * @throws IOException            Any of the usual Input/Output exceptions.          * @throws ClassNotFoundException If class of a serialized object cannot be found.          */         @Override         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             }         }      }      private Utils () {} } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> json-path : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> jayway : Folder]
							[NT -> jsonpath : Folder]
								[NT -> internal : Folder]
									[NT -> Utils.java.merge : .java.merge-File]
										[T -> Utils.java : .java-Content "package com.jayway.jsonpath.internal;  import com.jayway.jsonpath.InvalidConversionException;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.Closeable; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamClass; import java.io.OutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.Iterator; import java.util.List;  public class Utils {      public static final String CR = System.getProperty("line.separator");      /**      * Creates a range of integers from start (inclusive) to end (exclusive)      *      * @param start      * @param end      * @return      */     public static List<Integer> createRange(int start, int end) {         List<Integer> range = new ArrayList<Integer>();         for (int i = start; i < end; i++) {             range.add(i);         }         return range;     }      // accept a collection of objects, since all objects have toString()     public static String join(String delimiter, String wrap, Iterable<? extends Object> objs) {         Iterator<? extends Object> iter = objs.iterator();         if (!iter.hasNext()) {             return "";         }          StringBuilder buffer = new StringBuilder();         buffer.append(wrap).append(iter.next()).append(wrap);         while (iter.hasNext()) {             buffer.append(delimiter).append(wrap).append(iter.next()).append(wrap);         }         return buffer.toString();     }      // accept a collection of objects, since all objects have toString()     public static String join(String delimiter, Iterable<? extends Object> objs) {         return join(delimiter, "", objs);     }      //---------------------------------------------------------     //     // IO     //     //---------------------------------------------------------      public static void closeQuietly(Closeable closeable) {         try {             if (closeable != null) {                 closeable.close();             }         } catch (IOException ignore) {         }     }      //---------------------------------------------------------     //     // Strings     //     //---------------------------------------------------------     public static boolean isInt(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false) {                 return false;             }         }         return true;     }      public static boolean isNumeric(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false && !(str.charAt(i) == '.')) {                 return false;             }         }         return true;     }      /**      * <p>Checks if a CharSequence is empty ("") or null.</p>      * <p/>      * <pre>      * StringUtils.isEmpty(null)      = true      * StringUtils.isEmpty("")        = true      * StringUtils.isEmpty(" ")       = false      * StringUtils.isEmpty("bob")     = false      * StringUtils.isEmpty("  bob  ") = false      * </pre>      * <p/>      * <p>NOTE: This method changed in Lang version 2.0.      * It no longer trims the CharSequence.      * That functionality is available in isBlank().</p>      *      * @param cs the CharSequence to check, may be null      * @return {@code true} if the CharSequence is empty or null      * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)      */     public static boolean isEmpty(CharSequence cs) {         return cs == null || cs.length() == 0;     }      /**      * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.      *      * @param cs         the {@code CharSequence} to be processed      * @param searchChar the {@code CharSequence} to be searched for      * @param start      the start index      * @return the index where the search sequence was found      */     static int indexOf(CharSequence cs, CharSequence searchChar, int start) {         return cs.toString().indexOf(searchChar.toString(), start);     }      /**      * <p>Counts how many times the substring appears in the larger string.</p>      * <p/>      * <p>A {@code null} or empty ("") String input returns {@code 0}.</p>      * <p/>      * <pre>      * StringUtils.countMatches(null, *)       = 0      * StringUtils.countMatches("", *)         = 0      * StringUtils.countMatches("abba", null)  = 0      * StringUtils.countMatches("abba", "")    = 0      * StringUtils.countMatches("abba", "a")   = 2      * StringUtils.countMatches("abba", "ab")  = 1      * StringUtils.countMatches("abba", "xxx") = 0      * </pre>      *      * @param str the CharSequence to check, may be null      * @param sub the substring to count, may be null      * @return the number of occurrences, 0 if either CharSequence is {@code null}      * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)      */     public static int countMatches(CharSequence str, CharSequence sub) {         if (isEmpty(str) || isEmpty(sub)) {             return 0;         }         int count = 0;         int idx = 0;         while ((idx = indexOf(str, sub, idx)) != -1) {             count++;             idx += sub.length();         }         return count;     }      //---------------------------------------------------------     //     // Validators     //     //---------------------------------------------------------      /**      * <p>Validate that the specified argument is not {@code null};      * otherwise throwing an exception with the specified message.      * <p/>      * <pre>Validate.notNull(myObject, "The object must not be null");</pre>      *      * @param <T>     the object type      * @param object  the object to check      * @param message the {@link String#format(String, Object...)} exception message if invalid, not null      * @param values  the optional values for the formatted exception message      * @return the validated object (never {@code null} for method chaining)      * @throws NullPointerException if the object is {@code null}      */     public static <T> T notNull(T object, String message, Object... values) {         if (object == null) {             throw new IllegalArgumentException(String.format(message, values));         }         return object;     }      /**      * <p>Validate that the argument condition is {@code true}; otherwise      * throwing an exception with the specified message. This method is useful when      * validating according to an arbitrary boolean expression, such as validating a      * primitive number or using your own custom validation expression.</p>      * <p/>      * <pre>Validate.isTrue(i > 0.0, "The value must be greater than zero: %d", i);</pre>      * <p/>      * <p>For performance reasons, the long value is passed as a separate parameter and      * appended to the exception message only in the case of an error.</p>      *      * @param expression the boolean expression to check      * @param message      * @throws IllegalArgumentException if expression is {@code false}      */     public static void isTrue(boolean expression, String message) {         if (expression == false) {             throw new IllegalArgumentException(message);         }     }      /**      * <p>Validate that the specified argument character sequence is      * neither {@code null} nor a length of zero (no characters);      * otherwise throwing an exception with the specified message.      * <p/>      * <pre>Validate.notEmpty(myString, "The string must not be empty");</pre>      *      * @param <T>     the character sequence type      * @param chars   the character sequence to check, validated not null by this method      * @param message the {@link String#format(String, Object...)} exception message if invalid, not null      * @param values  the optional values for the formatted exception message, null array not recommended      * @return the validated character sequence (never {@code null} method for chaining)      * @throws NullPointerException     if the character sequence is {@code null}      * @throws IllegalArgumentException if the character sequence is empty      */     public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {         if (chars == null) {             throw new IllegalArgumentException(String.format(message, values));         }         if (chars.length() == 0) {             throw new IllegalArgumentException(String.format(message, values));         }         return chars;     }       //---------------------------------------------------------     //     // Converters     //     //---------------------------------------------------------     public static String toString(Object o) {         if (null == o) {             return null;         }          return o.toString();     }      //---------------------------------------------------------     //     // Serialization     //     //---------------------------------------------------------      /**      * <p>Deep clone an {@code Object} using serialization.</p>      * <p/>      * <p>This is many times slower than writing clone methods by hand      * on all objects in your object graph. However, for complex object      * graphs, or for those that don't support deep cloning this can      * be a simple alternative implementation. Of course all the objects      * must be {@code Serializable}.</p>      *      * @param <T>    the type of the object involved      * @param object the {@code Serializable} object to clone      * @return the cloned object      */     public static <T extends Serializable> T clone(T object) {         if (object == null) {             return null;         }         byte[] objectData = serialize(object);         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);          ClassLoaderAwareObjectInputStream in = null;         try {             // stream closed in the finally             in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());             /*              * when we serialize and deserialize an object,              * it is reasonable to assume the deserialized object              * is of the same type as the original serialized object              */             @SuppressWarnings("unchecked") // see above                     T readObject = (T) in.readObject();             return readObject;          } catch (ClassNotFoundException ex) {             throw new RuntimeException("ClassNotFoundException while reading cloned object data", ex);         } catch (IOException ex) {             throw new RuntimeException("IOException while reading cloned object data", ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) {                 throw new RuntimeException("IOException on closing cloned object data InputStream.", ex);             }         }     }       /**      * <p>Serializes an {@code Object} to the specified stream.</p>      * <p/>      * <p>The stream will be closed once the object is written.      * This avoids the need for a finally clause, and maybe also exception      * handling, in the application code.</p>      * <p/>      * <p>The stream passed in is not buffered internally within this method.      * This is the responsibility of your application if desired.</p>      *      * @param obj          the object to serialize to bytes, may be null      * @param outputStream the stream to write to, must not be null      * @throws IllegalArgumentException if {@code outputStream} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static void serialize(Serializable obj, OutputStream outputStream) {         if (outputStream == null) {             throw new IllegalArgumentException("The OutputStream must not be null");         }         ObjectOutputStream out = null;         try {             // stream closed in the finally             out = new ObjectOutputStream(outputStream);             out.writeObject(obj);          } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (out != null) {                     out.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }      /**      * <p>Serializes an {@code Object} to a byte array for      * storage/serialization.</p>      *      * @param obj the object to serialize to bytes      * @return a byte[] with the converted Serializable      * @throws RuntimeException (runtime) if the serialization fails      */     public static byte[] serialize(Serializable obj) {         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);         serialize(obj, baos);         return baos.toByteArray();     }      // Deserialize     //-----------------------------------------------------------------------      /**      * <p>Deserializes an {@code Object} from the specified stream.</p>      * <p/>      * <p>The stream will be closed once the object is written. This      * avoids the need for a finally clause, and maybe also exception      * handling, in the application code.</p>      * <p/>      * <p>The stream passed in is not buffered internally within this method.      * This is the responsibility of your application if desired.</p>      *      * @param inputStream the serialized object input stream, must not be null      * @return the deserialized object      * @throws IllegalArgumentException if {@code inputStream} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static Object deserialize(InputStream inputStream) {         if (inputStream == null) {             throw new IllegalArgumentException("The InputStream must not be null");         }         ObjectInputStream in = null;         try {             // stream closed in the finally             in = new ObjectInputStream(inputStream);             return in.readObject();          } catch (ClassNotFoundException ex) {             throw new RuntimeException(ex);         } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }      /**      * <p>Deserializes a single {@code Object} from an array of bytes.</p>      *      * @param objectData the serialized object, must not be null      * @return the deserialized object      * @throws IllegalArgumentException if {@code objectData} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static Object deserialize(byte[] objectData) {         if (objectData == null) {             throw new IllegalArgumentException("The byte[] must not be null");         }         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);         return deserialize(bais);     }      /**      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}      * that uses a custom  <code>ClassLoader</code> to resolve a class.      * If the specified <code>ClassLoader</code> is not able to resolve the class,      * the context classloader of the current thread will be used.      * This way, the standard deserialization work also in web-application      * containers and application servers, no matter in which of the      * <code>ClassLoader</code> the particular class that encapsulates      * serialization/deserialization lives. </p>      * <p/>      * <p>For more in-depth information about the problem for which this      * class here is a workaround, see the JIRA issue LANG-626. </p>      */     static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {         private ClassLoader classLoader;          /**          * Constructor.          *          * @param in          The <code>InputStream</code>.          * @param classLoader classloader to use          * @throws IOException if an I/O error occurs while reading stream header.          * @see java.io.ObjectInputStream          */         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {             super(in);             this.classLoader = classLoader;         }          /**          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>          * of the current <code>Thread</code> to resolve the class.          *          * @param desc An instance of class <code>ObjectStreamClass</code>.          * @return A <code>Class</code> object corresponding to <code>desc</code>.          * @throws IOException            Any of the usual Input/Output exceptions.          * @throws ClassNotFoundException If class of a serialized object cannot be found.          */         @Override         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             }         }      } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> json-path : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> jayway : Folder]
							[NT -> jsonpath : Folder]
								[NT -> internal : Folder]
									[NT -> Utils.java.merge : .java.merge-File]
										[T -> Utils.java : .java-Content "package com.jayway.jsonpath.internal;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.Closeable; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamClass; import java.io.OutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.Iterator; import java.util.List;  public class Utils {      public static final String CR = System.getProperty("line.separator");      /**      * Creates a range of integers from start (inclusive) to end (exclusive)      *      * @param start      * @param end      * @return      */     public static List<Integer> createRange(int start, int end) {         List<Integer> range = new ArrayList<Integer>();         for (int i = start; i < end; i++) {             range.add(i);         }         return range;     }      // accept a collection of objects, since all objects have toString()     public static String join(String delimiter, String wrap, Iterable<? extends Object> objs) {         Iterator<? extends Object> iter = objs.iterator();         if (!iter.hasNext()) {             return "";         }          StringBuilder buffer = new StringBuilder();         buffer.append(wrap).append(iter.next()).append(wrap);         while (iter.hasNext()) {             buffer.append(delimiter).append(wrap).append(iter.next()).append(wrap);         }         return buffer.toString();     }      // accept a collection of objects, since all objects have toString()     public static String join(String delimiter, Iterable<? extends Object> objs) {         return join(delimiter, "", objs);     }      //---------------------------------------------------------     //     // IO     //     //---------------------------------------------------------      public static void closeQuietly(Closeable closeable) {         try {             if (closeable != null) {                 closeable.close();             }         } catch (IOException ignore) {         }     }      //---------------------------------------------------------     //     // Strings     //     //---------------------------------------------------------     public static boolean isInt(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false) {                 return false;             }         }         return true;     }      public static boolean isNumeric(String str) {         if (str == null) {             return false;         }         int sz = str.length();         for (int i = 0; i < sz; i++) {             if (Character.isDigit(str.charAt(i)) == false && !(str.charAt(i) == '.')) {                 return false;             }         }         return true;     }      /**      * <p>Checks if a CharSequence is empty ("") or null.</p>      * <p/>      * <pre>      * StringUtils.isEmpty(null)      = true      * StringUtils.isEmpty("")        = true      * StringUtils.isEmpty(" ")       = false      * StringUtils.isEmpty("bob")     = false      * StringUtils.isEmpty("  bob  ") = false      * </pre>      * <p/>      * <p>NOTE: This method changed in Lang version 2.0.      * It no longer trims the CharSequence.      * That functionality is available in isBlank().</p>      *      * @param cs the CharSequence to check, may be null      * @return {@code true} if the CharSequence is empty or null      * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)      */     public static boolean isEmpty(CharSequence cs) {         return cs == null || cs.length() == 0;     }      /**      * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.      *      * @param cs         the {@code CharSequence} to be processed      * @param searchChar the {@code CharSequence} to be searched for      * @param start      the start index      * @return the index where the search sequence was found      */     static int indexOf(CharSequence cs, CharSequence searchChar, int start) {         return cs.toString().indexOf(searchChar.toString(), start);     }      /**      * <p>Counts how many times the substring appears in the larger string.</p>      * <p/>      * <p>A {@code null} or empty ("") String input returns {@code 0}.</p>      * <p/>      * <pre>      * StringUtils.countMatches(null, *)       = 0      * StringUtils.countMatches("", *)         = 0      * StringUtils.countMatches("abba", null)  = 0      * StringUtils.countMatches("abba", "")    = 0      * StringUtils.countMatches("abba", "a")   = 2      * StringUtils.countMatches("abba", "ab")  = 1      * StringUtils.countMatches("abba", "xxx") = 0      * </pre>      *      * @param str the CharSequence to check, may be null      * @param sub the substring to count, may be null      * @return the number of occurrences, 0 if either CharSequence is {@code null}      * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)      */     public static int countMatches(CharSequence str, CharSequence sub) {         if (isEmpty(str) || isEmpty(sub)) {             return 0;         }         int count = 0;         int idx = 0;         while ((idx = indexOf(str, sub, idx)) != -1) {             count++;             idx += sub.length();         }         return count;     }      //---------------------------------------------------------     //     // Validators     //     //---------------------------------------------------------      /**      * <p>Validate that the specified argument is not {@code null};      * otherwise throwing an exception with the specified message.      * <p/>      * <pre>Validate.notNull(myObject, "The object must not be null");</pre>      *      * @param <T>     the object type      * @param object  the object to check      * @param message the {@link String#format(String, Object...)} exception message if invalid, not null      * @param values  the optional values for the formatted exception message      * @return the validated object (never {@code null} for method chaining)      * @throws NullPointerException if the object is {@code null}      */     public static <T> T notNull(T object, String message, Object... values) {         if (object == null) {             throw new IllegalArgumentException(String.format(message, values));         }         return object;     }      /**      * <p>Validate that the argument condition is {@code true}; otherwise      * throwing an exception with the specified message. This method is useful when      * validating according to an arbitrary boolean expression, such as validating a      * primitive number or using your own custom validation expression.</p>      * <p/>      * <pre>Validate.isTrue(i > 0.0, "The value must be greater than zero: %d", i);</pre>      * <p/>      * <p>For performance reasons, the long value is passed as a separate parameter and      * appended to the exception message only in the case of an error.</p>      *      * @param expression the boolean expression to check      * @param message      * @throws IllegalArgumentException if expression is {@code false}      */     public static void isTrue(boolean expression, String message) {         if (expression == false) {             throw new IllegalArgumentException(message);         }     }      /**      * <p>Validate that the specified argument character sequence is      * neither {@code null} nor a length of zero (no characters);      * otherwise throwing an exception with the specified message.      * <p/>      * <pre>Validate.notEmpty(myString, "The string must not be empty");</pre>      *      * @param <T>     the character sequence type      * @param chars   the character sequence to check, validated not null by this method      * @param message the {@link String#format(String, Object...)} exception message if invalid, not null      * @param values  the optional values for the formatted exception message, null array not recommended      * @return the validated character sequence (never {@code null} method for chaining)      * @throws NullPointerException     if the character sequence is {@code null}      * @throws IllegalArgumentException if the character sequence is empty      */     public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {         if (chars == null) {             throw new IllegalArgumentException(String.format(message, values));         }         if (chars.length() == 0) {             throw new IllegalArgumentException(String.format(message, values));         }         return chars;     }       //---------------------------------------------------------     //     // Converters     //     //---------------------------------------------------------     public static String toString(Object o) {         if (null == o) {             return null;         }          return o.toString();     }      //---------------------------------------------------------     //     // Serialization     //     //---------------------------------------------------------      /**      * <p>Deep clone an {@code Object} using serialization.</p>      * <p/>      * <p>This is many times slower than writing clone methods by hand      * on all objects in your object graph. However, for complex object      * graphs, or for those that don't support deep cloning this can      * be a simple alternative implementation. Of course all the objects      * must be {@code Serializable}.</p>      *      * @param <T>    the type of the object involved      * @param object the {@code Serializable} object to clone      * @return the cloned object      */     public static <T extends Serializable> T clone(T object) {         if (object == null) {             return null;         }         byte[] objectData = serialize(object);         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);          ClassLoaderAwareObjectInputStream in = null;         try {             // stream closed in the finally             in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());             /*              * when we serialize and deserialize an object,              * it is reasonable to assume the deserialized object              * is of the same type as the original serialized object              */             @SuppressWarnings("unchecked") // see above                     T readObject = (T) in.readObject();             return readObject;          } catch (ClassNotFoundException ex) {             throw new RuntimeException("ClassNotFoundException while reading cloned object data", ex);         } catch (IOException ex) {             throw new RuntimeException("IOException while reading cloned object data", ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) {                 throw new RuntimeException("IOException on closing cloned object data InputStream.", ex);             }         }     }       /**      * <p>Serializes an {@code Object} to the specified stream.</p>      * <p/>      * <p>The stream will be closed once the object is written.      * This avoids the need for a finally clause, and maybe also exception      * handling, in the application code.</p>      * <p/>      * <p>The stream passed in is not buffered internally within this method.      * This is the responsibility of your application if desired.</p>      *      * @param obj          the object to serialize to bytes, may be null      * @param outputStream the stream to write to, must not be null      * @throws IllegalArgumentException if {@code outputStream} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static void serialize(Serializable obj, OutputStream outputStream) {         if (outputStream == null) {             throw new IllegalArgumentException("The OutputStream must not be null");         }         ObjectOutputStream out = null;         try {             // stream closed in the finally             out = new ObjectOutputStream(outputStream);             out.writeObject(obj);          } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (out != null) {                     out.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }      /**      * <p>Serializes an {@code Object} to a byte array for      * storage/serialization.</p>      *      * @param obj the object to serialize to bytes      * @return a byte[] with the converted Serializable      * @throws RuntimeException (runtime) if the serialization fails      */     public static byte[] serialize(Serializable obj) {         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);         serialize(obj, baos);         return baos.toByteArray();     }      // Deserialize     //-----------------------------------------------------------------------      /**      * <p>Deserializes an {@code Object} from the specified stream.</p>      * <p/>      * <p>The stream will be closed once the object is written. This      * avoids the need for a finally clause, and maybe also exception      * handling, in the application code.</p>      * <p/>      * <p>The stream passed in is not buffered internally within this method.      * This is the responsibility of your application if desired.</p>      *      * @param inputStream the serialized object input stream, must not be null      * @return the deserialized object      * @throws IllegalArgumentException if {@code inputStream} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static Object deserialize(InputStream inputStream) {         if (inputStream == null) {             throw new IllegalArgumentException("The InputStream must not be null");         }         ObjectInputStream in = null;         try {             // stream closed in the finally             in = new ObjectInputStream(inputStream);             return in.readObject();          } catch (ClassNotFoundException ex) {             throw new RuntimeException(ex);         } catch (IOException ex) {             throw new RuntimeException(ex);         } finally {             try {                 if (in != null) {                     in.close();                 }             } catch (IOException ex) { // NOPMD                 // ignore close exception             }         }     }      /**      * <p>Deserializes a single {@code Object} from an array of bytes.</p>      *      * @param objectData the serialized object, must not be null      * @return the deserialized object      * @throws IllegalArgumentException if {@code objectData} is {@code null}      * @throws RuntimeException         (runtime) if the serialization fails      */     public static Object deserialize(byte[] objectData) {         if (objectData == null) {             throw new IllegalArgumentException("The byte[] must not be null");         }         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);         return deserialize(bais);     }      /**      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}      * that uses a custom  <code>ClassLoader</code> to resolve a class.      * If the specified <code>ClassLoader</code> is not able to resolve the class,      * the context classloader of the current thread will be used.      * This way, the standard deserialization work also in web-application      * containers and application servers, no matter in which of the      * <code>ClassLoader</code> the particular class that encapsulates      * serialization/deserialization lives. </p>      * <p/>      * <p>For more in-depth information about the problem for which this      * class here is a workaround, see the JIRA issue LANG-626. </p>      */     static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {         private ClassLoader classLoader;          /**          * Constructor.          *          * @param in          The <code>InputStream</code>.          * @param classLoader classloader to use          * @throws IOException if an I/O error occurs while reading stream header.          * @see java.io.ObjectInputStream          */         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {             super(in);             this.classLoader = classLoader;         }          /**          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>          * of the current <code>Thread</code> to resolve the class.          *          * @param desc An instance of class <code>ObjectStreamClass</code>.          * @return A <code>Class</code> object corresponding to <code>desc</code>.          * @throws IOException            Any of the usual Input/Output exceptions.          * @throws ClassNotFoundException If class of a serialized object cannot be found.          */         @Override         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             }         }      } } " compose:StringConcatenation merge: LineBased]
