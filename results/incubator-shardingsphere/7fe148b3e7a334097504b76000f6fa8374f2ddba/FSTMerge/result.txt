Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/sharding-proxy/src/main/java/io/shardingsphere/proxy/config/RuleRegistry.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/sharding-proxy/src/main/java/io/shardingsphere/proxy/config/RuleRegistry.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/sharding-proxy/src/main/java/io/shardingsphere/proxy/config/RuleRegistry.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/sharding-proxy/src/main/java/io/shardingsphere/proxy/config/RuleRegistry.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/sharding-proxy/src/main/java/io/shardingsphere/proxy/config/RuleRegistry.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/sharding-proxy/src/main/java/io/shardingsphere/proxy/config/RuleRegistry.java
[NT -> left : Feature]
	[NT -> sharding-proxy : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> io : Folder]
						[NT -> shardingsphere : Folder]
							[NT -> proxy : Folder]
								[NT -> config : Folder]
									[NT -> RuleRegistry.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package io.shardingsphere.proxy.config;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.constant.ShardingProperties{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.constant.ShardingProperties;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.constant.ShardingPropertiesConstant{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.constant.ShardingPropertiesConstant;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.constant.TransactionType{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.constant.TransactionType;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.exception.ShardingException{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.exception.ShardingException;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.metadata.ShardingMetaData{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.metadata.ShardingMetaData;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.rule.MasterSlaveRule{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.rule.MasterSlaveRule;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.rule.ShardingRule{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.rule.ShardingRule;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.core.yaml.proxy.YamlProxyConfiguration{ImportPackage} : ImportDeclaration "import io.shardingsphere.core.yaml.proxy.YamlProxyConfiguration;" compose:Replacement merge: Default]
											[T -> io.shardingsphere.proxy.metadata.ProxyShardingMetaData{ImportPackage} : ImportDeclaration "import io.shardingsphere.proxy.metadata.ProxyShardingMetaData;" compose:Replacement merge: Default]
											[T -> lombok.Getter{ImportPackage} : ImportDeclaration "import lombok.Getter;" compose:Replacement merge: Default]
											[T -> javax.sql.DataSource{ImportPackage} : ImportDeclaration "import javax.sql.DataSource;" compose:Replacement merge: Default]
											[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
											[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
											[T -> java.sql.SQLException{ImportPackage} : ImportDeclaration "import java.sql.SQLException;" compose:Replacement merge: Default]
											[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.Properties{ImportPackage} : ImportDeclaration "import java.util.Properties;" compose:Replacement merge: Default]
											[T -> java.util.concurrent.ExecutorService{ImportPackage} : ImportDeclaration "import java.util.concurrent.ExecutorService;" compose:Replacement merge: Default]
											[T -> java.util.concurrent.Executors{ImportPackage} : ImportDeclaration "import java.util.concurrent.Executors;" compose:Replacement merge: Default]
											[NT -> RuleRegistry : ClassDeclaration]
												[T -> - : Modifiers "@Getter public final" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> RuleRegistry : Id "RuleRegistry" compose:Replacement merge: Default]
												[T -> MAX_EXECUTOR_THREADS : FieldDecl "private static final int MAX_EXECUTOR_THREADS = Runtime.getRuntime().availableProcessors() * 2;" compose:Replacement merge: SemanticConflict]
												[T -> INSTANCE : FieldDecl "private static final RuleRegistry INSTANCE = new RuleRegistry();" compose:Replacement merge: SemanticConflict]
												[T -> dataSourceMap : FieldDecl "private final Map<String, DataSource> dataSourceMap;" compose:Replacement merge: SemanticConflict]
												[T -> shardingRule : FieldDecl "private final ShardingRule shardingRule;" compose:Replacement merge: SemanticConflict]
												[T -> masterSlaveRule : FieldDecl "private final MasterSlaveRule masterSlaveRule;" compose:Replacement merge: SemanticConflict]
												[T -> shardingMetaData : FieldDecl "private final ShardingMetaData shardingMetaData;" compose:Replacement merge: SemanticConflict]
												[T -> isOnlyMasterSlave : FieldDecl "private final boolean isOnlyMasterSlave;" compose:Replacement merge: SemanticConflict]
												[T -> executorService : FieldDecl "private final ExecutorService executorService = Executors.newFixedThreadPool(MAX_EXECUTOR_THREADS);" compose:Replacement merge: SemanticConflict]
												[T -> proxyMode : FieldDecl "private final String proxyMode;" compose:Replacement merge: SemanticConflict]
												[T -> showSQL : FieldDecl "private final boolean showSQL;" compose:Replacement merge: SemanticConflict]
												[T -> transactionType : FieldDecl "private final TransactionType transactionType;" compose:Replacement merge: SemanticConflict]
												[T -> RuleRegistry({FormalParametersInternal}) : ConstructorDecl "private RuleRegistry() {         YamlProxyConfiguration yamlProxyConfiguration;         try {             yamlProxyConfiguration = YamlProxyConfiguration.unmarshal(new File(getClass().getResource("/conf/config.yaml").getFile()));         } catch (final IOException ex) {             throw new ShardingException(ex);         }         transactionType = TransactionType.findByValue(yamlProxyConfiguration.getTransactionMode());         dataSourceMap = ProxyRawDataSourceFactory.create(transactionType, yamlProxyConfiguration);         shardingRule = yamlProxyConfiguration.obtainShardingRule(Collections.<String>emptyList());         masterSlaveRule = yamlProxyConfiguration.obtainMasterSlaveRule();         isOnlyMasterSlave = shardingRule.getTableRules().isEmpty() && !masterSlaveRule.getMasterDataSourceName().isEmpty();         Properties properties = yamlProxyConfiguration.getShardingRule().getProps();         ShardingProperties shardingProperties = new ShardingProperties(null == properties ? new Properties() : properties);         proxyMode = shardingProperties.getValue(ShardingPropertiesConstant.PROXY_MODE);         showSQL = shardingProperties.getValue(ShardingPropertiesConstant.SQL_SHOW);         try {             shardingMetaData = new ProxyShardingMetaData(dataSourceMap);             if (!isOnlyMasterSlave) {                 shardingMetaData.init(shardingRule);             }         } catch (final SQLException ex) {             throw new ShardingException(ex);         }     }" compose:Replacement merge: LineBased]
												[T -> getInstance({FormalParametersInternal}) : MethodDecl "public static RuleRegistry getInstance() {         return INSTANCE;     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> sharding-proxy : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> io : Folder]
						[NT -> shardingsphere : Folder]
							[NT -> proxy : Folder]
								[NT -> config : Folder]
									[NT -> RuleRegistry.java : Java-File]
[NT -> right : Feature]
	[NT -> sharding-proxy : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> io : Folder]
						[NT -> shardingsphere : Folder]
							[NT -> proxy : Folder]
								[NT -> config : Folder]
									[NT -> RuleRegistry.java : Java-File]
[NT -> left : Feature]
	[NT -> sharding-proxy : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> io : Folder]
						[NT -> shardingsphere : Folder]
							[NT -> proxy : Folder]
								[NT -> config : Folder]
									[NT -> RuleRegistry.java.merge : .java.merge-File]
										[T -> RuleRegistry.java : .java-Content "/*  * Copyright 2016-2018 shardingsphere.io.  * <p>  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  * </p>  */  package io.shardingsphere.proxy.config;  import io.shardingsphere.core.constant.ShardingProperties; import io.shardingsphere.core.constant.ShardingPropertiesConstant; import io.shardingsphere.core.constant.TransactionType; import io.shardingsphere.core.exception.ShardingException; import io.shardingsphere.core.metadata.ShardingMetaData; import io.shardingsphere.core.rule.MasterSlaveRule; import io.shardingsphere.core.rule.ShardingRule; import io.shardingsphere.core.yaml.proxy.YamlProxyConfiguration; import io.shardingsphere.proxy.metadata.ProxyShardingMetaData; import lombok.Getter;  import javax.sql.DataSource; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.Collections; import java.util.Map; import java.util.Properties; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  /**  * Sharding rule registry.  *  * @author zhangliang  * @author zhangyonglun  * @author panjuan  * @author zhaojun  */ @Getter public final class RuleRegistry {          private static final int MAX_EXECUTOR_THREADS = Runtime.getRuntime().availableProcessors() * 2;          private static final RuleRegistry INSTANCE = new RuleRegistry();          private final Map<String, DataSource> dataSourceMap;          private final ShardingRule shardingRule;          private final MasterSlaveRule masterSlaveRule;          private final ShardingMetaData shardingMetaData;          private final boolean isOnlyMasterSlave;          private final ExecutorService executorService = Executors.newFixedThreadPool(MAX_EXECUTOR_THREADS);          private final String proxyMode;          private final boolean showSQL;          private final TransactionType transactionType;          private RuleRegistry() {         YamlProxyConfiguration yamlProxyConfiguration;         try {             yamlProxyConfiguration = YamlProxyConfiguration.unmarshal(new File(getClass().getResource("/conf/config.yaml").getFile()));         } catch (final IOException ex) {             throw new ShardingException(ex);         }         transactionType = TransactionType.findByValue(yamlProxyConfiguration.getTransactionMode());         dataSourceMap = ProxyRawDataSourceFactory.create(transactionType, yamlProxyConfiguration);         shardingRule = yamlProxyConfiguration.obtainShardingRule(Collections.<String>emptyList());         masterSlaveRule = yamlProxyConfiguration.obtainMasterSlaveRule();         isOnlyMasterSlave = shardingRule.getTableRules().isEmpty() && !masterSlaveRule.getMasterDataSourceName().isEmpty();         Properties properties = yamlProxyConfiguration.getShardingRule().getProps();         ShardingProperties shardingProperties = new ShardingProperties(null == properties ? new Properties() : properties);         proxyMode = shardingProperties.getValue(ShardingPropertiesConstant.PROXY_MODE);         showSQL = shardingProperties.getValue(ShardingPropertiesConstant.SQL_SHOW);         try {             shardingMetaData = new ProxyShardingMetaData(dataSourceMap);             if (!isOnlyMasterSlave) {                 shardingMetaData.init(shardingRule);             }         } catch (final SQLException ex) {             throw new ShardingException(ex);         }     }          /**      * Get instance of sharding rule registry.      *      * @return instance of sharding rule registry      */     public static RuleRegistry getInstance() {         return INSTANCE;     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> sharding-proxy : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> io : Folder]
						[NT -> shardingsphere : Folder]
							[NT -> proxy : Folder]
								[NT -> config : Folder]
									[NT -> RuleRegistry.java.merge : .java.merge-File]
										[T -> RuleRegistry.java : .java-Content "/*  * Copyright 2016-2018 shardingsphere.io.  * <p>  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  * </p>  */  package io.shardingsphere.proxy.config;  import com.zaxxer.hikari.HikariConfig; import com.zaxxer.hikari.HikariDataSource; import io.shardingsphere.core.constant.ShardingProperties; import io.shardingsphere.core.constant.ShardingPropertiesConstant; import io.shardingsphere.core.exception.ShardingException; import io.shardingsphere.core.metadata.ShardingMetaData; import io.shardingsphere.core.rule.MasterSlaveRule; import io.shardingsphere.core.rule.ShardingRule; import io.shardingsphere.core.yaml.proxy.YamlProxyConfiguration; import io.shardingsphere.core.yaml.sharding.DataSourceParameter; import io.shardingsphere.proxy.metadata.ProxyShardingMetaData; import lombok.Getter;  import javax.sql.DataSource; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.Collections; import java.util.HashMap; import java.util.Map; import java.util.Properties; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  /**  * Sharding rule registry.  *  * @author zhangliang  * @author zhangyonglun  * @author panjuan  */ @Getter public final class RuleRegistry {          private static final int MAX_EXECUTOR_THREADS = Runtime.getRuntime().availableProcessors() * 2;          private static final RuleRegistry INSTANCE = new RuleRegistry();          private final Map<String, DataSource> dataSourceMap;          private final ShardingRule shardingRule;          private final MasterSlaveRule masterSlaveRule;          private final ShardingMetaData shardingMetaData;          private final boolean isOnlyMasterSlave;          private final ExecutorService executorService = Executors.newFixedThreadPool(MAX_EXECUTOR_THREADS);          private final String proxyMode;          private final boolean showSQL;          private RuleRegistry() {         YamlProxyConfiguration yamlProxyConfiguration;         try {             yamlProxyConfiguration = YamlProxyConfiguration.unmarshal(new File(getClass().getResource("/conf/config.yaml").getFile()));         } catch (final IOException ex) {             throw new ShardingException(ex);         }         dataSourceMap = new HashMap<>(128, 1);         Map<String, DataSourceParameter> dataSourceParameters = yamlProxyConfiguration.getDataSources();         for (Map.Entry<String, DataSourceParameter> entry : dataSourceParameters.entrySet()) {             dataSourceMap.put(entry.getKey(), getDataSource(entry.getValue()));         }         shardingRule = yamlProxyConfiguration.obtainShardingRule(Collections.<String>emptyList());         masterSlaveRule = yamlProxyConfiguration.obtainMasterSlaveRule();         isOnlyMasterSlave = shardingRule.getTableRules().isEmpty() && !masterSlaveRule.getMasterDataSourceName().isEmpty();         Properties properties = yamlProxyConfiguration.getShardingRule().getProps();         ShardingProperties shardingProperties = new ShardingProperties(null == properties ? new Properties() : properties);         proxyMode = shardingProperties.getValue(ShardingPropertiesConstant.PROXY_MODE);         showSQL = shardingProperties.getValue(ShardingPropertiesConstant.SQL_SHOW);         try {             shardingMetaData = new ProxyShardingMetaData(dataSourceMap);             if (!isOnlyMasterSlave) {                 shardingMetaData.init(shardingRule);             }         } catch (final SQLException ex) {             throw new ShardingException(ex);         }     }          private DataSource getDataSource(final DataSourceParameter dataSourceParameter) {         HikariConfig config = new HikariConfig();         config.setDriverClassName("com.mysql.jdbc.Driver");         config.setJdbcUrl(dataSourceParameter.getUrl());         config.setUsername(dataSourceParameter.getUsername());         config.setPassword(dataSourceParameter.getPassword());         config.setAutoCommit(dataSourceParameter.getAutoCommit());         config.setConnectionTimeout(dataSourceParameter.getConnectionTimeout());         config.setIdleTimeout(dataSourceParameter.getIdleTimeout());         config.setMaxLifetime(dataSourceParameter.getMaxLifetime());         config.setMaximumPoolSize(dataSourceParameter.getMaximumPoolSize());         config.addDataSourceProperty("useServerPrepStmts", "true");         config.addDataSourceProperty("cachePrepStmts", "true");         return new HikariDataSource(config);     }          /**      * Get instance of sharding rule registry.      *      * @return instance of sharding rule registry      */     public static RuleRegistry getInstance() {         return INSTANCE;     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> sharding-proxy : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> io : Folder]
						[NT -> shardingsphere : Folder]
							[NT -> proxy : Folder]
								[NT -> config : Folder]
									[NT -> RuleRegistry.java.merge : .java.merge-File]
										[T -> RuleRegistry.java : .java-Content "/*  * Copyright 2016-2018 shardingsphere.io.  * <p>  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  * </p>  */  package io.shardingsphere.proxy.config;  import com.google.common.util.concurrent.ListeningExecutorService; import com.google.common.util.concurrent.MoreExecutors; import com.zaxxer.hikari.HikariConfig; import com.zaxxer.hikari.HikariDataSource; import io.shardingsphere.core.constant.ShardingProperties; import io.shardingsphere.core.constant.ShardingPropertiesConstant; import io.shardingsphere.core.exception.ShardingException; import io.shardingsphere.core.metadata.ShardingMetaData; import io.shardingsphere.core.rule.MasterSlaveRule; import io.shardingsphere.core.rule.ShardingRule; import io.shardingsphere.core.yaml.proxy.YamlProxyConfiguration; import io.shardingsphere.core.yaml.sharding.DataSourceParameter; import io.shardingsphere.proxy.metadata.ProxyShardingMetaData; import lombok.Getter;  import javax.sql.DataSource; import java.io.File; import java.io.IOException; import java.util.Collections; import java.util.HashMap; import java.util.Map; import java.util.Properties; import java.util.concurrent.Executors;  /**  * Sharding rule registry.  *  * @author zhangliang  * @author zhangyonglun  * @author panjuan  */ @Getter public final class RuleRegistry {          private static final int MAX_EXECUTOR_THREADS = Runtime.getRuntime().availableProcessors() * 2;          private static final RuleRegistry INSTANCE = new RuleRegistry();          private final Map<String, DataSource> dataSourceMap;          private final ShardingRule shardingRule;          private final MasterSlaveRule masterSlaveRule;          private final ShardingMetaData shardingMetaData;          private final boolean isOnlyMasterSlave;          private final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(MAX_EXECUTOR_THREADS));          private final String proxyMode;          private final boolean showSQL;          private RuleRegistry() {         YamlProxyConfiguration yamlProxyConfiguration;         try {             yamlProxyConfiguration = YamlProxyConfiguration.unmarshal(new File(getClass().getResource("/conf/config.yaml").getFile()));         } catch (final IOException ex) {             throw new ShardingException(ex);         }         dataSourceMap = new HashMap<>(128, 1);         Map<String, DataSourceParameter> dataSourceParameters = yamlProxyConfiguration.getDataSources();         for (Map.Entry<String, DataSourceParameter> entry : dataSourceParameters.entrySet()) {             dataSourceMap.put(entry.getKey(), getDataSource(entry.getValue()));         }         shardingRule = yamlProxyConfiguration.obtainShardingRule(Collections.<String>emptyList());         masterSlaveRule = yamlProxyConfiguration.obtainMasterSlaveRule();         isOnlyMasterSlave = shardingRule.getTableRules().isEmpty() && !masterSlaveRule.getMasterDataSourceName().isEmpty();         Properties properties = yamlProxyConfiguration.getShardingRule().getProps();         ShardingProperties shardingProperties = new ShardingProperties(null == properties ? new Properties() : properties);         proxyMode = shardingProperties.getValue(ShardingPropertiesConstant.PROXY_MODE);         showSQL = shardingProperties.getValue(ShardingPropertiesConstant.SQL_SHOW);         shardingMetaData = new ProxyShardingMetaData(executorService, dataSourceMap);         if (!isOnlyMasterSlave) {             shardingMetaData.init(shardingRule);         }              }          private DataSource getDataSource(final DataSourceParameter dataSourceParameter) {         HikariConfig config = new HikariConfig();         config.setDriverClassName("com.mysql.jdbc.Driver");         config.setJdbcUrl(dataSourceParameter.getUrl());         config.setUsername(dataSourceParameter.getUsername());         config.setPassword(dataSourceParameter.getPassword());         config.setAutoCommit(dataSourceParameter.getAutoCommit());         config.setConnectionTimeout(dataSourceParameter.getConnectionTimeout());         config.setIdleTimeout(dataSourceParameter.getIdleTimeout());         config.setMaxLifetime(dataSourceParameter.getMaxLifetime());         config.setMaximumPoolSize(dataSourceParameter.getMaximumPoolSize());         config.addDataSourceProperty("useServerPrepStmts", "true");         config.addDataSourceProperty("cachePrepStmts", "true");         return new HikariDataSource(config);     }          /**      * Get instance of sharding rule registry.      *      * @return instance of sharding rule registry      */     public static RuleRegistry getInstance() {         return INSTANCE;     } } " compose:StringConcatenation merge: LineBased]
