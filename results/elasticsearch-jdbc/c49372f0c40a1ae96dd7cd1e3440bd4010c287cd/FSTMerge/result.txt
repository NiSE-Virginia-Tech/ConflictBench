Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/test/java/org/xbib/elasticsearch/river/jdbc/strategy/column/ColumnRiverFlowTests.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/test/java/org/xbib/elasticsearch/river/jdbc/strategy/column/ColumnRiverFlowTests.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/test/java/org/xbib/elasticsearch/river/jdbc/strategy/column/ColumnRiverFlowTests.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/test/java/org/xbib/elasticsearch/river/jdbc/strategy/column/ColumnRiverFlowTests.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/test/java/org/xbib/elasticsearch/river/jdbc/strategy/column/ColumnRiverFlowTests.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/test/java/org/xbib/elasticsearch/river/jdbc/strategy/column/ColumnRiverFlowTests.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> test : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> xbib : Folder]
						[NT -> elasticsearch : Folder]
							[NT -> river : Folder]
								[NT -> jdbc : Folder]
									[NT -> strategy : Folder]
										[NT -> column : Folder]
											[NT -> ColumnRiverFlowTests.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package org.xbib.elasticsearch.river.jdbc.strategy.column;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.action.get.GetResponse{ImportPackage} : ImportDeclaration "import org.elasticsearch.action.get.GetResponse;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.client.Client{ImportPackage} : ImportDeclaration "import org.elasticsearch.client.Client;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.client.Requests{ImportPackage} : ImportDeclaration "import org.elasticsearch.client.Requests;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.Settings{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.settings.Settings;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.loader.JsonSettingsLoader{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.settings.loader.JsonSettingsLoader;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.unit.TimeValue{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.unit.TimeValue;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.indices.IndexMissingException{ImportPackage} : ImportDeclaration "import org.elasticsearch.indices.IndexMissingException;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.river.RiverName{ImportPackage} : ImportDeclaration "import org.elasticsearch.river.RiverName;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.river.RiverSettings{ImportPackage} : ImportDeclaration "import org.elasticsearch.river.RiverSettings;" compose:Replacement merge: Default]
													[T -> org.testng.annotations.Parameters{ImportPackage} : ImportDeclaration "import org.testng.annotations.Parameters;" compose:Replacement merge: Default]
													[T -> org.testng.annotations.Test{ImportPackage} : ImportDeclaration "import org.testng.annotations.Test;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentBuilder{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.xcontent.XContentBuilder;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentFactory{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.xcontent.XContentFactory;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.action.river.jdbc.state.RiverState{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.action.river.jdbc.state.RiverState;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.plugin.jdbc.RiverContext{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.plugin.jdbc.RiverContext;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.RiverFlow{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.RiverFlow;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.RiverSource{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.RiverSource;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest;" compose:Replacement merge: Default]
													[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
													[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder{ImportPackage} : ImportDeclaration "import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder{ImportPackage} : ImportDeclaration "import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;" compose:Replacement merge: Default]
													[NT -> ColumnRiverFlowTests : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> ColumnRiverFlowTests : Id "ColumnRiverFlowTests" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends AbstractRiverNodeTest" compose:Replacement merge: Default]
														[T -> getRiverSource({FormalParametersInternal}) : MethodDecl "@Override     public RiverSource getRiverSource() {         return new ColumnRiverSource();     }" compose:Replacement merge: LineBased]
														[T -> getRiverContext({FormalParametersInternal}) : MethodDecl "@Override     public RiverContext getRiverContext() {         return new RiverContext();     }" compose:Replacement merge: LineBased]
														[T -> testWriteLastRiverRunTimeToCustomRiverInfo(String-String) : MethodDecl "@Test()     @Parameters({"river-existedWhereClause"})     public void testWriteLastRiverRunTimeToCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         setupContext(new MockRiverSource() {             @Override             public void fetch() {             }         }, riverResource);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setName(context.getRiverName())                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();         assertLastRiverRunTimeExists(client);     }" compose:Replacement merge: LineBased]
														[T -> testReadLastRiverRunTimeFromCustomRiverInfo(String-String) : MethodDecl "@Test()     @Parameters({"river-existedWhereClause"})     public void testReadLastRiverRunTimeFromCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         final TimeValue lastRunAt = new TimeValue(600);         setupContext(new MockRiverSource() {             @Override             public void fetch() {                 assertLastRunDateEquals(lastRunAt);             }         }, riverResource);         writeLastRunDateToCustomRiverInfo(client, lastRunAt);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();     }" compose:Replacement merge: LineBased]
														[T -> setupContext(RiverSource-RiverSource-String-String) : MethodDecl "private void setupContext(RiverSource riverSource, String riverResource) throws IOException {         RiverSettings riverSettings = riverSettings(riverResource);         context.setRiverName(new RiverName(index, type).getName());         context.setRiverMouth(new MockRiverMouth());         context.setRiverSource(riverSource);         context.setRiverSettings(riverSettings.settings());         context.columnEscape(true);     }" compose:Replacement merge: LineBased]
														[T -> assertLastRiverRunTimeExists(Client-Client) : MethodDecl "private void assertLastRiverRunTimeExists(Client client) {         try {             GetResponse get = client.prepareGet("_river",                     context.getRiverName(),                     ColumnRiverFlow.DOCUMENT).execute().actionGet();             logger.info("get response = {}", get.getSourceAsMap());             Map map = (Map) get.getSourceAsMap().get("jdbc");             assertNotNull(map, "jdbc key not exists in custom info");             assertNotNull(map.get(ColumnRiverFlow.LAST_RUN_TIME), "last run time should not be null");         } catch (IndexMissingException e) {             fail("custom info not found");         }     }" compose:Replacement merge: LineBased]
														[T -> assertLastRunDateEquals(TimeValue-TimeValue) : MethodDecl "private void assertLastRunDateEquals(TimeValue expectedLastRunAt) {         Map map = (Map) context.getRiverSettings().get("jdbc");         assertNotNull(map);         assertEquals(map.get(ColumnRiverFlow.LAST_RUN_TIME), expectedLastRunAt);     }" compose:Replacement merge: LineBased]
														[T -> writeLastRunDateToCustomRiverInfo(Client-Client-TimeValue-TimeValue) : MethodDecl "private void writeLastRunDateToCustomRiverInfo(Client client, TimeValue lastRunAt) throws IOException {         XContentBuilder builder = XContentFactory.jsonBuilder()                 .startObject()                 .startObject("jdbc")                 .field(ColumnRiverFlow.LAST_RUN_TIME, lastRunAt.millis())                 .endObject()                 .endObject();         client.prepareIndex().setIndex("_river").setType(context.getRiverName()).setId(ColumnRiverFlow.DOCUMENT)                 .setSource(builder.string()).execute().actionGet();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> test : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> xbib : Folder]
						[NT -> elasticsearch : Folder]
							[NT -> river : Folder]
								[NT -> jdbc : Folder]
									[NT -> strategy : Folder]
										[NT -> column : Folder]
											[NT -> ColumnRiverFlowTests.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package org.xbib.elasticsearch.river.jdbc.strategy.column;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.action.get.GetResponse{ImportPackage} : ImportDeclaration "import org.elasticsearch.action.get.GetResponse;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.client.Client{ImportPackage} : ImportDeclaration "import org.elasticsearch.client.Client;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.client.Requests{ImportPackage} : ImportDeclaration "import org.elasticsearch.client.Requests;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.Settings{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.settings.Settings;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.loader.JsonSettingsLoader{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.settings.loader.JsonSettingsLoader;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.unit.TimeValue{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.unit.TimeValue;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.indices.IndexMissingException{ImportPackage} : ImportDeclaration "import org.elasticsearch.indices.IndexMissingException;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.river.RiverName{ImportPackage} : ImportDeclaration "import org.elasticsearch.river.RiverName;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.river.RiverSettings{ImportPackage} : ImportDeclaration "import org.elasticsearch.river.RiverSettings;" compose:Replacement merge: Default]
													[T -> org.testng.annotations.Parameters{ImportPackage} : ImportDeclaration "import org.testng.annotations.Parameters;" compose:Replacement merge: Default]
													[T -> org.testng.annotations.Test{ImportPackage} : ImportDeclaration "import org.testng.annotations.Test;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentBuilder{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.xcontent.XContentBuilder;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentFactory{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.xcontent.XContentFactory;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.action.river.state.RiverState{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.action.river.state.RiverState;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.plugin.jdbc.RiverContext{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.plugin.jdbc.RiverContext;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.RiverFlow{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.RiverFlow;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.RiverSource{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.RiverSource;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest;" compose:Replacement merge: Default]
													[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
													[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder{ImportPackage} : ImportDeclaration "import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder{ImportPackage} : ImportDeclaration "import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;" compose:Replacement merge: Default]
													[NT -> ColumnRiverFlowTests : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> ColumnRiverFlowTests : Id "ColumnRiverFlowTests" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends AbstractRiverNodeTest" compose:Replacement merge: Default]
														[T -> getRiverSource({FormalParametersInternal}) : MethodDecl "@Override     public RiverSource getRiverSource() {         return new ColumnRiverSource();     }" compose:Replacement merge: LineBased]
														[T -> getRiverContext({FormalParametersInternal}) : MethodDecl "@Override     public RiverContext getRiverContext() {         return new RiverContext();     }" compose:Replacement merge: LineBased]
														[T -> testWriteLastRiverRunTimeToCustomRiverInfo(String-String) : MethodDecl "@Test()     @Parameters({"river-existedWhereClause"})     public void testWriteLastRiverRunTimeToCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         setupContext(new MockRiverSource() {             @Override             public void fetch() {             }         }, riverResource);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();         // we can no longer test this, as _river index is always deleted between test runs!         //assertLastRiverRunTimeExists(client);     }" compose:Replacement merge: LineBased]
														[T -> testReadLastRiverRunTimeFromCustomRiverInfo(String-String) : MethodDecl "@Test()     @Parameters({"river-existedWhereClause"})     public void testReadLastRiverRunTimeFromCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         final TimeValue lastRunAt = new TimeValue(600);         setupContext(new MockRiverSource() {             @Override             public void fetch() {                 assertLastRunDateEquals(lastRunAt);             }         }, riverResource);         writeLastRunDateToCustomRiverInfo(client, lastRunAt);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();     }" compose:Replacement merge: LineBased]
														[T -> setupContext(RiverSource-RiverSource-String-String) : MethodDecl "private void setupContext(RiverSource riverSource, String riverResource) throws IOException {         RiverSettings riverSettings = riverSettings(riverResource);         context.setRiverName(new RiverName(index, type).getName());         context.setRiverMouth(new MockRiverMouth());         context.setRiverSource(riverSource);         context.setRiverSettings(riverSettings.settings());         context.columnEscape(true);     }" compose:Replacement merge: LineBased]
														[T -> assertLastRiverRunTimeExists(Client-Client) : MethodDecl "private void assertLastRiverRunTimeExists(Client client) {         try {             GetResponse get = client.prepareGet("_river",                     context.getRiverName(),                     ColumnRiverFlow.DOCUMENT).execute().actionGet();             logger.info("get response = {}", get.getSourceAsMap());             Map map = (Map) get.getSourceAsMap().get("jdbc");             assertNotNull(map, "jdbc key not exists in custom info");             assertNotNull(map.get(ColumnRiverFlow.LAST_RUN_TIME), "last run time should not be null");         } catch (IndexMissingException e) {             fail("custom info not found");         }     }" compose:Replacement merge: LineBased]
														[T -> assertLastRunDateEquals(TimeValue-TimeValue) : MethodDecl "private void assertLastRunDateEquals(TimeValue expectedLastRunAt) {         Map map = (Map) context.getRiverSettings().get("jdbc");         assertNotNull(map);         assertEquals(map.get(ColumnRiverFlow.LAST_RUN_TIME), expectedLastRunAt);     }" compose:Replacement merge: LineBased]
														[T -> writeLastRunDateToCustomRiverInfo(Client-Client-TimeValue-TimeValue) : MethodDecl "private void writeLastRunDateToCustomRiverInfo(Client client, TimeValue lastRunAt) throws IOException {         XContentBuilder builder = XContentFactory.jsonBuilder()                 .startObject()                 .startObject("jdbc")                 .field(ColumnRiverFlow.LAST_RUN_TIME, lastRunAt.millis())                 .endObject()                 .endObject();         client.prepareIndex().setIndex("_river").setType(context.getRiverName()).setId(ColumnRiverFlow.DOCUMENT)                 .setSource(builder.string()).execute().actionGet();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> test : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> xbib : Folder]
						[NT -> elasticsearch : Folder]
							[NT -> river : Folder]
								[NT -> jdbc : Folder]
									[NT -> strategy : Folder]
										[NT -> column : Folder]
											[NT -> ColumnRiverFlowTests.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package org.xbib.elasticsearch.river.jdbc.strategy.column;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.action.get.GetResponse{ImportPackage} : ImportDeclaration "import org.elasticsearch.action.get.GetResponse;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.client.Client{ImportPackage} : ImportDeclaration "import org.elasticsearch.client.Client;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.client.Requests{ImportPackage} : ImportDeclaration "import org.elasticsearch.client.Requests;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.Settings{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.settings.Settings;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.loader.JsonSettingsLoader{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.settings.loader.JsonSettingsLoader;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.unit.TimeValue{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.unit.TimeValue;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.indices.IndexMissingException{ImportPackage} : ImportDeclaration "import org.elasticsearch.indices.IndexMissingException;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.river.RiverName{ImportPackage} : ImportDeclaration "import org.elasticsearch.river.RiverName;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.river.RiverSettings{ImportPackage} : ImportDeclaration "import org.elasticsearch.river.RiverSettings;" compose:Replacement merge: Default]
													[T -> org.testng.annotations.Parameters{ImportPackage} : ImportDeclaration "import org.testng.annotations.Parameters;" compose:Replacement merge: Default]
													[T -> org.testng.annotations.Test{ImportPackage} : ImportDeclaration "import org.testng.annotations.Test;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentBuilder{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.xcontent.XContentBuilder;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentFactory{ImportPackage} : ImportDeclaration "import org.elasticsearch.common.xcontent.XContentFactory;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.action.river.state.RiverState{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.action.river.state.RiverState;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.plugin.jdbc.RiverContext{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.plugin.jdbc.RiverContext;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.RiverFlow{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.RiverFlow;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.RiverSource{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.RiverSource;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource;" compose:Replacement merge: Default]
													[T -> org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest{ImportPackage} : ImportDeclaration "import org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest;" compose:Replacement merge: Default]
													[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
													[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder{ImportPackage} : ImportDeclaration "import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;" compose:Replacement merge: Default]
													[T -> org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder{ImportPackage} : ImportDeclaration "import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;" compose:Replacement merge: Default]
													[NT -> ColumnRiverFlowTests : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> ColumnRiverFlowTests : Id "ColumnRiverFlowTests" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends AbstractRiverNodeTest" compose:Replacement merge: Default]
														[T -> getRiverSource({FormalParametersInternal}) : MethodDecl "@Override     public RiverSource getRiverSource() {         return new ColumnRiverSource();     }" compose:Replacement merge: LineBased]
														[T -> getRiverContext({FormalParametersInternal}) : MethodDecl "@Override     public RiverContext getRiverContext() {         return new RiverContext();     }" compose:Replacement merge: LineBased]
														[T -> testWriteLastRiverRunTimeToCustomRiverInfo(String-String) : MethodDecl "@Test()     @Parameters({"river-existedWhereClause"})     public void testWriteLastRiverRunTimeToCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         setupContext(new MockRiverSource() {             @Override             public void fetch() {             }         }, riverResource);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setName(context.getRiverName())                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();         assertLastRiverRunTimeExists(client);     }" compose:Replacement merge: LineBased]
														[T -> testReadLastRiverRunTimeFromCustomRiverInfo(String-String) : MethodDecl "@Test()     @Parameters({"river-existedWhereClause"})     public void testReadLastRiverRunTimeFromCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         final TimeValue lastRunAt = new TimeValue(600);         setupContext(new MockRiverSource() {             @Override             public void fetch() {                 assertLastRunDateEquals(lastRunAt);             }         }, riverResource);         writeLastRunDateToCustomRiverInfo(client, lastRunAt);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();     }" compose:Replacement merge: LineBased]
														[T -> setupContext(RiverSource-RiverSource-String-String) : MethodDecl "private void setupContext(RiverSource riverSource, String riverResource) throws IOException {         RiverSettings riverSettings = riverSettings(riverResource);         context.setRiverName(new RiverName(index, type).getName());         context.setRiverMouth(new MockRiverMouth());         context.setRiverSource(riverSource);         context.setRiverSettings(riverSettings.settings());         context.columnEscape(true);     }" compose:Replacement merge: LineBased]
														[T -> assertLastRiverRunTimeExists(Client-Client) : MethodDecl "private void assertLastRiverRunTimeExists(Client client) {         try {             GetResponse get = client.prepareGet("_river",                     context.getRiverName(),                     ColumnRiverFlow.DOCUMENT).execute().actionGet();             logger.info("get response = {}", get.getSourceAsMap());             Map map = (Map) get.getSourceAsMap().get("jdbc");             assertNotNull(map, "jdbc key not exists in custom info");             assertNotNull(map.get(ColumnRiverFlow.LAST_RUN_TIME), "last run time should not be null");         } catch (IndexMissingException e) {             fail("custom info not found");         }     }" compose:Replacement merge: LineBased]
														[T -> assertLastRunDateEquals(TimeValue-TimeValue) : MethodDecl "private void assertLastRunDateEquals(TimeValue expectedLastRunAt) {         Map map = (Map) context.getRiverSettings().get("jdbc");         assertNotNull(map);         assertEquals(map.get(ColumnRiverFlow.LAST_RUN_TIME), expectedLastRunAt);     }" compose:Replacement merge: LineBased]
														[T -> writeLastRunDateToCustomRiverInfo(Client-Client-TimeValue-TimeValue) : MethodDecl "private void writeLastRunDateToCustomRiverInfo(Client client, TimeValue lastRunAt) throws IOException {         XContentBuilder builder = XContentFactory.jsonBuilder()                 .startObject()                 .startObject("jdbc")                 .field(ColumnRiverFlow.LAST_RUN_TIME, lastRunAt.millis())                 .endObject()                 .endObject();         client.prepareIndex().setIndex("_river").setType(context.getRiverName()).setId(ColumnRiverFlow.DOCUMENT)                 .setSource(builder.string()).execute().actionGet();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> test : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> xbib : Folder]
						[NT -> elasticsearch : Folder]
							[NT -> river : Folder]
								[NT -> jdbc : Folder]
									[NT -> strategy : Folder]
										[NT -> column : Folder]
											[NT -> ColumnRiverFlowTests.java.merge : .java.merge-File]
												[T -> ColumnRiverFlowTests.java : .java-Content "package org.xbib.elasticsearch.river.jdbc.strategy.column;  import org.elasticsearch.action.get.GetResponse; import org.elasticsearch.client.Client; import org.elasticsearch.client.Requests; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.common.settings.loader.JsonSettingsLoader; import org.elasticsearch.common.unit.TimeValue; import org.elasticsearch.indices.IndexMissingException; import org.elasticsearch.river.RiverName; import org.elasticsearch.river.RiverSettings; import org.testng.annotations.Parameters; import org.testng.annotations.Test; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.xbib.elasticsearch.action.river.jdbc.state.RiverState; import org.xbib.elasticsearch.plugin.jdbc.RiverContext; import org.xbib.elasticsearch.river.jdbc.RiverFlow; import org.xbib.elasticsearch.river.jdbc.RiverSource; import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth; import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource; import org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest;  import java.io.IOException; import java.util.Map;  import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder; import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;  public class ColumnRiverFlowTests extends AbstractRiverNodeTest {      @Override     public RiverSource getRiverSource() {         return new ColumnRiverSource();     }      @Override     public RiverContext getRiverContext() {         return new RiverContext();     }      @Test()     @Parameters({"river-existedWhereClause"})     public void testWriteLastRiverRunTimeToCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         setupContext(new MockRiverSource() {             @Override             public void fetch() {             }         }, riverResource);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setName(context.getRiverName())                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();         assertLastRiverRunTimeExists(client);     }      @Test()     @Parameters({"river-existedWhereClause"})     public void testReadLastRiverRunTimeFromCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         final TimeValue lastRunAt = new TimeValue(600);         setupContext(new MockRiverSource() {             @Override             public void fetch() {                 assertLastRunDateEquals(lastRunAt);             }         }, riverResource);         writeLastRunDateToCustomRiverInfo(client, lastRunAt);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();     }      private void setupContext(RiverSource riverSource, String riverResource) throws IOException {         RiverSettings riverSettings = riverSettings(riverResource);         context.setRiverName(new RiverName(index, type).getName());         context.setRiverMouth(new MockRiverMouth());         context.setRiverSource(riverSource);         context.setRiverSettings(riverSettings.settings());         context.columnEscape(true);     }      private void assertLastRiverRunTimeExists(Client client) {         try {             GetResponse get = client.prepareGet("_river",                     context.getRiverName(),                     ColumnRiverFlow.DOCUMENT).execute().actionGet();             logger.info("get response = {}", get.getSourceAsMap());             Map map = (Map) get.getSourceAsMap().get("jdbc");             assertNotNull(map, "jdbc key not exists in custom info");             assertNotNull(map.get(ColumnRiverFlow.LAST_RUN_TIME), "last run time should not be null");         } catch (IndexMissingException e) {             fail("custom info not found");         }     }      private void assertLastRunDateEquals(TimeValue expectedLastRunAt) {         Map map = (Map) context.getRiverSettings().get("jdbc");         assertNotNull(map);         assertEquals(map.get(ColumnRiverFlow.LAST_RUN_TIME), expectedLastRunAt);     }      private void writeLastRunDateToCustomRiverInfo(Client client, TimeValue lastRunAt) throws IOException {         XContentBuilder builder = XContentFactory.jsonBuilder()                 .startObject()                 .startObject("jdbc")                 .field(ColumnRiverFlow.LAST_RUN_TIME, lastRunAt.millis())                 .endObject()                 .endObject();         client.prepareIndex().setIndex("_river").setType(context.getRiverName()).setId(ColumnRiverFlow.DOCUMENT)                 .setSource(builder.string()).execute().actionGet();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> test : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> xbib : Folder]
						[NT -> elasticsearch : Folder]
							[NT -> river : Folder]
								[NT -> jdbc : Folder]
									[NT -> strategy : Folder]
										[NT -> column : Folder]
											[NT -> ColumnRiverFlowTests.java.merge : .java.merge-File]
												[T -> ColumnRiverFlowTests.java : .java-Content "package org.xbib.elasticsearch.river.jdbc.strategy.column;  import org.elasticsearch.action.get.GetResponse; import org.elasticsearch.client.Client; import org.elasticsearch.client.Requests; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.common.settings.loader.JsonSettingsLoader; import org.elasticsearch.common.unit.TimeValue; import org.elasticsearch.indices.IndexMissingException; import org.elasticsearch.river.RiverName; import org.elasticsearch.river.RiverSettings; import org.testng.annotations.Parameters; import org.testng.annotations.Test; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.xbib.elasticsearch.action.river.state.RiverState; import org.xbib.elasticsearch.plugin.jdbc.RiverContext; import org.xbib.elasticsearch.river.jdbc.RiverFlow; import org.xbib.elasticsearch.river.jdbc.RiverSource; import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth; import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource; import org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest;  import java.io.IOException; import java.util.Map;  import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder; import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;  public class ColumnRiverFlowTests extends AbstractRiverNodeTest {      @Override     public RiverSource getRiverSource() {         return new ColumnRiverSource();     }      @Override     public RiverContext getRiverContext() {         return new RiverContext();     }      @Test()     @Parameters({"river-existedWhereClause"})     public void testWriteLastRiverRunTimeToCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         setupContext(new MockRiverSource() {             @Override             public void fetch() {             }         }, riverResource);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();         // we can no longer test this, as _river index is always deleted between test runs!         //assertLastRiverRunTimeExists(client);     }      @Test()     @Parameters({"river-existedWhereClause"})     public void testReadLastRiverRunTimeFromCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         final TimeValue lastRunAt = new TimeValue(600);         setupContext(new MockRiverSource() {             @Override             public void fetch() {                 assertLastRunDateEquals(lastRunAt);             }         }, riverResource);         writeLastRunDateToCustomRiverInfo(client, lastRunAt);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();     }      private void setupContext(RiverSource riverSource, String riverResource) throws IOException {         RiverSettings riverSettings = riverSettings(riverResource);         context.setRiverName(new RiverName(index, type).getName());         context.setRiverMouth(new MockRiverMouth());         context.setRiverSource(riverSource);         context.setRiverSettings(riverSettings.settings());         context.columnEscape(true);     }      private void assertLastRiverRunTimeExists(Client client) {         try {             GetResponse get = client.prepareGet("_river",                     context.getRiverName(),                     ColumnRiverFlow.DOCUMENT).execute().actionGet();             logger.info("get response = {}", get.getSourceAsMap());             Map map = (Map) get.getSourceAsMap().get("jdbc");             assertNotNull(map, "jdbc key not exists in custom info");             assertNotNull(map.get(ColumnRiverFlow.LAST_RUN_TIME), "last run time should not be null");         } catch (IndexMissingException e) {             fail("custom info not found");         }     }      private void assertLastRunDateEquals(TimeValue expectedLastRunAt) {         Map map = (Map) context.getRiverSettings().get("jdbc");         assertNotNull(map);         assertEquals(map.get(ColumnRiverFlow.LAST_RUN_TIME), expectedLastRunAt);     }      private void writeLastRunDateToCustomRiverInfo(Client client, TimeValue lastRunAt) throws IOException {         XContentBuilder builder = XContentFactory.jsonBuilder()                 .startObject()                 .startObject("jdbc")                 .field(ColumnRiverFlow.LAST_RUN_TIME, lastRunAt.millis())                 .endObject()                 .endObject();         client.prepareIndex().setIndex("_river").setType(context.getRiverName()).setId(ColumnRiverFlow.DOCUMENT)                 .setSource(builder.string()).execute().actionGet();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> test : Folder]
			[NT -> java : Folder]
				[NT -> org : Folder]
					[NT -> xbib : Folder]
						[NT -> elasticsearch : Folder]
							[NT -> river : Folder]
								[NT -> jdbc : Folder]
									[NT -> strategy : Folder]
										[NT -> column : Folder]
											[NT -> ColumnRiverFlowTests.java.merge : .java.merge-File]
												[T -> ColumnRiverFlowTests.java : .java-Content "package org.xbib.elasticsearch.river.jdbc.strategy.column;  import org.elasticsearch.action.get.GetResponse; import org.elasticsearch.client.Client; import org.elasticsearch.client.Requests; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.common.settings.loader.JsonSettingsLoader; import org.elasticsearch.common.unit.TimeValue; import org.elasticsearch.indices.IndexMissingException; import org.elasticsearch.river.RiverName; import org.elasticsearch.river.RiverSettings; import org.testng.annotations.Parameters; import org.testng.annotations.Test; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.xbib.elasticsearch.action.river.state.RiverState; import org.xbib.elasticsearch.plugin.jdbc.RiverContext; import org.xbib.elasticsearch.river.jdbc.RiverFlow; import org.xbib.elasticsearch.river.jdbc.RiverSource; import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverMouth; import org.xbib.elasticsearch.river.jdbc.strategy.mock.MockRiverSource; import org.xbib.elasticsearch.support.helper.AbstractRiverNodeTest;  import java.io.IOException; import java.util.Map;  import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder; import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;  public class ColumnRiverFlowTests extends AbstractRiverNodeTest {      @Override     public RiverSource getRiverSource() {         return new ColumnRiverSource();     }      @Override     public RiverContext getRiverContext() {         return new RiverContext();     }      @Test()     @Parameters({"river-existedWhereClause"})     public void testWriteLastRiverRunTimeToCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         setupContext(new MockRiverSource() {             @Override             public void fetch() {             }         }, riverResource);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setName(context.getRiverName())                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();         assertLastRiverRunTimeExists(client);     }      @Test()     @Parameters({"river-existedWhereClause"})     public void testReadLastRiverRunTimeFromCustomRiverInfo(String riverResource) throws IOException {         final Client client = client("1");         final TimeValue lastRunAt = new TimeValue(600);         setupContext(new MockRiverSource() {             @Override             public void fetch() {                 assertLastRunDateEquals(lastRunAt);             }         }, riverResource);         writeLastRunDateToCustomRiverInfo(client, lastRunAt);         Map<String, Object> spec = (Map<String, Object>) riverSettings(riverResource).settings().get("jdbc");         Map<String, String> loadedSettings = new JsonSettingsLoader().load(jsonBuilder().map(spec).string());         Settings settings = settingsBuilder().put(loadedSettings).build();         RiverFlow flow = new ColumnRiverFlow();         flow.setRiverContext(context);         flow.getFeeder()                 .setRiverState(new RiverState())                 .setSpec(spec)                 .setSettings(settings)                 .setClient(client)                 .run();     }      private void setupContext(RiverSource riverSource, String riverResource) throws IOException {         RiverSettings riverSettings = riverSettings(riverResource);         context.setRiverName(new RiverName(index, type).getName());         context.setRiverMouth(new MockRiverMouth());         context.setRiverSource(riverSource);         context.setRiverSettings(riverSettings.settings());         context.columnEscape(true);     }      private void assertLastRiverRunTimeExists(Client client) {         try {             GetResponse get = client.prepareGet("_river",                     context.getRiverName(),                     ColumnRiverFlow.DOCUMENT).execute().actionGet();             logger.info("get response = {}", get.getSourceAsMap());             Map map = (Map) get.getSourceAsMap().get("jdbc");             assertNotNull(map, "jdbc key not exists in custom info");             assertNotNull(map.get(ColumnRiverFlow.LAST_RUN_TIME), "last run time should not be null");         } catch (IndexMissingException e) {             fail("custom info not found");         }     }      private void assertLastRunDateEquals(TimeValue expectedLastRunAt) {         Map map = (Map) context.getRiverSettings().get("jdbc");         assertNotNull(map);         assertEquals(map.get(ColumnRiverFlow.LAST_RUN_TIME), expectedLastRunAt);     }      private void writeLastRunDateToCustomRiverInfo(Client client, TimeValue lastRunAt) throws IOException {         XContentBuilder builder = XContentFactory.jsonBuilder()                 .startObject()                 .startObject("jdbc")                 .field(ColumnRiverFlow.LAST_RUN_TIME, lastRunAt.millis())                 .endObject()                 .endObject();         client.prepareIndex().setIndex("_river").setType(context.getRiverName()).setId(ColumnRiverFlow.DOCUMENT)                 .setSource(builder.string()).execute().actionGet();         client.admin().indices().refresh(Requests.refreshRequest("_river")).actionGet();     } } " compose:StringConcatenation merge: LineBased]
