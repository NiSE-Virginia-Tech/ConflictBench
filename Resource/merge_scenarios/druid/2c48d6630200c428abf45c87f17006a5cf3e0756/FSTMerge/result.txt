Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/com/alibaba/druid/wall/WallProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/com/alibaba/druid/wall/WallProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/com/alibaba/druid/wall/WallProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/com/alibaba/druid/wall/WallProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/com/alibaba/druid/wall/WallProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/com/alibaba/druid/wall/WallProvider.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> alibaba : Folder]
						[NT -> druid : Folder]
							[NT -> wall : Folder]
								[NT -> WallProvider.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.alibaba.druid.wall;" compose:Replacement merge: Default]
										[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
										[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
										[T -> java.util.LinkedHashMap{ImportPackage} : ImportDeclaration "import java.util.LinkedHashMap;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.locks.ReentrantReadWriteLock{ImportPackage} : ImportDeclaration "import java.util.concurrent.locks.ReentrantReadWriteLock;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.ast.SQLStatement{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.ast.SQLStatement;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.ParserException{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.ParserException;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.SQLStatementParser{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.SQLStatementParser;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.Token{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.Token;" compose:Replacement merge: Default]
										[NT -> WallProvider : ClassDeclaration]
											[T -> - : Modifiers "public abstract" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> WallProvider : Id "WallProvider" compose:Replacement merge: Default]
											[T -> PRESENT : FieldDecl "private static final Object           PRESENT           = new Object();" compose:Replacement merge: SemanticConflict]
											[T -> whiteList : FieldDecl "private LinkedHashMap<String, Object> whiteList;" compose:Replacement merge: SemanticConflict]
											[T -> whileListMaxSize : FieldDecl "private int                           whileListMaxSize  = 1024;" compose:Replacement merge: SemanticConflict]
											[T -> whiteSqlMaxLength : FieldDecl "private int                           whiteSqlMaxLength = 1024;" compose:Replacement merge: SemanticConflict]
											[T -> config : FieldDecl "protected final WallConfig            config;" compose:Replacement merge: SemanticConflict]
											[T -> lock : FieldDecl "private final ReentrantReadWriteLock  lock              = new ReentrantReadWriteLock();" compose:Replacement merge: SemanticConflict]
											[T -> WallProvider(WallConfig-WallConfig) : ConstructorDecl "public WallProvider(WallConfig config){          this.config = config;      }" compose:Replacement merge: LineBased]
											[T -> getConfig({FormalParametersInternal}) : MethodDecl "public WallConfig getConfig() {          return config;      }" compose:Replacement merge: LineBased]
											[T -> addWhiteSql(String-String) : MethodDecl "public void addWhiteSql(String sql) {          lock.writeLock().lock();          try {              if (whiteList == null) {                  whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);              }                whiteList.put(sql, PRESENT);          } finally {              lock.writeLock().unlock();          }      }" compose:Replacement merge: LineBased]
											[T -> clearCache({FormalParametersInternal}) : MethodDecl "public void clearCache() {          lock.writeLock().lock();          try {              if (whiteList != null) {                  whiteList = null;              }          } finally {              lock.writeLock().unlock();          }      }" compose:Replacement merge: LineBased]
											[T -> whiteContains(String-String) : MethodDecl "public boolean whiteContains(String sql) {          lock.readLock().lock();          try {              if (whiteList == null) {                  return false;              }                return whiteList.get(sql) != null;          } finally {              lock.readLock().unlock();          }      }" compose:Replacement merge: LineBased]
											[T -> createParser(String-String) : MethodDecl "public abstract SQLStatementParser createParser(String sql);" compose:Replacement merge: LineBased]
											[T -> createWallVisitor({FormalParametersInternal}) : MethodDecl "public abstract WallVisitor createWallVisitor();" compose:Replacement merge: LineBased]
											[T -> checkValid(String-String) : MethodDecl "public boolean checkValid(String sql) {          return check(sql).size() == 0;      }" compose:Replacement merge: LineBased]
											[T -> check(String-String) : MethodDecl "public List<Violation> check(String sql) {          // first step, check whiteList          boolean isWhite = whiteContains(sql);          if (isWhite) {              return Collections.emptyList();          }            SQLStatementParser parser = createParser(sql);            if (!config.isCommentAllow()) {              parser.getLexer().setAllowComment(false); // permit comment          }            List<SQLStatement> statementList = new ArrayList<SQLStatement>();            try {              parser.parseStatementList(statementList);          } catch (ParserException e) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (parser.getLexer().token() != Token.EOF) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (statementList.size() > 1) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            SQLStatement stmt = statementList.get(0);            WallVisitor visitor = createWallVisitor();            try {              stmt.accept(visitor);          } catch (ParserException e) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (visitor.getViolations().size() == 0) {              if (sql.length() < whiteSqlMaxLength) {                  this.addWhiteSql(sql);              }          }            return visitor.getViolations();      }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> alibaba : Folder]
						[NT -> druid : Folder]
							[NT -> wall : Folder]
								[NT -> WallProvider.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.alibaba.druid.wall;" compose:Replacement merge: Default]
										[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
										[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
										[T -> java.util.LinkedHashMap{ImportPackage} : ImportDeclaration "import java.util.LinkedHashMap;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.ast.SQLStatement{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.ast.SQLStatement;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.ParserException{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.ParserException;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.SQLStatementParser{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.SQLStatementParser;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.Token{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.Token;" compose:Replacement merge: Default]
										[NT -> WallProvider : ClassDeclaration]
											[T -> - : Modifiers "public abstract" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> WallProvider : Id "WallProvider" compose:Replacement merge: Default]
											[T -> PRESENT : FieldDecl "private static final Object           PRESENT           = new Object();" compose:Replacement merge: SemanticConflict]
											[T -> whiteList : FieldDecl "private LinkedHashMap<String, Object> whiteList;" compose:Replacement merge: SemanticConflict]
											[T -> whileListMaxSize : FieldDecl "private int                           whileListMaxSize  = 1024;" compose:Replacement merge: SemanticConflict]
											[T -> whiteSqlMaxLength : FieldDecl "private int                           whiteSqlMaxLength = 1024;" compose:Replacement merge: SemanticConflict]
											[T -> config : FieldDecl "protected final WallConfig            config;" compose:Replacement merge: SemanticConflict]
											[T -> WallProvider(WallConfig-WallConfig) : ConstructorDecl "public WallProvider(WallConfig config){          this.config = config;      }" compose:Replacement merge: LineBased]
											[T -> getConfig({FormalParametersInternal}) : MethodDecl "public WallConfig getConfig() {          return config;      }" compose:Replacement merge: LineBased]
											[T -> addWhiteSql(String-String) : MethodDecl "public synchronized void addWhiteSql(String sql) {          if (whiteList == null) {              whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);          }            whiteList.put(sql, PRESENT);      }" compose:Replacement merge: LineBased]
											[T -> whiteContains(String-String) : MethodDecl "public synchronized boolean whiteContains(String sql) {          if (whiteList == null) {              return false;          }            return whiteList.get(sql) != null;      }" compose:Replacement merge: LineBased]
											[T -> createParser(String-String) : MethodDecl "public abstract SQLStatementParser createParser(String sql);" compose:Replacement merge: LineBased]
											[T -> createWallVisitor({FormalParametersInternal}) : MethodDecl "public abstract WallVisitor createWallVisitor();" compose:Replacement merge: LineBased]
											[T -> checkValid(String-String) : MethodDecl "public boolean checkValid(String sql) {          return check(sql).size() == 0;      }" compose:Replacement merge: LineBased]
											[T -> check(String-String) : MethodDecl "public List<Violation> check(String sql) {          // first step, check whiteList          boolean isWhite = whiteContains(sql);          if (isWhite) {              return Collections.emptyList();          }            SQLStatementParser parser = createParser(sql);          parser.getLexer().setAllowComment(false); // permit comment            List<SQLStatement> statementList = new ArrayList<SQLStatement>();            try {              parser.parseStatementList(statementList);          } catch (ParserException e) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (parser.getLexer().token() != Token.EOF) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (statementList.size() > 1) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            SQLStatement stmt = statementList.get(0);            WallVisitor visitor = createWallVisitor();            try {              stmt.accept(visitor);          } catch (ParserException e) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (visitor.getViolations().size() == 0) {              if (sql.length() < whiteSqlMaxLength) {                  this.addWhiteSql(sql);              }          }            return visitor.getViolations();      }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> alibaba : Folder]
						[NT -> druid : Folder]
							[NT -> wall : Folder]
								[NT -> WallProvider.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.alibaba.druid.wall;" compose:Replacement merge: Default]
										[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
										[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
										[T -> java.util.LinkedHashMap{ImportPackage} : ImportDeclaration "import java.util.LinkedHashMap;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> java.util.concurrent.locks.ReentrantReadWriteLock{ImportPackage} : ImportDeclaration "import java.util.concurrent.locks.ReentrantReadWriteLock;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.ast.SQLStatement{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.ast.SQLStatement;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.ParserException{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.ParserException;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.SQLStatementParser{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.SQLStatementParser;" compose:Replacement merge: Default]
										[T -> com.alibaba.druid.sql.parser.Token{ImportPackage} : ImportDeclaration "import com.alibaba.druid.sql.parser.Token;" compose:Replacement merge: Default]
										[NT -> WallProvider : ClassDeclaration]
											[T -> - : Modifiers "public abstract" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> WallProvider : Id "WallProvider" compose:Replacement merge: Default]
											[T -> PRESENT : FieldDecl "private static final Object           PRESENT           = new Object();" compose:Replacement merge: SemanticConflict]
											[T -> whiteList : FieldDecl "private LinkedHashMap<String, Object> whiteList;" compose:Replacement merge: SemanticConflict]
											[T -> whileListMaxSize : FieldDecl "private int                           whileListMaxSize  = 1024;" compose:Replacement merge: SemanticConflict]
											[T -> whiteSqlMaxLength : FieldDecl "private int                           whiteSqlMaxLength = 1024;" compose:Replacement merge: SemanticConflict]
											[T -> config : FieldDecl "protected final WallConfig            config;" compose:Replacement merge: SemanticConflict]
											[T -> lock : FieldDecl "private final ReentrantReadWriteLock  lock              = new ReentrantReadWriteLock();" compose:Replacement merge: SemanticConflict]
											[T -> WallProvider(WallConfig-WallConfig) : ConstructorDecl "public WallProvider(WallConfig config){          this.config = config;      }" compose:Replacement merge: LineBased]
											[T -> getConfig({FormalParametersInternal}) : MethodDecl "public WallConfig getConfig() {          return config;      }" compose:Replacement merge: LineBased]
											[T -> addWhiteSql(String-String) : MethodDecl "public void addWhiteSql(String sql) {          lock.writeLock().lock();          try {              if (whiteList == null) {                  whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);              }                whiteList.put(sql, PRESENT);          } finally {              lock.writeLock().unlock();          }      }" compose:Replacement merge: LineBased]
											[T -> whiteContains(String-String) : MethodDecl "public boolean whiteContains(String sql) {          lock.readLock().lock();          try {              if (whiteList == null) {                  return false;              }                return whiteList.get(sql) != null;          } finally {              lock.readLock().unlock();          }      }" compose:Replacement merge: LineBased]
											[T -> createParser(String-String) : MethodDecl "public abstract SQLStatementParser createParser(String sql);" compose:Replacement merge: LineBased]
											[T -> createWallVisitor({FormalParametersInternal}) : MethodDecl "public abstract WallVisitor createWallVisitor();" compose:Replacement merge: LineBased]
											[T -> checkValid(String-String) : MethodDecl "public boolean checkValid(String sql) {          return check(sql).size() == 0;      }" compose:Replacement merge: LineBased]
											[T -> check(String-String) : MethodDecl "public List<Violation> check(String sql) {          // first step, check whiteList          boolean isWhite = whiteContains(sql);          if (isWhite) {              return Collections.emptyList();          }            SQLStatementParser parser = createParser(sql);            if (!config.isCommentAllow()) {              parser.getLexer().setAllowComment(false); // permit comment          }            List<SQLStatement> statementList = new ArrayList<SQLStatement>();            try {              parser.parseStatementList(statementList);          } catch (ParserException e) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (parser.getLexer().token() != Token.EOF) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (statementList.size() > 1) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            SQLStatement stmt = statementList.get(0);            WallVisitor visitor = createWallVisitor();            try {              stmt.accept(visitor);          } catch (ParserException e) {              return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));          }            if (visitor.getViolations().size() == 0) {              if (sql.length() < whiteSqlMaxLength) {                  this.addWhiteSql(sql);              }          }            return visitor.getViolations();      }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> alibaba : Folder]
						[NT -> druid : Folder]
							[NT -> wall : Folder]
								[NT -> WallProvider.java.merge : .java.merge-File]
									[T -> WallProvider.java : .java-Content "package com.alibaba.druid.wall;  import java.util.ArrayList; import java.util.Collections; import java.util.LinkedHashMap; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock;  import com.alibaba.druid.sql.ast.SQLStatement; import com.alibaba.druid.sql.parser.ParserException; import com.alibaba.druid.sql.parser.SQLStatementParser; import com.alibaba.druid.sql.parser.Token;  public abstract class WallProvider {      // Dummy value to associate with an Object in the backing Map     private static final Object           PRESENT           = new Object();      private LinkedHashMap<String, Object> whiteList;      private int                           whileListMaxSize  = 1024;      private int                           whiteSqlMaxLength = 1024;                        // 1k      protected final WallConfig            config;      private final ReentrantReadWriteLock  lock              = new ReentrantReadWriteLock();      public WallProvider(WallConfig config){         this.config = config;     }      public WallConfig getConfig() {         return config;     }      public void addWhiteSql(String sql) {         lock.writeLock().lock();         try {             if (whiteList == null) {                 whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);             }              whiteList.put(sql, PRESENT);         } finally {             lock.writeLock().unlock();         }     }          public void clearCache() {         lock.writeLock().lock();         try {             if (whiteList != null) {                 whiteList = null;             }         } finally {             lock.writeLock().unlock();         }     }      public boolean whiteContains(String sql) {         lock.readLock().lock();         try {             if (whiteList == null) {                 return false;             }              return whiteList.get(sql) != null;         } finally {             lock.readLock().unlock();         }     }      public abstract SQLStatementParser createParser(String sql);      public abstract WallVisitor createWallVisitor();      public boolean checkValid(String sql) {         return check(sql).size() == 0;     }      public List<Violation> check(String sql) {         // first step, check whiteList         boolean isWhite = whiteContains(sql);         if (isWhite) {             return Collections.emptyList();         }          SQLStatementParser parser = createParser(sql);          if (!config.isCommentAllow()) {             parser.getLexer().setAllowComment(false); // permit comment         }          List<SQLStatement> statementList = new ArrayList<SQLStatement>();          try {             parser.parseStatementList(statementList);         } catch (ParserException e) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (parser.getLexer().token() != Token.EOF) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (statementList.size() > 1) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          SQLStatement stmt = statementList.get(0);          WallVisitor visitor = createWallVisitor();          try {             stmt.accept(visitor);         } catch (ParserException e) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (visitor.getViolations().size() == 0) {             if (sql.length() < whiteSqlMaxLength) {                 this.addWhiteSql(sql);             }         }          return visitor.getViolations();     }  } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> alibaba : Folder]
						[NT -> druid : Folder]
							[NT -> wall : Folder]
								[NT -> WallProvider.java.merge : .java.merge-File]
									[T -> WallProvider.java : .java-Content "package com.alibaba.druid.wall;  import java.util.ArrayList; import java.util.Collections; import java.util.LinkedHashMap; import java.util.List;  import com.alibaba.druid.sql.ast.SQLStatement; import com.alibaba.druid.sql.parser.ParserException; import com.alibaba.druid.sql.parser.SQLStatementParser; import com.alibaba.druid.sql.parser.Token;  public abstract class WallProvider {      // Dummy value to associate with an Object in the backing Map     private static final Object           PRESENT           = new Object();      private LinkedHashMap<String, Object> whiteList;      private int                           whileListMaxSize  = 1024;      private int                           whiteSqlMaxLength = 1024;        // 1k      protected final WallConfig            config;      public WallProvider(WallConfig config){         this.config = config;     }      public WallConfig getConfig() {         return config;     }      public synchronized void addWhiteSql(String sql) {         if (whiteList == null) {             whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);         }          whiteList.put(sql, PRESENT);     }      public synchronized boolean whiteContains(String sql) {         if (whiteList == null) {             return false;         }          return whiteList.get(sql) != null;     }      public abstract SQLStatementParser createParser(String sql);      public abstract WallVisitor createWallVisitor();          public boolean checkValid(String sql) {         return check(sql).size() == 0;     }      public List<Violation> check(String sql) {         // first step, check whiteList         boolean isWhite = whiteContains(sql);         if (isWhite) {             return Collections.emptyList();         }          SQLStatementParser parser = createParser(sql);         parser.getLexer().setAllowComment(false); // permit comment          List<SQLStatement> statementList = new ArrayList<SQLStatement>();          try {             parser.parseStatementList(statementList);         } catch (ParserException e) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (parser.getLexer().token() != Token.EOF) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (statementList.size() > 1) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          SQLStatement stmt = statementList.get(0);          WallVisitor visitor = createWallVisitor();          try {             stmt.accept(visitor);         } catch (ParserException e) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (visitor.getViolations().size() == 0) {             if (sql.length() < whiteSqlMaxLength) {                 this.addWhiteSql(sql);             }         }          return visitor.getViolations();     }  } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> alibaba : Folder]
						[NT -> druid : Folder]
							[NT -> wall : Folder]
								[NT -> WallProvider.java.merge : .java.merge-File]
									[T -> WallProvider.java : .java-Content "package com.alibaba.druid.wall;  import java.util.ArrayList; import java.util.Collections; import java.util.LinkedHashMap; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock;  import com.alibaba.druid.sql.ast.SQLStatement; import com.alibaba.druid.sql.parser.ParserException; import com.alibaba.druid.sql.parser.SQLStatementParser; import com.alibaba.druid.sql.parser.Token;  public abstract class WallProvider {      // Dummy value to associate with an Object in the backing Map     private static final Object           PRESENT           = new Object();      private LinkedHashMap<String, Object> whiteList;      private int                           whileListMaxSize  = 1024;      private int                           whiteSqlMaxLength = 1024;                        // 1k      protected final WallConfig            config;      private final ReentrantReadWriteLock  lock              = new ReentrantReadWriteLock();      public WallProvider(WallConfig config){         this.config = config;     }      public WallConfig getConfig() {         return config;     }      public void addWhiteSql(String sql) {         lock.writeLock().lock();         try {             if (whiteList == null) {                 whiteList = new LinkedHashMap<String, Object>(whileListMaxSize, 0.75f, true);             }              whiteList.put(sql, PRESENT);         } finally {             lock.writeLock().unlock();         }     }      public boolean whiteContains(String sql) {         lock.readLock().lock();         try {             if (whiteList == null) {                 return false;             }              return whiteList.get(sql) != null;         } finally {             lock.readLock().unlock();         }     }      public abstract SQLStatementParser createParser(String sql);      public abstract WallVisitor createWallVisitor();      public boolean checkValid(String sql) {         return check(sql).size() == 0;     }      public List<Violation> check(String sql) {         // first step, check whiteList         boolean isWhite = whiteContains(sql);         if (isWhite) {             return Collections.emptyList();         }          SQLStatementParser parser = createParser(sql);          if (!config.isCommentAllow()) {             parser.getLexer().setAllowComment(false); // permit comment         }          List<SQLStatement> statementList = new ArrayList<SQLStatement>();          try {             parser.parseStatementList(statementList);         } catch (ParserException e) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (parser.getLexer().token() != Token.EOF) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (statementList.size() > 1) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          SQLStatement stmt = statementList.get(0);          WallVisitor visitor = createWallVisitor();          try {             stmt.accept(visitor);         } catch (ParserException e) {             return Collections.<Violation> singletonList(new IllegalSQLObjectViolation(sql));         }          if (visitor.getViolations().size() == 0) {             if (sql.length() < whiteSqlMaxLength) {                 this.addWhiteSql(sql);             }         }          return visitor.getViolations();     }  } " compose:StringConcatenation merge: LineBased]
