Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/spock-core/src/main/java/spock/lang/Unroll.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/spock-core/src/main/java/spock/lang/Unroll.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/spock-core/src/main/java/spock/lang/Unroll.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/spock-core/src/main/java/spock/lang/Unroll.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/spock-core/src/main/java/spock/lang/Unroll.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/spock-core/src/main/java/spock/lang/Unroll.java
[NT -> left : Feature]
	[NT -> spock-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> spock : Folder]
						[NT -> lang : Folder]
							[NT -> Unroll.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package spock.lang;" compose:Replacement merge: Default]
									[T -> groovy.lang.Closure{ImportPackage} : ImportDeclaration "import groovy.lang.Closure;" compose:Replacement merge: Default]
									[T -> java.lang.annotation.* : ImportDeclaration "import java.lang.annotation.*;" compose:Replacement merge: Default]
									[NT -> Unroll : AnnotationTypeDeclaration]
										[T -> - : Modifiers "@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public" compose:Replacement merge: SemanticConflict]
										[T -> Unroll : Id "Unroll" compose:Replacement merge: Default]
										[T -> value : AnnotationMethodDecl "Class<? extends Closure> value() default Closure.class;" compose:Replacement merge: SemanticConflict]
[NT -> base : Feature]
	[NT -> spock-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> spock : Folder]
						[NT -> lang : Folder]
							[NT -> Unroll.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package spock.lang;" compose:Replacement merge: Default]
									[T -> java.lang.annotation.* : ImportDeclaration "import java.lang.annotation.*;" compose:Replacement merge: Default]
									[NT -> Unroll : AnnotationTypeDeclaration]
										[T -> - : Modifiers "@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public" compose:Replacement merge: SemanticConflict]
										[T -> Unroll : Id "Unroll" compose:Replacement merge: Default]
										[T -> value : AnnotationMethodDecl "String value() default "";" compose:Replacement merge: SemanticConflict]
[NT -> right : Feature]
	[NT -> spock-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> spock : Folder]
						[NT -> lang : Folder]
							[NT -> Unroll.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package spock.lang;" compose:Replacement merge: Default]
									[T -> java.lang.annotation.* : ImportDeclaration "import java.lang.annotation.*;" compose:Replacement merge: Default]
									[NT -> Unroll : AnnotationTypeDeclaration]
										[T -> - : Modifiers "@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public" compose:Replacement merge: SemanticConflict]
										[T -> Unroll : Id "Unroll" compose:Replacement merge: Default]
										[T -> value : AnnotationMethodDecl "String value() default "#featureName[#iterationCount]";" compose:Replacement merge: SemanticConflict]
[NT -> left : Feature]
	[NT -> spock-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> spock : Folder]
						[NT -> lang : Folder]
							[NT -> Unroll.java.merge : .java.merge-File]
								[T -> Unroll.java : .java-Content "package spock.lang;  import groovy.lang.Closure;  import java.lang.annotation.*;  /**  * Indicates that iterations of a data-driven feature should be made visible  * as separate features to the outside world (IDEs, reports, etc.). By default,  * the name of an iteration is the feature's name followed by a consecutive number.  * This can be changed by providing a naming pattern after @Unroll. A naming pattern  * is a closure returning a GString. Data variables may be referenced with the  * usual GString '$' notation. Example:  *  * <pre>  * &#64;Unroll({ "$name should have length $length" })  * def "name length"() {  *   expect:  *   name.size() == length  *  *   where:  *   name << ["Kirk", "Spock", "Scotty"]  *   length << [4, 5, 6]  * }  * </pre>  *  * @author Peter Niederwieser  */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Unroll {   // to ensure best possible tool support, we use the same default naming   // scheme as Junit's @Parameterized   Class<? extends Closure> value() default Closure.class; } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> spock-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> spock : Folder]
						[NT -> lang : Folder]
							[NT -> Unroll.java.merge : .java.merge-File]
								[T -> Unroll.java : .java-Content "package spock.lang;  import java.lang.annotation.*;  /**  * Indicates that iterations of a data-driven feature should be made visible  * as separate features to the outside world (IDEs, reports, etc.). By default,  * the name of an iteration is the feature's name followed by a consecutive number.  * This can be changed by providing a naming pattern after @Unroll. A naming pattern  * may refer to data variables by prepending their names with #. Example:  *  * <pre>  * &#64;Unroll("#name should have length #length")  * def "name length"() {  *   expect:  *   name.size() == length  *  *   where:  *   name << ["Kirk", "Spock", "Scotty"]  *   length << [4, 5, 6]  * }  * </pre>  *  * @author Peter Niederwieser  */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Unroll {   // to ensure best possible tool support, we use the same default naming   // scheme as JUnit's @Parameterized   String value() default ""; } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> spock-core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> spock : Folder]
						[NT -> lang : Folder]
							[NT -> Unroll.java.merge : .java.merge-File]
								[T -> Unroll.java : .java-Content "package spock.lang;  import java.lang.annotation.*;  /**  * Indicates that iterations of a data-driven feature should be made visible  * as separate features to the outside world (IDEs, reports, etc.). By default,  * the name of an iteration is the feature's name followed by a consecutive number.  * This can be changed by providing a naming pattern after @Unroll. A naming pattern  * may refer to data variables by prepending their names with #. Example:  *  * <pre>  * &#64;Unroll("#name should have length #length")  * def "name length"() {  *   expect:  *   name.size() == length  *  *   where:  *   name << ["Kirk", "Spock", "Scotty"]  *   length << [4, 5, 6]  * }  * </pre>  *  * @author Peter Niederwieser  */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Unroll {   // to ensure best possible tool support, we use the same default naming   // scheme as JUnit's @Parameterized   String value() default "#featureName[#iterationCount]"; } " compose:StringConcatenation merge: LineBased]
