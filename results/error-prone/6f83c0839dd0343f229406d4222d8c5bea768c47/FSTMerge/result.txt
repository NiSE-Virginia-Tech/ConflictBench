Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/.idea/projectCodeStyle.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/.idea/vcs.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/.idea/copyright/Google.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/.idea/copyright/profiles_settings.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/core/src/main/java/com/google/errorprone/ErrorProneScanner.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/core/src/main/java/com/google/errorprone/ErrorProneScanner.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/.idea/projectCodeStyle.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/.idea/vcs.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/.idea/copyright/Google.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/.idea/copyright/profiles_settings.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/core/src/main/java/com/google/errorprone/ErrorProneScanner.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/core/src/main/java/com/google/errorprone/ErrorProneScanner.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/.idea/projectCodeStyle.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/.idea/vcs.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/.idea/copyright/Google.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/.idea/copyright/profiles_settings.xml
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/core/src/main/java/com/google/errorprone/ErrorProneScanner.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/core/src/main/java/com/google/errorprone/ErrorProneScanner.java
[NT -> left : Feature]
	[NT -> .idea : Folder]
		[NT -> projectCodeStyle.xml : XML-File]
			[NT ->  : project]
				[T -> version : attribute "4" compose:Replacement merge: Default]
				[NT -> CodeStyleSettingsManager : component]
					[T -> name : attribute "CodeStyleSettingsManager" compose:Replacement merge: Default]
					[T -> name : attribute "CodeStyleSettingsManager" compose:Replacement merge: Default]
					[NT -> PER_PROJECT_SETTINGS : option]
						[T -> name : attribute "PER_PROJECT_SETTINGS" compose:Replacement merge: Default]
						[T -> name : attribute "PER_PROJECT_SETTINGS" compose:Replacement merge: Default]
						[NT ->  : value]
							[NT ->  : ADDITIONAL_INDENT_OPTIONS]
								[T -> fileType : attribute "java" compose:Replacement merge: Default]
								[NT -> INDENT_SIZE : option]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> CONTINUATION_INDENT_SIZE : option]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "8" compose:Replacement merge: Default]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> TAB_SIZE : option]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
								[NT -> USE_TAB_CHARACTER : option]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
								[NT -> SMART_TABS : option]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_SIZE : option]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "0" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_ABSOLUTE : option]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
								[NT -> USE_RELATIVE_INDENTS : option]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
							[NT ->  : ADDITIONAL_INDENT_OPTIONS]
								[T -> fileType : attribute "xml" compose:Replacement merge: Default]
								[NT -> INDENT_SIZE : option]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> CONTINUATION_INDENT_SIZE : option]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "8" compose:Replacement merge: Default]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> TAB_SIZE : option]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
								[NT -> USE_TAB_CHARACTER : option]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
								[NT -> SMART_TABS : option]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_SIZE : option]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "0" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_ABSOLUTE : option]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
								[NT -> USE_RELATIVE_INDENTS : option]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
		[NT -> vcs.xml : XML-File]
			[NT ->  : project]
				[T -> version : attribute "4" compose:Replacement merge: Default]
				[NT -> VcsDirectoryMappings : component]
					[T -> name : attribute "VcsDirectoryMappings" compose:Replacement merge: Default]
					[T -> name : attribute "VcsDirectoryMappings" compose:Replacement merge: Default]
					[NT ->  : mapping]
						[T -> directory : attribute "" compose:Replacement merge: Default]
						[T -> vcs : attribute "Git" compose:Replacement merge: Default]
		[NT -> copyright : Folder]
			[NT -> Google.xml : XML-File]
				[NT -> CopyrightManager : component]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[NT ->  : copyright]
						[NT -> notice : option]
							[T -> name : attribute "notice" compose:Replacement merge: Default]
							[T -> value : attribute "Copyright &#36;today.year Google Inc. All Rights Reserved.  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License." compose:Replacement merge: Default]
							[T -> name : attribute "notice" compose:Replacement merge: Default]
						[NT -> keyword : option]
							[T -> name : attribute "keyword" compose:Replacement merge: Default]
							[T -> value : attribute "Copyright" compose:Replacement merge: Default]
							[T -> name : attribute "keyword" compose:Replacement merge: Default]
						[NT -> allowReplaceKeyword : option]
							[T -> name : attribute "allowReplaceKeyword" compose:Replacement merge: Default]
							[T -> value : attribute "" compose:Replacement merge: Default]
							[T -> name : attribute "allowReplaceKeyword" compose:Replacement merge: Default]
						[NT -> myName : option]
							[T -> name : attribute "myName" compose:Replacement merge: Default]
							[T -> value : attribute "Google" compose:Replacement merge: Default]
							[T -> name : attribute "myName" compose:Replacement merge: Default]
						[NT -> myLocal : option]
							[T -> name : attribute "myLocal" compose:Replacement merge: Default]
							[T -> value : attribute "true" compose:Replacement merge: Default]
							[T -> name : attribute "myLocal" compose:Replacement merge: Default]
			[NT -> profiles_settings.xml : XML-File]
				[NT -> CopyrightManager : component]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[NT ->  : settings]
						[T -> default : attribute "Google" compose:Replacement merge: Default]
						[NT ->  : module2copyright]
							[NT ->  : element]
								[T -> copyright : attribute "Google" compose:Replacement merge: Default]
								[T -> module : attribute "All" compose:Replacement merge: Default]
						[NT -> XML : LanguageOptions]
							[T -> name : attribute "XML" compose:Replacement merge: Default]
							[T -> name : attribute "XML" compose:Replacement merge: Default]
							[NT -> fileTypeOverride : option]
								[T -> name : attribute "fileTypeOverride" compose:Replacement merge: Default]
								[T -> value : attribute "3" compose:Replacement merge: Default]
								[T -> name : attribute "fileTypeOverride" compose:Replacement merge: Default]
							[NT -> prefixLines : option]
								[T -> name : attribute "prefixLines" compose:Replacement merge: Default]
								[T -> value : attribute "false" compose:Replacement merge: Default]
								[T -> name : attribute "prefixLines" compose:Replacement merge: Default]
[NT -> base : Feature]
	[NT -> .idea : Folder]
		[NT -> projectCodeStyle.xml : XML-File]
			[NT ->  : project]
				[T -> version : attribute "4" compose:Replacement merge: Default]
				[NT -> CodeStyleSettingsManager : component]
					[T -> name : attribute "CodeStyleSettingsManager" compose:Replacement merge: Default]
					[T -> name : attribute "CodeStyleSettingsManager" compose:Replacement merge: Default]
					[NT -> PER_PROJECT_SETTINGS : option]
						[T -> name : attribute "PER_PROJECT_SETTINGS" compose:Replacement merge: Default]
						[T -> name : attribute "PER_PROJECT_SETTINGS" compose:Replacement merge: Default]
						[NT ->  : value]
							[NT ->  : ADDITIONAL_INDENT_OPTIONS]
								[T -> fileType : attribute "java" compose:Replacement merge: Default]
								[NT -> INDENT_SIZE : option]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> CONTINUATION_INDENT_SIZE : option]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "8" compose:Replacement merge: Default]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> TAB_SIZE : option]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
								[NT -> USE_TAB_CHARACTER : option]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
								[NT -> SMART_TABS : option]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_SIZE : option]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "0" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_ABSOLUTE : option]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
								[NT -> USE_RELATIVE_INDENTS : option]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
							[NT ->  : ADDITIONAL_INDENT_OPTIONS]
								[T -> fileType : attribute "xml" compose:Replacement merge: Default]
								[NT -> INDENT_SIZE : option]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> CONTINUATION_INDENT_SIZE : option]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "8" compose:Replacement merge: Default]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> TAB_SIZE : option]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
								[NT -> USE_TAB_CHARACTER : option]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
								[NT -> SMART_TABS : option]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_SIZE : option]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "0" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_ABSOLUTE : option]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
								[NT -> USE_RELATIVE_INDENTS : option]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
		[NT -> vcs.xml : XML-File]
			[NT ->  : project]
				[T -> version : attribute "4" compose:Replacement merge: Default]
				[NT -> VcsDirectoryMappings : component]
					[T -> name : attribute "VcsDirectoryMappings" compose:Replacement merge: Default]
					[T -> name : attribute "VcsDirectoryMappings" compose:Replacement merge: Default]
					[NT ->  : mapping]
						[T -> directory : attribute "" compose:Replacement merge: Default]
						[T -> vcs : attribute "Git" compose:Replacement merge: Default]
		[NT -> copyright : Folder]
			[NT -> Google.xml : XML-File]
				[NT -> CopyrightManager : component]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[NT ->  : copyright]
						[NT -> notice : option]
							[T -> name : attribute "notice" compose:Replacement merge: Default]
							[T -> value : attribute "Copyright &#36;today.year Google Inc. All Rights Reserved.  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License." compose:Replacement merge: Default]
							[T -> name : attribute "notice" compose:Replacement merge: Default]
						[NT -> keyword : option]
							[T -> name : attribute "keyword" compose:Replacement merge: Default]
							[T -> value : attribute "Copyright" compose:Replacement merge: Default]
							[T -> name : attribute "keyword" compose:Replacement merge: Default]
						[NT -> allowReplaceKeyword : option]
							[T -> name : attribute "allowReplaceKeyword" compose:Replacement merge: Default]
							[T -> value : attribute "" compose:Replacement merge: Default]
							[T -> name : attribute "allowReplaceKeyword" compose:Replacement merge: Default]
						[NT -> myName : option]
							[T -> name : attribute "myName" compose:Replacement merge: Default]
							[T -> value : attribute "Google" compose:Replacement merge: Default]
							[T -> name : attribute "myName" compose:Replacement merge: Default]
						[NT -> myLocal : option]
							[T -> name : attribute "myLocal" compose:Replacement merge: Default]
							[T -> value : attribute "true" compose:Replacement merge: Default]
							[T -> name : attribute "myLocal" compose:Replacement merge: Default]
			[NT -> profiles_settings.xml : XML-File]
				[NT -> CopyrightManager : component]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[NT ->  : settings]
						[T -> default : attribute "Google" compose:Replacement merge: Default]
						[NT ->  : module2copyright]
							[NT ->  : element]
								[T -> copyright : attribute "Google" compose:Replacement merge: Default]
								[T -> module : attribute "All" compose:Replacement merge: Default]
						[NT -> XML : LanguageOptions]
							[T -> name : attribute "XML" compose:Replacement merge: Default]
							[T -> name : attribute "XML" compose:Replacement merge: Default]
							[NT -> fileTypeOverride : option]
								[T -> name : attribute "fileTypeOverride" compose:Replacement merge: Default]
								[T -> value : attribute "3" compose:Replacement merge: Default]
								[T -> name : attribute "fileTypeOverride" compose:Replacement merge: Default]
							[NT -> prefixLines : option]
								[T -> name : attribute "prefixLines" compose:Replacement merge: Default]
								[T -> value : attribute "false" compose:Replacement merge: Default]
								[T -> name : attribute "prefixLines" compose:Replacement merge: Default]
[NT -> right : Feature]
	[NT -> .idea : Folder]
		[NT -> projectCodeStyle.xml : XML-File]
			[NT ->  : project]
				[T -> version : attribute "4" compose:Replacement merge: Default]
				[NT -> CodeStyleSettingsManager : component]
					[T -> name : attribute "CodeStyleSettingsManager" compose:Replacement merge: Default]
					[T -> name : attribute "CodeStyleSettingsManager" compose:Replacement merge: Default]
					[NT -> PER_PROJECT_SETTINGS : option]
						[T -> name : attribute "PER_PROJECT_SETTINGS" compose:Replacement merge: Default]
						[T -> name : attribute "PER_PROJECT_SETTINGS" compose:Replacement merge: Default]
						[NT ->  : value]
							[NT ->  : ADDITIONAL_INDENT_OPTIONS]
								[T -> fileType : attribute "java" compose:Replacement merge: Default]
								[NT -> INDENT_SIZE : option]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> CONTINUATION_INDENT_SIZE : option]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "8" compose:Replacement merge: Default]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> TAB_SIZE : option]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
								[NT -> USE_TAB_CHARACTER : option]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
								[NT -> SMART_TABS : option]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_SIZE : option]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "0" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_ABSOLUTE : option]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
								[NT -> USE_RELATIVE_INDENTS : option]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
							[NT ->  : ADDITIONAL_INDENT_OPTIONS]
								[T -> fileType : attribute "xml" compose:Replacement merge: Default]
								[NT -> INDENT_SIZE : option]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> CONTINUATION_INDENT_SIZE : option]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "8" compose:Replacement merge: Default]
									[T -> name : attribute "CONTINUATION_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> TAB_SIZE : option]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "4" compose:Replacement merge: Default]
									[T -> name : attribute "TAB_SIZE" compose:Replacement merge: Default]
								[NT -> USE_TAB_CHARACTER : option]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_TAB_CHARACTER" compose:Replacement merge: Default]
								[NT -> SMART_TABS : option]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "SMART_TABS" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_SIZE : option]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
									[T -> value : attribute "0" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_SIZE" compose:Replacement merge: Default]
								[NT -> LABEL_INDENT_ABSOLUTE : option]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "LABEL_INDENT_ABSOLUTE" compose:Replacement merge: Default]
								[NT -> USE_RELATIVE_INDENTS : option]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
									[T -> value : attribute "false" compose:Replacement merge: Default]
									[T -> name : attribute "USE_RELATIVE_INDENTS" compose:Replacement merge: Default]
		[NT -> vcs.xml : XML-File]
			[NT ->  : project]
				[T -> version : attribute "4" compose:Replacement merge: Default]
				[NT -> VcsDirectoryMappings : component]
					[T -> name : attribute "VcsDirectoryMappings" compose:Replacement merge: Default]
					[T -> name : attribute "VcsDirectoryMappings" compose:Replacement merge: Default]
					[NT ->  : mapping]
						[T -> directory : attribute "" compose:Replacement merge: Default]
						[T -> vcs : attribute "Git" compose:Replacement merge: Default]
		[NT -> copyright : Folder]
			[NT -> Google.xml : XML-File]
				[NT -> CopyrightManager : component]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[NT ->  : copyright]
						[NT -> notice : option]
							[T -> name : attribute "notice" compose:Replacement merge: Default]
							[T -> value : attribute "Copyright &#36;today.year Google Inc. All Rights Reserved.  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License." compose:Replacement merge: Default]
							[T -> name : attribute "notice" compose:Replacement merge: Default]
						[NT -> keyword : option]
							[T -> name : attribute "keyword" compose:Replacement merge: Default]
							[T -> value : attribute "Copyright" compose:Replacement merge: Default]
							[T -> name : attribute "keyword" compose:Replacement merge: Default]
						[NT -> allowReplaceKeyword : option]
							[T -> name : attribute "allowReplaceKeyword" compose:Replacement merge: Default]
							[T -> value : attribute "" compose:Replacement merge: Default]
							[T -> name : attribute "allowReplaceKeyword" compose:Replacement merge: Default]
						[NT -> myName : option]
							[T -> name : attribute "myName" compose:Replacement merge: Default]
							[T -> value : attribute "Google" compose:Replacement merge: Default]
							[T -> name : attribute "myName" compose:Replacement merge: Default]
						[NT -> myLocal : option]
							[T -> name : attribute "myLocal" compose:Replacement merge: Default]
							[T -> value : attribute "true" compose:Replacement merge: Default]
							[T -> name : attribute "myLocal" compose:Replacement merge: Default]
			[NT -> profiles_settings.xml : XML-File]
				[NT -> CopyrightManager : component]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[T -> name : attribute "CopyrightManager" compose:Replacement merge: Default]
					[NT ->  : settings]
						[T -> default : attribute "Google" compose:Replacement merge: Default]
						[NT ->  : module2copyright]
							[NT ->  : element]
								[T -> copyright : attribute "Google" compose:Replacement merge: Default]
								[T -> module : attribute "All" compose:Replacement merge: Default]
						[NT -> XML : LanguageOptions]
							[T -> name : attribute "XML" compose:Replacement merge: Default]
							[T -> name : attribute "XML" compose:Replacement merge: Default]
							[NT -> fileTypeOverride : option]
								[T -> name : attribute "fileTypeOverride" compose:Replacement merge: Default]
								[T -> value : attribute "3" compose:Replacement merge: Default]
								[T -> name : attribute "fileTypeOverride" compose:Replacement merge: Default]
							[NT -> prefixLines : option]
								[T -> name : attribute "prefixLines" compose:Replacement merge: Default]
								[T -> value : attribute "false" compose:Replacement merge: Default]
								[T -> name : attribute "prefixLines" compose:Replacement merge: Default]
[NT -> left : Feature]
	[NT -> core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> google : Folder]
							[NT -> errorprone : Folder]
								[NT -> ErrorProneScanner.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.google.errorprone;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.BugPattern.MaturityLevel.MATURE{ImportPackage} : ImportDeclaration "import static com.google.errorprone.BugPattern.MaturityLevel.MATURE;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.bugpatterns.BugChecker.* : ImportDeclaration "import static com.google.errorprone.bugpatterns.BugChecker.*;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.bugpatterns.* : ImportDeclaration "import com.google.errorprone.bugpatterns.*;" compose:Replacement merge: Default]
										[T -> com.sun.source.tree.* : ImportDeclaration "import com.sun.source.tree.*;" compose:Replacement merge: Default]
										[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[NT -> ErrorProneScanner : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> ErrorProneScanner : Id "ErrorProneScanner" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends Scanner" compose:Replacement merge: Default]
											[NT -> EnabledPredicate : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> EnabledPredicate : Id "EnabledPredicate" compose:Replacement merge: Default]
												[T -> isEnabled(Class<?extendsBugChecker>-Class<?extendsBugChecker>-BugPattern-BugPattern) : MethodDecl "boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation);" compose:Replacement merge: LineBased]
												[T -> DEFAULT_CHECKS : FieldDecl "public static final EnabledPredicate DEFAULT_CHECKS = new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> checkerClass, BugPattern annotation) {         return annotation.maturity() == MATURE;       }     };" compose:Replacement merge: SemanticConflict]
											[T -> forMatcher(Class<?>-Class<?>) : MethodDecl "public static Scanner forMatcher(final Class<?> checkerClass) {     return new ErrorProneScanner(new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation) {         return check.equals(checkerClass);       }     });   }" compose:Replacement merge: LineBased]
											[T -> ALL_CHECKERS : FieldDecl "private static final List<? extends Class<? extends BugChecker>> ALL_CHECKERS = Arrays.asList(       SelfEquals.class,       OrderingFrom.class,       PreconditionsCheckNotNull.class,       PreconditionsExpensiveString.class,       PreconditionsCheckNotNullPrimitive.class,       CollectionIncompatibleType.class,       ArrayEquals.class,       ArrayToString.class,       ReturnValueIgnored.class,       NonRuntimeAnnotation.class,       InvalidPatternSyntax.class,       ModifyingCollectionWithItself.class,       PreconditionsTooManyArgs.class,       CheckReturnValue.class,       DeadException.class,       InjectAssistedInjectAndInjectOnConstructors.class,       InjectMoreThanOneQualifier.class,       InjectMoreThanOneScopeAnnotationOnClass.class,       InjectScopeAnnotationOnInterfaceOrAbstractClass.class,       FallThroughSuppression.class,       SuppressWarningsDeprecated.class,       EmptyIfStatement.class,       EmptyStatement.class,       InvalidNumericEquality.class,       InvalidStringEquality.class,       SelfEquality.class,       BadShiftAmount.class,       ArrayToStringConcatenation.class,       ComparisonOutOfRange.class,       SelfAssignment.class,       GuiceAssistedParameters.class,       CovariantEquals.class,       JUnit4TestNotRun.class,       WrongParameterPackage.class,       LongLiteralLowerCaseSuffix.class,       UnneededConditionalOperator.class,       ArrayToStringCompoundAssignment.class,       InjectScopeOrQualifierAnnotationRetention.class,       InjectInvalidTargetingOnScopingAnnotation.class,       GuiceAssistedInjectScoping.class,       InjectMoreThanOneInjectableConstructor.class   );" compose:Replacement merge: SemanticConflict]
											[T -> ErrorProneScanner(EnabledPredicate-EnabledPredicate) : ConstructorDecl "@SuppressWarnings("unchecked")   public ErrorProneScanner(EnabledPredicate predicate) {     try {       for (final Class<? extends BugChecker> checkerClass: ALL_CHECKERS) {         if (predicate.isEnabled(checkerClass, checkerClass.getAnnotation(BugPattern.class))) {           BugChecker checker = checkerClass.newInstance();           registerNodeTypes(checker);         }       }     } catch (Exception e) {       throw new RuntimeException("Could not reflectively create error prone matchers", e);     }   }" compose:Replacement merge: LineBased]
											[T -> ErrorProneScanner(BugChecker-BugChecker) : ConstructorDecl "public ErrorProneScanner(BugChecker checker) {     registerNodeTypes(checker);   }" compose:Replacement merge: LineBased]
											[T -> methodInvocationMatchers : FieldDecl "private final List<MethodInvocationTreeMatcher> methodInvocationMatchers =       new ArrayList<MethodInvocationTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> newClassMatchers : FieldDecl "private final List<NewClassTreeMatcher> newClassMatchers =       new ArrayList<NewClassTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> annotationMatchers : FieldDecl "private final List<AnnotationTreeMatcher> annotationMatchers =       new ArrayList<AnnotationTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> emptyStatementMatchers : FieldDecl "private final List<EmptyStatementTreeMatcher> emptyStatementMatchers =       new ArrayList<EmptyStatementTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> assignmentMatchers : FieldDecl "private final List<AssignmentTreeMatcher> assignmentMatchers =       new ArrayList<AssignmentTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> variableMatchers : FieldDecl "private final List<VariableTreeMatcher> variableMatchers =       new ArrayList<VariableTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> methodMatchers : FieldDecl "private final List<MethodTreeMatcher> methodMatchers =       new ArrayList<MethodTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> literalMatchers : FieldDecl "private final List<LiteralTreeMatcher> literalMatchers =       new ArrayList<LiteralTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> conditionalExpressionMatchers : FieldDecl "private final List<ConditionalExpressionTreeMatcher> conditionalExpressionMatchers =       new ArrayList<ConditionalExpressionTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> binaryExpressionMatchers : FieldDecl "private final List<BinaryTreeMatcher> binaryExpressionMatchers =       new ArrayList<BinaryTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> compoundAssignmentMatchers : FieldDecl "private final List<CompoundAssignmentTreeMatcher> compoundAssignmentMatchers =       new ArrayList<CompoundAssignmentTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> classMatchers : FieldDecl "private final List<ClassTreeMatcher> classMatchers =       new ArrayList<ClassTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> registerNodeTypes(BugChecker-BugChecker) : MethodDecl "private void registerNodeTypes(BugChecker checker) {     if (checker instanceof MethodInvocationTreeMatcher)       this.methodInvocationMatchers.add((MethodInvocationTreeMatcher) checker);     if (checker instanceof NewClassTreeMatcher)       this.newClassMatchers.add((NewClassTreeMatcher) checker);     if (checker instanceof AnnotationTreeMatcher)       this.annotationMatchers.add((AnnotationTreeMatcher) checker);     if (checker instanceof EmptyStatementTreeMatcher)       this.emptyStatementMatchers.add((EmptyStatementTreeMatcher) checker);     if (checker instanceof AssignmentTreeMatcher)       this.assignmentMatchers.add((AssignmentTreeMatcher) checker);     if (checker instanceof VariableTreeMatcher)       this.variableMatchers.add((VariableTreeMatcher) checker);     if (checker instanceof MethodTreeMatcher)       this.methodMatchers.add((MethodTreeMatcher) checker);     if (checker instanceof LiteralTreeMatcher)       this.literalMatchers.add((LiteralTreeMatcher) checker);     if (checker instanceof ConditionalExpressionTreeMatcher)       this.conditionalExpressionMatchers.add((ConditionalExpressionTreeMatcher) checker);     if (checker instanceof BinaryTreeMatcher)       this.binaryExpressionMatchers.add((BinaryTreeMatcher) checker);     if (checker instanceof CompoundAssignmentTreeMatcher)       this.compoundAssignmentMatchers.add((CompoundAssignmentTreeMatcher) checker);     if (checker instanceof ClassTreeMatcher)       this.classMatchers.add((ClassTreeMatcher) checker);   }" compose:Replacement merge: LineBased]
											[T -> visitMethodInvocation(MethodInvocationTree-MethodInvocationTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitMethodInvocation(       MethodInvocationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodInvocationTreeMatcher matcher : methodInvocationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethodInvocation(tree, state), tree, state);     }     return super.visitMethodInvocation(tree, state);   }" compose:Replacement merge: LineBased]
											[T -> visitBinary(BinaryTree-BinaryTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitBinary(BinaryTree tree,  VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (BinaryTreeMatcher matcher : binaryExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchBinary(tree, state), tree, state);     }     return super.visitBinary(tree, state);   }" compose:Replacement merge: LineBased]
											[T -> visitNewClass(NewClassTree-NewClassTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitNewClass(NewClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (NewClassTreeMatcher matcher : newClassMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchNewClass(tree, state), tree, state);     }     return super.visitNewClass(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitAnnotation(AnnotationTree-AnnotationTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitAnnotation(AnnotationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AnnotationTreeMatcher matcher : annotationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAnnotation(tree, state), tree, state);     }     return super.visitAnnotation(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitEmptyStatement(EmptyStatementTree-EmptyStatementTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitEmptyStatement(       EmptyStatementTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (EmptyStatementTreeMatcher matcher : emptyStatementMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchEmptyStatement(tree, state), tree, state);     }     return super.visitEmptyStatement(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitAssignment(AssignmentTree-AssignmentTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitAssignment(AssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AssignmentTreeMatcher matcher : assignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAssignment(tree, state), tree, state);     }     return super.visitAssignment(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitVariable(VariableTree-VariableTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitVariable(VariableTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (VariableTreeMatcher matcher : variableMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchVariable(tree, state), tree, state);     }     return super.visitVariable(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitMethod(MethodTree-MethodTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitMethod(MethodTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodTreeMatcher matcher : methodMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethod(tree, state), tree, state);     }     return super.visitMethod(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitLiteral(LiteralTree-LiteralTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitLiteral(LiteralTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (LiteralTreeMatcher matcher : literalMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchLiteral(tree, state), tree, state);     }     return super.visitLiteral(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitConditionalExpression(ConditionalExpressionTree-ConditionalExpressionTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitConditionalExpression(       ConditionalExpressionTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ConditionalExpressionTreeMatcher matcher : conditionalExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchConditionalExpression(tree, state), tree, state);     }     return super.visitConditionalExpression(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitCompoundAssignment(CompoundAssignmentTree-CompoundAssignmentTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitCompoundAssignment(CompoundAssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (CompoundAssignmentTreeMatcher matcher : compoundAssignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchCompoundAssignment(tree, state), tree, state);     }     return super.visitCompoundAssignment(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitClass(ClassTree-ClassTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitClass(ClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ClassTreeMatcher matcher : classMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchClass(tree, state), tree, state);     }     return super.visitClass(tree, visitorState);   }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> google : Folder]
							[NT -> errorprone : Folder]
								[NT -> ErrorProneScanner.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.google.errorprone;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.BugPattern.MaturityLevel.MATURE{ImportPackage} : ImportDeclaration "import static com.google.errorprone.BugPattern.MaturityLevel.MATURE;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.bugpatterns.BugChecker.* : ImportDeclaration "import static com.google.errorprone.bugpatterns.BugChecker.*;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.bugpatterns.* : ImportDeclaration "import com.google.errorprone.bugpatterns.*;" compose:Replacement merge: Default]
										[T -> com.sun.source.tree.* : ImportDeclaration "import com.sun.source.tree.*;" compose:Replacement merge: Default]
										[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[NT -> ErrorProneScanner : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> ErrorProneScanner : Id "ErrorProneScanner" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends Scanner" compose:Replacement merge: Default]
											[NT -> EnabledPredicate : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> EnabledPredicate : Id "EnabledPredicate" compose:Replacement merge: Default]
												[T -> isEnabled(Class<?extendsBugChecker>-Class<?extendsBugChecker>-BugPattern-BugPattern) : MethodDecl "boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation);" compose:Replacement merge: LineBased]
												[T -> DEFAULT_CHECKS : FieldDecl "public static final EnabledPredicate DEFAULT_CHECKS = new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> checkerClass, BugPattern annotation) {         return annotation.maturity() == MATURE;       }     };" compose:Replacement merge: SemanticConflict]
											[T -> forMatcher(Class<?>-Class<?>) : MethodDecl "public static Scanner forMatcher(final Class<?> checkerClass) {     return new ErrorProneScanner(new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation) {         return check.equals(checkerClass);       }     });   }" compose:Replacement merge: LineBased]
											[T -> ALL_CHECKERS : FieldDecl "private static final List<? extends Class<? extends BugChecker>> ALL_CHECKERS = Arrays.asList(       SelfEquals.class,       OrderingFrom.class,       PreconditionsCheckNotNull.class,       PreconditionsExpensiveString.class,       PreconditionsCheckNotNullPrimitive.class,       CollectionIncompatibleType.class,       ArrayEquals.class,       ArrayToString.class,       ReturnValueIgnored.class,       NonRuntimeAnnotation.class,       InvalidPatternSyntax.class,       ModifyingCollectionWithItself.class,       PreconditionsTooManyArgs.class,       CheckReturnValue.class,       DeadException.class,       InjectAssistedInjectAndInjectOnConstructors.class,       InjectMoreThanOneQualifier.class,       InjectMoreThanOneScopeAnnotationOnClass.class,       InjectScopeAnnotationOnInterfaceOrAbstractClass.class,       FallThroughSuppression.class,       SuppressWarningsDeprecated.class,       EmptyIfStatement.class,       EmptyStatement.class,       InvalidNumericEquality.class,       InvalidStringEquality.class,       SelfEquality.class,       BadShiftAmount.class,       ArrayToStringConcatenation.class,       ComparisonOutOfRange.class,       SelfAssignment.class,       GuiceAssistedParameters.class,       CovariantEquals.class,       JUnit4TestNotRun.class,       WrongParameterPackage.class,       LongLiteralLowerCaseSuffix.class,       UnneededConditionalOperator.class,       ArrayToStringCompoundAssignment.class,       InjectScopeOrQualifierAnnotationRetention.class,       InjectInvalidTargetingOnScopingAnnotation.class,       GuiceAssistedInjectScoping.class   );" compose:Replacement merge: SemanticConflict]
											[T -> ErrorProneScanner(EnabledPredicate-EnabledPredicate) : ConstructorDecl "@SuppressWarnings("unchecked")   public ErrorProneScanner(EnabledPredicate predicate) {     try {       for (final Class<? extends BugChecker> checkerClass: ALL_CHECKERS) {         if (predicate.isEnabled(checkerClass, checkerClass.getAnnotation(BugPattern.class))) {           BugChecker checker = checkerClass.newInstance();           registerNodeTypes(checker);         }       }     } catch (Exception e) {       throw new RuntimeException("Could not reflectively create error prone matchers", e);     }   }" compose:Replacement merge: LineBased]
											[T -> ErrorProneScanner(BugChecker-BugChecker) : ConstructorDecl "public ErrorProneScanner(BugChecker checker) {     registerNodeTypes(checker);   }" compose:Replacement merge: LineBased]
											[T -> methodInvocationMatchers : FieldDecl "private final List<MethodInvocationTreeMatcher> methodInvocationMatchers =       new ArrayList<MethodInvocationTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> newClassMatchers : FieldDecl "private final List<NewClassTreeMatcher> newClassMatchers =       new ArrayList<NewClassTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> annotationMatchers : FieldDecl "private final List<AnnotationTreeMatcher> annotationMatchers =       new ArrayList<AnnotationTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> emptyStatementMatchers : FieldDecl "private final List<EmptyStatementTreeMatcher> emptyStatementMatchers =       new ArrayList<EmptyStatementTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> assignmentMatchers : FieldDecl "private final List<AssignmentTreeMatcher> assignmentMatchers =       new ArrayList<AssignmentTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> variableMatchers : FieldDecl "private final List<VariableTreeMatcher> variableMatchers =       new ArrayList<VariableTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> methodMatchers : FieldDecl "private final List<MethodTreeMatcher> methodMatchers =       new ArrayList<MethodTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> literalMatchers : FieldDecl "private final List<LiteralTreeMatcher> literalMatchers =       new ArrayList<LiteralTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> conditionalExpressionMatchers : FieldDecl "private final List<ConditionalExpressionTreeMatcher> conditionalExpressionMatchers =       new ArrayList<ConditionalExpressionTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> binaryExpressionMatchers : FieldDecl "private final List<BinaryTreeMatcher> binaryExpressionMatchers =       new ArrayList<BinaryTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> compoundAssignmentMatchers : FieldDecl "private final List<CompoundAssignmentTreeMatcher> compoundAssignmentMatchers =       new ArrayList<CompoundAssignmentTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> classMatchers : FieldDecl "private final List<ClassTreeMatcher> classMatchers =       new ArrayList<ClassTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> registerNodeTypes(BugChecker-BugChecker) : MethodDecl "private void registerNodeTypes(BugChecker checker) {     if (checker instanceof MethodInvocationTreeMatcher)       this.methodInvocationMatchers.add((MethodInvocationTreeMatcher) checker);     if (checker instanceof NewClassTreeMatcher)       this.newClassMatchers.add((NewClassTreeMatcher) checker);     if (checker instanceof AnnotationTreeMatcher)       this.annotationMatchers.add((AnnotationTreeMatcher) checker);     if (checker instanceof EmptyStatementTreeMatcher)       this.emptyStatementMatchers.add((EmptyStatementTreeMatcher) checker);     if (checker instanceof AssignmentTreeMatcher)       this.assignmentMatchers.add((AssignmentTreeMatcher) checker);     if (checker instanceof VariableTreeMatcher)       this.variableMatchers.add((VariableTreeMatcher) checker);     if (checker instanceof MethodTreeMatcher)       this.methodMatchers.add((MethodTreeMatcher) checker);     if (checker instanceof LiteralTreeMatcher)       this.literalMatchers.add((LiteralTreeMatcher) checker);     if (checker instanceof ConditionalExpressionTreeMatcher)       this.conditionalExpressionMatchers.add((ConditionalExpressionTreeMatcher) checker);     if (checker instanceof BinaryTreeMatcher)       this.binaryExpressionMatchers.add((BinaryTreeMatcher) checker);     if (checker instanceof CompoundAssignmentTreeMatcher)       this.compoundAssignmentMatchers.add((CompoundAssignmentTreeMatcher) checker);     if (checker instanceof ClassTreeMatcher)       this.classMatchers.add((ClassTreeMatcher) checker);   }" compose:Replacement merge: LineBased]
											[T -> visitMethodInvocation(MethodInvocationTree-MethodInvocationTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitMethodInvocation(       MethodInvocationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodInvocationTreeMatcher matcher : methodInvocationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethodInvocation(tree, state), tree, state);     }     return super.visitMethodInvocation(tree, state);   }" compose:Replacement merge: LineBased]
											[T -> visitBinary(BinaryTree-BinaryTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitBinary(BinaryTree tree,  VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (BinaryTreeMatcher matcher : binaryExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchBinary(tree, state), tree, state);     }     return super.visitBinary(tree, state);   }" compose:Replacement merge: LineBased]
											[T -> visitNewClass(NewClassTree-NewClassTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitNewClass(NewClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (NewClassTreeMatcher matcher : newClassMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchNewClass(tree, state), tree, state);     }     return super.visitNewClass(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitAnnotation(AnnotationTree-AnnotationTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitAnnotation(AnnotationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AnnotationTreeMatcher matcher : annotationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAnnotation(tree, state), tree, state);     }     return super.visitAnnotation(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitEmptyStatement(EmptyStatementTree-EmptyStatementTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitEmptyStatement(       EmptyStatementTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (EmptyStatementTreeMatcher matcher : emptyStatementMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchEmptyStatement(tree, state), tree, state);     }     return super.visitEmptyStatement(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitAssignment(AssignmentTree-AssignmentTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitAssignment(AssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AssignmentTreeMatcher matcher : assignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAssignment(tree, state), tree, state);     }     return super.visitAssignment(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitVariable(VariableTree-VariableTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitVariable(VariableTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (VariableTreeMatcher matcher : variableMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchVariable(tree, state), tree, state);     }     return super.visitVariable(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitMethod(MethodTree-MethodTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitMethod(MethodTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodTreeMatcher matcher : methodMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethod(tree, state), tree, state);     }     return super.visitMethod(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitLiteral(LiteralTree-LiteralTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitLiteral(LiteralTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (LiteralTreeMatcher matcher : literalMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchLiteral(tree, state), tree, state);     }     return super.visitLiteral(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitConditionalExpression(ConditionalExpressionTree-ConditionalExpressionTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitConditionalExpression(       ConditionalExpressionTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ConditionalExpressionTreeMatcher matcher : conditionalExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchConditionalExpression(tree, state), tree, state);     }     return super.visitConditionalExpression(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitCompoundAssignment(CompoundAssignmentTree-CompoundAssignmentTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitCompoundAssignment(CompoundAssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (CompoundAssignmentTreeMatcher matcher : compoundAssignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchCompoundAssignment(tree, state), tree, state);     }     return super.visitCompoundAssignment(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitClass(ClassTree-ClassTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitClass(ClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ClassTreeMatcher matcher : classMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchClass(tree, state), tree, state);     }     return super.visitClass(tree, visitorState);   }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> google : Folder]
							[NT -> errorprone : Folder]
								[NT -> ErrorProneScanner.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.google.errorprone;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.BugPattern.MaturityLevel.MATURE{ImportPackage} : ImportDeclaration "import static com.google.errorprone.BugPattern.MaturityLevel.MATURE;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.bugpatterns.BugChecker.* : ImportDeclaration "import static com.google.errorprone.bugpatterns.BugChecker.*;" compose:Replacement merge: Default]
										[T -> com.google.errorprone.bugpatterns.* : ImportDeclaration "import com.google.errorprone.bugpatterns.*;" compose:Replacement merge: Default]
										[T -> com.sun.source.tree.* : ImportDeclaration "import com.sun.source.tree.*;" compose:Replacement merge: Default]
										[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[NT -> ErrorProneScanner : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> ErrorProneScanner : Id "ErrorProneScanner" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends Scanner" compose:Replacement merge: Default]
											[NT -> EnabledPredicate : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> EnabledPredicate : Id "EnabledPredicate" compose:Replacement merge: Default]
												[T -> isEnabled(Class<?extendsBugChecker>-Class<?extendsBugChecker>-BugPattern-BugPattern) : MethodDecl "boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation);" compose:Replacement merge: LineBased]
												[T -> DEFAULT_CHECKS : FieldDecl "public static final EnabledPredicate DEFAULT_CHECKS = new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> checkerClass, BugPattern annotation) {         return annotation.maturity() == MATURE;       }     };" compose:Replacement merge: SemanticConflict]
											[T -> forMatcher(Class<?>-Class<?>) : MethodDecl "public static Scanner forMatcher(final Class<?> checkerClass) {     return new ErrorProneScanner(new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation) {         return check.equals(checkerClass);       }     });   }" compose:Replacement merge: LineBased]
											[T -> ALL_CHECKERS : FieldDecl "private static final List<? extends Class<? extends BugChecker>> ALL_CHECKERS = Arrays.asList(       SelfEquals.class,       OrderingFrom.class,       PreconditionsCheckNotNull.class,       PreconditionsExpensiveString.class,       PreconditionsCheckNotNullPrimitive.class,       CollectionIncompatibleType.class,       ArrayEquals.class,       ArrayToString.class,       ReturnValueIgnored.class,       NonRuntimeAnnotation.class,       InvalidPatternSyntax.class,       ModifyingCollectionWithItself.class,       PreconditionsTooManyArgs.class,       CheckReturnValue.class,       DeadException.class,       InjectAssistedInjectAndInjectOnConstructors.class,       InjectMoreThanOneQualifier.class,       InjectMoreThanOneScopeAnnotationOnClass.class,       InjectScopeAnnotationOnInterfaceOrAbstractClass.class,       FallThroughSuppression.class,       SuppressWarningsDeprecated.class,       EmptyIfStatement.class,       EmptyStatement.class,       InvalidNumericEquality.class,       InvalidStringEquality.class,       SelfEquality.class,       BadShiftAmount.class,       ArrayToStringConcatenation.class,       ComparisonOutOfRange.class,       SelfAssignment.class,       GuiceAssistedParameters.class,       CovariantEquals.class,       JUnit4TestNotRun.class,       WrongParameterPackage.class,       LongLiteralLowerCaseSuffix.class,       UnneededConditionalOperator.class,       ArrayToStringCompoundAssignment.class,       InjectScopeOrQualifierAnnotationRetention.class,       InjectInvalidTargetingOnScopingAnnotation.class,       GuiceAssistedInjectScoping.class,       InjectJavaxInjectOnFinalField.class,       GuiceInjectOnFinalField.class   );" compose:Replacement merge: SemanticConflict]
											[T -> ErrorProneScanner(EnabledPredicate-EnabledPredicate) : ConstructorDecl "@SuppressWarnings("unchecked")   public ErrorProneScanner(EnabledPredicate predicate) {     try {       for (final Class<? extends BugChecker> checkerClass: ALL_CHECKERS) {         if (predicate.isEnabled(checkerClass, checkerClass.getAnnotation(BugPattern.class))) {           BugChecker checker = checkerClass.newInstance();           registerNodeTypes(checker);         }       }     } catch (Exception e) {       throw new RuntimeException("Could not reflectively create error prone matchers", e);     }   }" compose:Replacement merge: LineBased]
											[T -> ErrorProneScanner(BugChecker-BugChecker) : ConstructorDecl "public ErrorProneScanner(BugChecker... checkers) {     for (BugChecker checker : checkers) {       registerNodeTypes(checker);     }   }" compose:Replacement merge: LineBased]
											[T -> methodInvocationMatchers : FieldDecl "private final List<MethodInvocationTreeMatcher> methodInvocationMatchers =       new ArrayList<MethodInvocationTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> newClassMatchers : FieldDecl "private final List<NewClassTreeMatcher> newClassMatchers =       new ArrayList<NewClassTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> annotationMatchers : FieldDecl "private final List<AnnotationTreeMatcher> annotationMatchers =       new ArrayList<AnnotationTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> emptyStatementMatchers : FieldDecl "private final List<EmptyStatementTreeMatcher> emptyStatementMatchers =       new ArrayList<EmptyStatementTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> assignmentMatchers : FieldDecl "private final List<AssignmentTreeMatcher> assignmentMatchers =       new ArrayList<AssignmentTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> variableMatchers : FieldDecl "private final List<VariableTreeMatcher> variableMatchers =       new ArrayList<VariableTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> methodMatchers : FieldDecl "private final List<MethodTreeMatcher> methodMatchers =       new ArrayList<MethodTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> literalMatchers : FieldDecl "private final List<LiteralTreeMatcher> literalMatchers =       new ArrayList<LiteralTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> conditionalExpressionMatchers : FieldDecl "private final List<ConditionalExpressionTreeMatcher> conditionalExpressionMatchers =       new ArrayList<ConditionalExpressionTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> binaryExpressionMatchers : FieldDecl "private final List<BinaryTreeMatcher> binaryExpressionMatchers =       new ArrayList<BinaryTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> compoundAssignmentMatchers : FieldDecl "private final List<CompoundAssignmentTreeMatcher> compoundAssignmentMatchers =       new ArrayList<CompoundAssignmentTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> classMatchers : FieldDecl "private final List<ClassTreeMatcher> classMatchers =       new ArrayList<ClassTreeMatcher>();" compose:Replacement merge: SemanticConflict]
											[T -> registerNodeTypes(BugChecker-BugChecker) : MethodDecl "private void registerNodeTypes(BugChecker checker) {     if (checker instanceof MethodInvocationTreeMatcher)       this.methodInvocationMatchers.add((MethodInvocationTreeMatcher) checker);     if (checker instanceof NewClassTreeMatcher)       this.newClassMatchers.add((NewClassTreeMatcher) checker);     if (checker instanceof AnnotationTreeMatcher)       this.annotationMatchers.add((AnnotationTreeMatcher) checker);     if (checker instanceof EmptyStatementTreeMatcher)       this.emptyStatementMatchers.add((EmptyStatementTreeMatcher) checker);     if (checker instanceof AssignmentTreeMatcher)       this.assignmentMatchers.add((AssignmentTreeMatcher) checker);     if (checker instanceof VariableTreeMatcher)       this.variableMatchers.add((VariableTreeMatcher) checker);     if (checker instanceof MethodTreeMatcher)       this.methodMatchers.add((MethodTreeMatcher) checker);     if (checker instanceof LiteralTreeMatcher)       this.literalMatchers.add((LiteralTreeMatcher) checker);     if (checker instanceof ConditionalExpressionTreeMatcher)       this.conditionalExpressionMatchers.add((ConditionalExpressionTreeMatcher) checker);     if (checker instanceof BinaryTreeMatcher)       this.binaryExpressionMatchers.add((BinaryTreeMatcher) checker);     if (checker instanceof CompoundAssignmentTreeMatcher)       this.compoundAssignmentMatchers.add((CompoundAssignmentTreeMatcher) checker);     if (checker instanceof ClassTreeMatcher)       this.classMatchers.add((ClassTreeMatcher) checker);   }" compose:Replacement merge: LineBased]
											[T -> visitMethodInvocation(MethodInvocationTree-MethodInvocationTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitMethodInvocation(       MethodInvocationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodInvocationTreeMatcher matcher : methodInvocationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethodInvocation(tree, state), tree, state);     }     return super.visitMethodInvocation(tree, state);   }" compose:Replacement merge: LineBased]
											[T -> visitBinary(BinaryTree-BinaryTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitBinary(BinaryTree tree,  VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (BinaryTreeMatcher matcher : binaryExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchBinary(tree, state), tree, state);     }     return super.visitBinary(tree, state);   }" compose:Replacement merge: LineBased]
											[T -> visitNewClass(NewClassTree-NewClassTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitNewClass(NewClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (NewClassTreeMatcher matcher : newClassMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchNewClass(tree, state), tree, state);     }     return super.visitNewClass(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitAnnotation(AnnotationTree-AnnotationTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitAnnotation(AnnotationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AnnotationTreeMatcher matcher : annotationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAnnotation(tree, state), tree, state);     }     return super.visitAnnotation(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitEmptyStatement(EmptyStatementTree-EmptyStatementTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitEmptyStatement(       EmptyStatementTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (EmptyStatementTreeMatcher matcher : emptyStatementMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchEmptyStatement(tree, state), tree, state);     }     return super.visitEmptyStatement(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitAssignment(AssignmentTree-AssignmentTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitAssignment(AssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AssignmentTreeMatcher matcher : assignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAssignment(tree, state), tree, state);     }     return super.visitAssignment(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitVariable(VariableTree-VariableTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitVariable(VariableTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (VariableTreeMatcher matcher : variableMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchVariable(tree, state), tree, state);     }     return super.visitVariable(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitMethod(MethodTree-MethodTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitMethod(MethodTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodTreeMatcher matcher : methodMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethod(tree, state), tree, state);     }     return super.visitMethod(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitLiteral(LiteralTree-LiteralTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitLiteral(LiteralTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (LiteralTreeMatcher matcher : literalMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchLiteral(tree, state), tree, state);     }     return super.visitLiteral(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitConditionalExpression(ConditionalExpressionTree-ConditionalExpressionTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitConditionalExpression(       ConditionalExpressionTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ConditionalExpressionTreeMatcher matcher : conditionalExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchConditionalExpression(tree, state), tree, state);     }     return super.visitConditionalExpression(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitCompoundAssignment(CompoundAssignmentTree-CompoundAssignmentTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitCompoundAssignment(CompoundAssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (CompoundAssignmentTreeMatcher matcher : compoundAssignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchCompoundAssignment(tree, state), tree, state);     }     return super.visitCompoundAssignment(tree, visitorState);   }" compose:Replacement merge: LineBased]
											[T -> visitClass(ClassTree-ClassTree-VisitorState-VisitorState) : MethodDecl "@Override   public Void visitClass(ClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ClassTreeMatcher matcher : classMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchClass(tree, state), tree, state);     }     return super.visitClass(tree, visitorState);   }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> google : Folder]
							[NT -> errorprone : Folder]
								[NT -> ErrorProneScanner.java.merge : .java.merge-File]
									[T -> ErrorProneScanner.java : .java-Content "/*  * Copyright 2011 Google Inc. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package com.google.errorprone;  import static com.google.errorprone.BugPattern.MaturityLevel.MATURE; import static com.google.errorprone.bugpatterns.BugChecker.*;  import com.google.errorprone.bugpatterns.*; import com.sun.source.tree.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  /**  * Scans the parsed AST, looking for violations of any of the enabled checks.  * @author Alex Eagle (alexeagle@google.com)  */ public class ErrorProneScanner extends Scanner {    /**    * Selects which checks should be enabled when the compile is run.    */   public interface EnabledPredicate {     boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation);      /**      * Selects all checks which are annotated with maturity = MATURE.      */     public static final EnabledPredicate DEFAULT_CHECKS = new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> checkerClass, BugPattern annotation) {         return annotation.maturity() == MATURE;       }     };   }    /**    * Create a scanner that only enables a single matcher.    */   public static Scanner forMatcher(final Class<?> checkerClass) {     return new ErrorProneScanner(new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation) {         return check.equals(checkerClass);       }     });   }    // TODO: discover all @BugPattern-annotated classes   private static final List<? extends Class<? extends BugChecker>> ALL_CHECKERS = Arrays.asList(       SelfEquals.class,       OrderingFrom.class,       PreconditionsCheckNotNull.class,       PreconditionsExpensiveString.class,       PreconditionsCheckNotNullPrimitive.class,       CollectionIncompatibleType.class,       ArrayEquals.class,       ArrayToString.class,       ReturnValueIgnored.class,       NonRuntimeAnnotation.class,       InvalidPatternSyntax.class,       ModifyingCollectionWithItself.class,       PreconditionsTooManyArgs.class,       CheckReturnValue.class,       DeadException.class,       InjectAssistedInjectAndInjectOnConstructors.class,       InjectMoreThanOneQualifier.class,       InjectMoreThanOneScopeAnnotationOnClass.class,       InjectScopeAnnotationOnInterfaceOrAbstractClass.class,       FallThroughSuppression.class,       SuppressWarningsDeprecated.class,       EmptyIfStatement.class,       EmptyStatement.class,       InvalidNumericEquality.class,       InvalidStringEquality.class,       SelfEquality.class,       BadShiftAmount.class,       ArrayToStringConcatenation.class,       ComparisonOutOfRange.class,       SelfAssignment.class,       GuiceAssistedParameters.class,       CovariantEquals.class,       JUnit4TestNotRun.class,       WrongParameterPackage.class,       LongLiteralLowerCaseSuffix.class,       UnneededConditionalOperator.class,       ArrayToStringCompoundAssignment.class,       InjectScopeOrQualifierAnnotationRetention.class,       InjectInvalidTargetingOnScopingAnnotation.class,       GuiceAssistedInjectScoping.class,       InjectMoreThanOneInjectableConstructor.class   );    @SuppressWarnings("unchecked")   public ErrorProneScanner(EnabledPredicate predicate) {     try {       for (final Class<? extends BugChecker> checkerClass: ALL_CHECKERS) {         if (predicate.isEnabled(checkerClass, checkerClass.getAnnotation(BugPattern.class))) {           BugChecker checker = checkerClass.newInstance();           registerNodeTypes(checker);         }       }     } catch (Exception e) {       throw new RuntimeException("Could not reflectively create error prone matchers", e);     }   }    public ErrorProneScanner(BugChecker checker) {     registerNodeTypes(checker);   }    private final List<MethodInvocationTreeMatcher> methodInvocationMatchers =       new ArrayList<MethodInvocationTreeMatcher>();   private final List<NewClassTreeMatcher> newClassMatchers =       new ArrayList<NewClassTreeMatcher>();   private final List<AnnotationTreeMatcher> annotationMatchers =       new ArrayList<AnnotationTreeMatcher>();   private final List<EmptyStatementTreeMatcher> emptyStatementMatchers =       new ArrayList<EmptyStatementTreeMatcher>();   private final List<AssignmentTreeMatcher> assignmentMatchers =       new ArrayList<AssignmentTreeMatcher>();   private final List<VariableTreeMatcher> variableMatchers =       new ArrayList<VariableTreeMatcher>();   private final List<MethodTreeMatcher> methodMatchers =       new ArrayList<MethodTreeMatcher>();   private final List<LiteralTreeMatcher> literalMatchers =       new ArrayList<LiteralTreeMatcher>();   private final List<ConditionalExpressionTreeMatcher> conditionalExpressionMatchers =       new ArrayList<ConditionalExpressionTreeMatcher>();   private final List<BinaryTreeMatcher> binaryExpressionMatchers =       new ArrayList<BinaryTreeMatcher>();   private final List<CompoundAssignmentTreeMatcher> compoundAssignmentMatchers =       new ArrayList<CompoundAssignmentTreeMatcher>();   private final List<ClassTreeMatcher> classMatchers =       new ArrayList<ClassTreeMatcher>();    private void registerNodeTypes(BugChecker checker) {     if (checker instanceof MethodInvocationTreeMatcher)       this.methodInvocationMatchers.add((MethodInvocationTreeMatcher) checker);     if (checker instanceof NewClassTreeMatcher)       this.newClassMatchers.add((NewClassTreeMatcher) checker);     if (checker instanceof AnnotationTreeMatcher)       this.annotationMatchers.add((AnnotationTreeMatcher) checker);     if (checker instanceof EmptyStatementTreeMatcher)       this.emptyStatementMatchers.add((EmptyStatementTreeMatcher) checker);     if (checker instanceof AssignmentTreeMatcher)       this.assignmentMatchers.add((AssignmentTreeMatcher) checker);     if (checker instanceof VariableTreeMatcher)       this.variableMatchers.add((VariableTreeMatcher) checker);     if (checker instanceof MethodTreeMatcher)       this.methodMatchers.add((MethodTreeMatcher) checker);     if (checker instanceof LiteralTreeMatcher)       this.literalMatchers.add((LiteralTreeMatcher) checker);     if (checker instanceof ConditionalExpressionTreeMatcher)       this.conditionalExpressionMatchers.add((ConditionalExpressionTreeMatcher) checker);     if (checker instanceof BinaryTreeMatcher)       this.binaryExpressionMatchers.add((BinaryTreeMatcher) checker);     if (checker instanceof CompoundAssignmentTreeMatcher)       this.compoundAssignmentMatchers.add((CompoundAssignmentTreeMatcher) checker);     if (checker instanceof ClassTreeMatcher)       this.classMatchers.add((ClassTreeMatcher) checker);   }    @Override   public Void visitMethodInvocation(       MethodInvocationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodInvocationTreeMatcher matcher : methodInvocationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethodInvocation(tree, state), tree, state);     }     return super.visitMethodInvocation(tree, state);   }    @Override   public Void visitBinary(BinaryTree tree,  VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (BinaryTreeMatcher matcher : binaryExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchBinary(tree, state), tree, state);     }     return super.visitBinary(tree, state);   }    @Override   public Void visitNewClass(NewClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (NewClassTreeMatcher matcher : newClassMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchNewClass(tree, state), tree, state);     }     return super.visitNewClass(tree, visitorState);   }    @Override   public Void visitAnnotation(AnnotationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AnnotationTreeMatcher matcher : annotationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAnnotation(tree, state), tree, state);     }     return super.visitAnnotation(tree, visitorState);   }    @Override   public Void visitEmptyStatement(       EmptyStatementTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (EmptyStatementTreeMatcher matcher : emptyStatementMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchEmptyStatement(tree, state), tree, state);     }     return super.visitEmptyStatement(tree, visitorState);   }    @Override   public Void visitAssignment(AssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AssignmentTreeMatcher matcher : assignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAssignment(tree, state), tree, state);     }     return super.visitAssignment(tree, visitorState);   }     @Override   public Void visitVariable(VariableTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (VariableTreeMatcher matcher : variableMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchVariable(tree, state), tree, state);     }     return super.visitVariable(tree, visitorState);   }    @Override   public Void visitMethod(MethodTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodTreeMatcher matcher : methodMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethod(tree, state), tree, state);     }     return super.visitMethod(tree, visitorState);   }    @Override   public Void visitLiteral(LiteralTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (LiteralTreeMatcher matcher : literalMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchLiteral(tree, state), tree, state);     }     return super.visitLiteral(tree, visitorState);   }    @Override   public Void visitConditionalExpression(       ConditionalExpressionTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ConditionalExpressionTreeMatcher matcher : conditionalExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchConditionalExpression(tree, state), tree, state);     }     return super.visitConditionalExpression(tree, visitorState);   }    @Override   public Void visitCompoundAssignment(CompoundAssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (CompoundAssignmentTreeMatcher matcher : compoundAssignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchCompoundAssignment(tree, state), tree, state);     }     return super.visitCompoundAssignment(tree, visitorState);   }    @Override   public Void visitClass(ClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ClassTreeMatcher matcher : classMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchClass(tree, state), tree, state);     }     return super.visitClass(tree, visitorState);   } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> google : Folder]
							[NT -> errorprone : Folder]
								[NT -> ErrorProneScanner.java.merge : .java.merge-File]
									[T -> ErrorProneScanner.java : .java-Content "/*  * Copyright 2011 Google Inc. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package com.google.errorprone;  import static com.google.errorprone.BugPattern.MaturityLevel.MATURE; import static com.google.errorprone.bugpatterns.BugChecker.*;  import com.google.errorprone.bugpatterns.*; import com.sun.source.tree.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  /**  * Scans the parsed AST, looking for violations of any of the enabled checks.  * @author Alex Eagle (alexeagle@google.com)  */ public class ErrorProneScanner extends Scanner {    /**    * Selects which checks should be enabled when the compile is run.    */   public interface EnabledPredicate {     boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation);      /**      * Selects all checks which are annotated with maturity = MATURE.      */     public static final EnabledPredicate DEFAULT_CHECKS = new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> checkerClass, BugPattern annotation) {         return annotation.maturity() == MATURE;       }     };   }    /**    * Create a scanner that only enables a single matcher.    */   public static Scanner forMatcher(final Class<?> checkerClass) {     return new ErrorProneScanner(new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation) {         return check.equals(checkerClass);       }     });   }    // TODO: discover all @BugPattern-annotated classes   private static final List<? extends Class<? extends BugChecker>> ALL_CHECKERS = Arrays.asList(       SelfEquals.class,       OrderingFrom.class,       PreconditionsCheckNotNull.class,       PreconditionsExpensiveString.class,       PreconditionsCheckNotNullPrimitive.class,       CollectionIncompatibleType.class,       ArrayEquals.class,       ArrayToString.class,       ReturnValueIgnored.class,       NonRuntimeAnnotation.class,       InvalidPatternSyntax.class,       ModifyingCollectionWithItself.class,       PreconditionsTooManyArgs.class,       CheckReturnValue.class,       DeadException.class,       InjectAssistedInjectAndInjectOnConstructors.class,       InjectMoreThanOneQualifier.class,       InjectMoreThanOneScopeAnnotationOnClass.class,       InjectScopeAnnotationOnInterfaceOrAbstractClass.class,       FallThroughSuppression.class,       SuppressWarningsDeprecated.class,       EmptyIfStatement.class,       EmptyStatement.class,       InvalidNumericEquality.class,       InvalidStringEquality.class,       SelfEquality.class,       BadShiftAmount.class,       ArrayToStringConcatenation.class,       ComparisonOutOfRange.class,       SelfAssignment.class,       GuiceAssistedParameters.class,       CovariantEquals.class,       JUnit4TestNotRun.class,       WrongParameterPackage.class,       LongLiteralLowerCaseSuffix.class,       UnneededConditionalOperator.class,       ArrayToStringCompoundAssignment.class,       InjectScopeOrQualifierAnnotationRetention.class,       InjectInvalidTargetingOnScopingAnnotation.class,       GuiceAssistedInjectScoping.class   );    @SuppressWarnings("unchecked")   public ErrorProneScanner(EnabledPredicate predicate) {     try {       for (final Class<? extends BugChecker> checkerClass: ALL_CHECKERS) {         if (predicate.isEnabled(checkerClass, checkerClass.getAnnotation(BugPattern.class))) {           BugChecker checker = checkerClass.newInstance();           registerNodeTypes(checker);         }       }     } catch (Exception e) {       throw new RuntimeException("Could not reflectively create error prone matchers", e);     }   }    public ErrorProneScanner(BugChecker checker) {     registerNodeTypes(checker);   }    private final List<MethodInvocationTreeMatcher> methodInvocationMatchers =       new ArrayList<MethodInvocationTreeMatcher>();   private final List<NewClassTreeMatcher> newClassMatchers =       new ArrayList<NewClassTreeMatcher>();   private final List<AnnotationTreeMatcher> annotationMatchers =       new ArrayList<AnnotationTreeMatcher>();   private final List<EmptyStatementTreeMatcher> emptyStatementMatchers =       new ArrayList<EmptyStatementTreeMatcher>();   private final List<AssignmentTreeMatcher> assignmentMatchers =       new ArrayList<AssignmentTreeMatcher>();   private final List<VariableTreeMatcher> variableMatchers =       new ArrayList<VariableTreeMatcher>();   private final List<MethodTreeMatcher> methodMatchers =       new ArrayList<MethodTreeMatcher>();   private final List<LiteralTreeMatcher> literalMatchers =       new ArrayList<LiteralTreeMatcher>();   private final List<ConditionalExpressionTreeMatcher> conditionalExpressionMatchers =       new ArrayList<ConditionalExpressionTreeMatcher>();   private final List<BinaryTreeMatcher> binaryExpressionMatchers =       new ArrayList<BinaryTreeMatcher>();   private final List<CompoundAssignmentTreeMatcher> compoundAssignmentMatchers =       new ArrayList<CompoundAssignmentTreeMatcher>();   private final List<ClassTreeMatcher> classMatchers =       new ArrayList<ClassTreeMatcher>();    private void registerNodeTypes(BugChecker checker) {     if (checker instanceof MethodInvocationTreeMatcher)       this.methodInvocationMatchers.add((MethodInvocationTreeMatcher) checker);     if (checker instanceof NewClassTreeMatcher)       this.newClassMatchers.add((NewClassTreeMatcher) checker);     if (checker instanceof AnnotationTreeMatcher)       this.annotationMatchers.add((AnnotationTreeMatcher) checker);     if (checker instanceof EmptyStatementTreeMatcher)       this.emptyStatementMatchers.add((EmptyStatementTreeMatcher) checker);     if (checker instanceof AssignmentTreeMatcher)       this.assignmentMatchers.add((AssignmentTreeMatcher) checker);     if (checker instanceof VariableTreeMatcher)       this.variableMatchers.add((VariableTreeMatcher) checker);     if (checker instanceof MethodTreeMatcher)       this.methodMatchers.add((MethodTreeMatcher) checker);     if (checker instanceof LiteralTreeMatcher)       this.literalMatchers.add((LiteralTreeMatcher) checker);     if (checker instanceof ConditionalExpressionTreeMatcher)       this.conditionalExpressionMatchers.add((ConditionalExpressionTreeMatcher) checker);     if (checker instanceof BinaryTreeMatcher)       this.binaryExpressionMatchers.add((BinaryTreeMatcher) checker);     if (checker instanceof CompoundAssignmentTreeMatcher)       this.compoundAssignmentMatchers.add((CompoundAssignmentTreeMatcher) checker);     if (checker instanceof ClassTreeMatcher)       this.classMatchers.add((ClassTreeMatcher) checker);   }    @Override   public Void visitMethodInvocation(       MethodInvocationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodInvocationTreeMatcher matcher : methodInvocationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethodInvocation(tree, state), tree, state);     }     return super.visitMethodInvocation(tree, state);   }    @Override   public Void visitBinary(BinaryTree tree,  VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (BinaryTreeMatcher matcher : binaryExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchBinary(tree, state), tree, state);     }     return super.visitBinary(tree, state);   }    @Override   public Void visitNewClass(NewClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (NewClassTreeMatcher matcher : newClassMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchNewClass(tree, state), tree, state);     }     return super.visitNewClass(tree, visitorState);   }    @Override   public Void visitAnnotation(AnnotationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AnnotationTreeMatcher matcher : annotationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAnnotation(tree, state), tree, state);     }     return super.visitAnnotation(tree, visitorState);   }    @Override   public Void visitEmptyStatement(       EmptyStatementTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (EmptyStatementTreeMatcher matcher : emptyStatementMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchEmptyStatement(tree, state), tree, state);     }     return super.visitEmptyStatement(tree, visitorState);   }    @Override   public Void visitAssignment(AssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AssignmentTreeMatcher matcher : assignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAssignment(tree, state), tree, state);     }     return super.visitAssignment(tree, visitorState);   }     @Override   public Void visitVariable(VariableTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (VariableTreeMatcher matcher : variableMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchVariable(tree, state), tree, state);     }     return super.visitVariable(tree, visitorState);   }    @Override   public Void visitMethod(MethodTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodTreeMatcher matcher : methodMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethod(tree, state), tree, state);     }     return super.visitMethod(tree, visitorState);   }    @Override   public Void visitLiteral(LiteralTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (LiteralTreeMatcher matcher : literalMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchLiteral(tree, state), tree, state);     }     return super.visitLiteral(tree, visitorState);   }    @Override   public Void visitConditionalExpression(       ConditionalExpressionTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ConditionalExpressionTreeMatcher matcher : conditionalExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchConditionalExpression(tree, state), tree, state);     }     return super.visitConditionalExpression(tree, visitorState);   }    @Override   public Void visitCompoundAssignment(CompoundAssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (CompoundAssignmentTreeMatcher matcher : compoundAssignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchCompoundAssignment(tree, state), tree, state);     }     return super.visitCompoundAssignment(tree, visitorState);   }    @Override   public Void visitClass(ClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ClassTreeMatcher matcher : classMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchClass(tree, state), tree, state);     }     return super.visitClass(tree, visitorState);   } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> core : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> google : Folder]
							[NT -> errorprone : Folder]
								[NT -> ErrorProneScanner.java.merge : .java.merge-File]
									[T -> ErrorProneScanner.java : .java-Content "/*  * Copyright 2011 Google Inc. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package com.google.errorprone;  import static com.google.errorprone.BugPattern.MaturityLevel.MATURE; import static com.google.errorprone.bugpatterns.BugChecker.*;  import com.google.errorprone.bugpatterns.*; import com.sun.source.tree.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  /**  * Scans the parsed AST, looking for violations of any of the enabled checks.  * @author Alex Eagle (alexeagle@google.com)  */ public class ErrorProneScanner extends Scanner {    /**    * Selects which checks should be enabled when the compile is run.    */   public interface EnabledPredicate {     boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation);      /**      * Selects all checks which are annotated with maturity = MATURE.      */     public static final EnabledPredicate DEFAULT_CHECKS = new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> checkerClass, BugPattern annotation) {         return annotation.maturity() == MATURE;       }     };   }    /**    * Create a scanner that only enables a single matcher.    */   public static Scanner forMatcher(final Class<?> checkerClass) {     return new ErrorProneScanner(new EnabledPredicate() {       @Override       public boolean isEnabled(Class<? extends BugChecker> check, BugPattern annotation) {         return check.equals(checkerClass);       }     });   }    // TODO: discover all @BugPattern-annotated classes   private static final List<? extends Class<? extends BugChecker>> ALL_CHECKERS = Arrays.asList(       SelfEquals.class,       OrderingFrom.class,       PreconditionsCheckNotNull.class,       PreconditionsExpensiveString.class,       PreconditionsCheckNotNullPrimitive.class,       CollectionIncompatibleType.class,       ArrayEquals.class,       ArrayToString.class,       ReturnValueIgnored.class,       NonRuntimeAnnotation.class,       InvalidPatternSyntax.class,       ModifyingCollectionWithItself.class,       PreconditionsTooManyArgs.class,       CheckReturnValue.class,       DeadException.class,       InjectAssistedInjectAndInjectOnConstructors.class,       InjectMoreThanOneQualifier.class,       InjectMoreThanOneScopeAnnotationOnClass.class,       InjectScopeAnnotationOnInterfaceOrAbstractClass.class,       FallThroughSuppression.class,       SuppressWarningsDeprecated.class,       EmptyIfStatement.class,       EmptyStatement.class,       InvalidNumericEquality.class,       InvalidStringEquality.class,       SelfEquality.class,       BadShiftAmount.class,       ArrayToStringConcatenation.class,       ComparisonOutOfRange.class,       SelfAssignment.class,       GuiceAssistedParameters.class,       CovariantEquals.class,       JUnit4TestNotRun.class,       WrongParameterPackage.class,       LongLiteralLowerCaseSuffix.class,       UnneededConditionalOperator.class,       ArrayToStringCompoundAssignment.class,       InjectScopeOrQualifierAnnotationRetention.class,       InjectInvalidTargetingOnScopingAnnotation.class,       GuiceAssistedInjectScoping.class,       InjectJavaxInjectOnFinalField.class,       GuiceInjectOnFinalField.class   );    @SuppressWarnings("unchecked")   public ErrorProneScanner(EnabledPredicate predicate) {     try {       for (final Class<? extends BugChecker> checkerClass: ALL_CHECKERS) {         if (predicate.isEnabled(checkerClass, checkerClass.getAnnotation(BugPattern.class))) {           BugChecker checker = checkerClass.newInstance();           registerNodeTypes(checker);         }       }     } catch (Exception e) {       throw new RuntimeException("Could not reflectively create error prone matchers", e);     }   }    /**    * Create an error-prone scanner for a non-hardcoded set of checkers.    *    * @param checkers The checkers that this scanner should use.    */   public ErrorProneScanner(BugChecker... checkers) {     for (BugChecker checker : checkers) {       registerNodeTypes(checker);     }   }    private final List<MethodInvocationTreeMatcher> methodInvocationMatchers =       new ArrayList<MethodInvocationTreeMatcher>();   private final List<NewClassTreeMatcher> newClassMatchers =       new ArrayList<NewClassTreeMatcher>();   private final List<AnnotationTreeMatcher> annotationMatchers =       new ArrayList<AnnotationTreeMatcher>();   private final List<EmptyStatementTreeMatcher> emptyStatementMatchers =       new ArrayList<EmptyStatementTreeMatcher>();   private final List<AssignmentTreeMatcher> assignmentMatchers =       new ArrayList<AssignmentTreeMatcher>();   private final List<VariableTreeMatcher> variableMatchers =       new ArrayList<VariableTreeMatcher>();   private final List<MethodTreeMatcher> methodMatchers =       new ArrayList<MethodTreeMatcher>();   private final List<LiteralTreeMatcher> literalMatchers =       new ArrayList<LiteralTreeMatcher>();   private final List<ConditionalExpressionTreeMatcher> conditionalExpressionMatchers =       new ArrayList<ConditionalExpressionTreeMatcher>();   private final List<BinaryTreeMatcher> binaryExpressionMatchers =       new ArrayList<BinaryTreeMatcher>();   private final List<CompoundAssignmentTreeMatcher> compoundAssignmentMatchers =       new ArrayList<CompoundAssignmentTreeMatcher>();   private final List<ClassTreeMatcher> classMatchers =       new ArrayList<ClassTreeMatcher>();    private void registerNodeTypes(BugChecker checker) {     if (checker instanceof MethodInvocationTreeMatcher)       this.methodInvocationMatchers.add((MethodInvocationTreeMatcher) checker);     if (checker instanceof NewClassTreeMatcher)       this.newClassMatchers.add((NewClassTreeMatcher) checker);     if (checker instanceof AnnotationTreeMatcher)       this.annotationMatchers.add((AnnotationTreeMatcher) checker);     if (checker instanceof EmptyStatementTreeMatcher)       this.emptyStatementMatchers.add((EmptyStatementTreeMatcher) checker);     if (checker instanceof AssignmentTreeMatcher)       this.assignmentMatchers.add((AssignmentTreeMatcher) checker);     if (checker instanceof VariableTreeMatcher)       this.variableMatchers.add((VariableTreeMatcher) checker);     if (checker instanceof MethodTreeMatcher)       this.methodMatchers.add((MethodTreeMatcher) checker);     if (checker instanceof LiteralTreeMatcher)       this.literalMatchers.add((LiteralTreeMatcher) checker);     if (checker instanceof ConditionalExpressionTreeMatcher)       this.conditionalExpressionMatchers.add((ConditionalExpressionTreeMatcher) checker);     if (checker instanceof BinaryTreeMatcher)       this.binaryExpressionMatchers.add((BinaryTreeMatcher) checker);     if (checker instanceof CompoundAssignmentTreeMatcher)       this.compoundAssignmentMatchers.add((CompoundAssignmentTreeMatcher) checker);     if (checker instanceof ClassTreeMatcher)       this.classMatchers.add((ClassTreeMatcher) checker);   }    @Override   public Void visitMethodInvocation(       MethodInvocationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodInvocationTreeMatcher matcher : methodInvocationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethodInvocation(tree, state), tree, state);     }     return super.visitMethodInvocation(tree, state);   }    @Override   public Void visitBinary(BinaryTree tree,  VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (BinaryTreeMatcher matcher : binaryExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchBinary(tree, state), tree, state);     }     return super.visitBinary(tree, state);   }    @Override   public Void visitNewClass(NewClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (NewClassTreeMatcher matcher : newClassMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchNewClass(tree, state), tree, state);     }     return super.visitNewClass(tree, visitorState);   }    @Override   public Void visitAnnotation(AnnotationTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AnnotationTreeMatcher matcher : annotationMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAnnotation(tree, state), tree, state);     }     return super.visitAnnotation(tree, visitorState);   }    @Override   public Void visitEmptyStatement(       EmptyStatementTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (EmptyStatementTreeMatcher matcher : emptyStatementMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchEmptyStatement(tree, state), tree, state);     }     return super.visitEmptyStatement(tree, visitorState);   }    @Override   public Void visitAssignment(AssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (AssignmentTreeMatcher matcher : assignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchAssignment(tree, state), tree, state);     }     return super.visitAssignment(tree, visitorState);   }     @Override   public Void visitVariable(VariableTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (VariableTreeMatcher matcher : variableMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchVariable(tree, state), tree, state);     }     return super.visitVariable(tree, visitorState);   }    @Override   public Void visitMethod(MethodTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (MethodTreeMatcher matcher : methodMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchMethod(tree, state), tree, state);     }     return super.visitMethod(tree, visitorState);   }    @Override   public Void visitLiteral(LiteralTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (LiteralTreeMatcher matcher : literalMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchLiteral(tree, state), tree, state);     }     return super.visitLiteral(tree, visitorState);   }    @Override   public Void visitConditionalExpression(       ConditionalExpressionTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ConditionalExpressionTreeMatcher matcher : conditionalExpressionMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchConditionalExpression(tree, state), tree, state);     }     return super.visitConditionalExpression(tree, visitorState);   }    @Override   public Void visitCompoundAssignment(CompoundAssignmentTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (CompoundAssignmentTreeMatcher matcher : compoundAssignmentMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchCompoundAssignment(tree, state), tree, state);     }     return super.visitCompoundAssignment(tree, visitorState);   }    @Override   public Void visitClass(ClassTree tree, VisitorState visitorState) {     VisitorState state = visitorState.withPath(getCurrentPath());     for (ClassTreeMatcher matcher : classMatchers) {       if (isSuppressed(matcher)) continue;       reportMatch(matcher.matchClass(tree, state), tree, state);     }     return super.visitClass(tree, visitorState);   } } " compose:StringConcatenation merge: LineBased]
