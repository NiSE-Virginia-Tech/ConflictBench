Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/proxy-server/src/main/java/org/fengfei/lanproxy/server/handlers/UserChannelHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/proxy-server/src/main/java/org/fengfei/lanproxy/server/handlers/UserChannelHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/proxy-server/src/main/java/org/fengfei/lanproxy/server/handlers/UserChannelHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/proxy-server/src/main/java/org/fengfei/lanproxy/server/handlers/UserChannelHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/proxy-server/src/main/java/org/fengfei/lanproxy/server/handlers/UserChannelHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/proxy-server/src/main/java/org/fengfei/lanproxy/server/handlers/UserChannelHandler.java
[NT -> left : Feature]
	[NT -> proxy-server : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> fengfei : Folder]
							[NT -> lanproxy : Folder]
								[NT -> server : Folder]
									[NT -> handlers : Folder]
										[NT -> UserChannelHandler.java : Java-File]
											[NT -> - : CompilationUnit]
												[T -> - : PackageDeclaration "package org.fengfei.lanproxy.server.handlers;" compose:Replacement merge: Default]
												[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: Default]
												[T -> java.util.concurrent.atomic.AtomicLong{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicLong;" compose:Replacement merge: Default]
												[T -> io.netty.buffer.Unpooled{ImportPackage} : ImportDeclaration "import io.netty.buffer.Unpooled;" compose:Replacement merge: Default]
												[T -> io.netty.channel.* : ImportDeclaration "import io.netty.channel.*;" compose:Replacement merge: Default]
												[T -> io.netty.handler.codec.http.DefaultFullHttpResponse{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.DefaultFullHttpResponse;" compose:Replacement merge: Default]
												[T -> io.netty.handler.codec.http.FullHttpResponse{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.FullHttpResponse;" compose:Replacement merge: Default]
												[T -> io.netty.handler.codec.http.HttpResponseStatus{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpResponseStatus;" compose:Replacement merge: Default]
												[T -> io.netty.handler.codec.http.HttpVersion{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpVersion;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.protocol.Constants{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.protocol.Constants;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.protocol.ProxyMessage{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.protocol.ProxyMessage;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.server.ProxyChannelManager{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.server.ProxyChannelManager;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.server.config.ProxyConfig{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.server.config.ProxyConfig;" compose:Replacement merge: Default]
												[T -> io.netty.buffer.ByteBuf{ImportPackage} : ImportDeclaration "import io.netty.buffer.ByteBuf;" compose:Replacement merge: Default]
												[NT -> UserChannelHandler : ClassDeclaration]
													[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
													[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
													[T -> UserChannelHandler : Id "UserChannelHandler" compose:Replacement merge: Default]
													[T -> - : ExtendsList "extends SimpleChannelInboundHandler<ByteBuf>" compose:Replacement merge: Default]
													[T -> userIdProducer : FieldDecl "private static AtomicLong userIdProducer = new AtomicLong(0);" compose:Replacement merge: SemanticConflict]
													[T -> exceptionCaught(ChannelHandlerContext-ChannelHandlerContext-Throwable-Throwable) : MethodDecl "@Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {          // 当出现异常就关闭连接         ctx.close();     }" compose:Replacement merge: LineBased]
													[T -> channelRead0(ChannelHandlerContext-ChannelHandlerContext-ByteBuf-ByteBuf) : MethodDecl "@Override     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();         if (proxyChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             byte[] bytes = new byte[buf.readableBytes()];             buf.readBytes(bytes);             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.P_TYPE_TRANSFER);             proxyMessage.setUri(userId);             proxyMessage.setData(bytes);             proxyChannel.writeAndFlush(proxyMessage);         }     }" compose:Replacement merge: LineBased]
													[T -> channelActive(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());          if (cmdChannel == null) {              // 该端口还没有代理客户端             FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.SERVICE_UNAVAILABLE);             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             String userId = newUserId();             String lanInfo = ProxyConfig.getInstance().getLanInfo(sa.getPort());             // 用户连接到代理服务器时，设置用户连接不可读，等待代理后端服务器连接成功后再改变为可读状态             userChannel.config().setOption(ChannelOption.AUTO_READ, false);             ProxyChannelManager.addUserChannelToCmdChannel(cmdChannel, userId, userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.TYPE_CONNECT);             proxyMessage.setUri(userId);             proxyMessage.setData(lanInfo.getBytes());             cmdChannel.writeAndFlush(proxyMessage);         }          super.channelActive(ctx);     }" compose:Replacement merge: LineBased]
													[T -> channelInactive(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelInactive(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {              // 用户连接断开，从控制连接中移除             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyChannelManager.removeUserChannelFromCmdChannel(cmdChannel, userId);             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null && proxyChannel.isActive()) {                 proxyChannel.attr(Constants.NEXT_CHANNEL).remove();                 proxyChannel.attr(Constants.CLIENT_KEY).remove();                 proxyChannel.attr(Constants.USER_ID).remove();                  proxyChannel.config().setOption(ChannelOption.AUTO_READ, true);                 // 通知客户端，用户连接已经断开                 ProxyMessage proxyMessage = new ProxyMessage();                 proxyMessage.setType(ProxyMessage.TYPE_DISCONNECT);                 proxyMessage.setUri(userId);                 proxyChannel.writeAndFlush(proxyMessage);             }         }          super.channelInactive(ctx);     }" compose:Replacement merge: LineBased]
													[T -> channelWritabilityChanged(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null) {                 proxyChannel.config().setOption(ChannelOption.AUTO_READ, userChannel.isWritable());             }         }          super.channelWritabilityChanged(ctx);     }" compose:Replacement merge: LineBased]
													[T -> newUserId({FormalParametersInternal}) : MethodDecl "private static String newUserId() {         return String.valueOf(userIdProducer.incrementAndGet());     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> proxy-server : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> fengfei : Folder]
							[NT -> lanproxy : Folder]
								[NT -> server : Folder]
									[NT -> handlers : Folder]
										[NT -> UserChannelHandler.java : Java-File]
											[NT -> - : CompilationUnit]
												[T -> - : PackageDeclaration "package org.fengfei.lanproxy.server.handlers;" compose:Replacement merge: Default]
												[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: Default]
												[T -> java.util.concurrent.atomic.AtomicLong{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicLong;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.protocol.Constants{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.protocol.Constants;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.protocol.ProxyMessage{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.protocol.ProxyMessage;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.server.ProxyChannelManager{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.server.ProxyChannelManager;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.server.config.ProxyConfig{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.server.config.ProxyConfig;" compose:Replacement merge: Default]
												[T -> io.netty.buffer.ByteBuf{ImportPackage} : ImportDeclaration "import io.netty.buffer.ByteBuf;" compose:Replacement merge: Default]
												[T -> io.netty.channel.Channel{ImportPackage} : ImportDeclaration "import io.netty.channel.Channel;" compose:Replacement merge: Default]
												[T -> io.netty.channel.ChannelHandlerContext{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandlerContext;" compose:Replacement merge: Default]
												[T -> io.netty.channel.ChannelOption{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelOption;" compose:Replacement merge: Default]
												[T -> io.netty.channel.SimpleChannelInboundHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.SimpleChannelInboundHandler;" compose:Replacement merge: Default]
												[NT -> UserChannelHandler : ClassDeclaration]
													[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
													[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
													[T -> UserChannelHandler : Id "UserChannelHandler" compose:Replacement merge: Default]
													[T -> - : ExtendsList "extends SimpleChannelInboundHandler<ByteBuf>" compose:Replacement merge: Default]
													[T -> userIdProducer : FieldDecl "private static AtomicLong userIdProducer = new AtomicLong(0);" compose:Replacement merge: SemanticConflict]
													[T -> exceptionCaught(ChannelHandlerContext-ChannelHandlerContext-Throwable-Throwable) : MethodDecl "@Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {          // 当出现异常就关闭连接         ctx.close();     }" compose:Replacement merge: LineBased]
													[T -> channelRead0(ChannelHandlerContext-ChannelHandlerContext-ByteBuf-ByteBuf) : MethodDecl "@Override     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();         if (proxyChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             byte[] bytes = new byte[buf.readableBytes()];             buf.readBytes(bytes);             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.P_TYPE_TRANSFER);             proxyMessage.setUri(userId);             proxyMessage.setData(bytes);             proxyChannel.writeAndFlush(proxyMessage);         }     }" compose:Replacement merge: LineBased]
													[T -> channelActive(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());          if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             String userId = newUserId();             String lanInfo = ProxyConfig.getInstance().getLanInfo(sa.getPort());             // 用户连接到代理服务器时，设置用户连接不可读，等待代理后端服务器连接成功后再改变为可读状态             userChannel.config().setOption(ChannelOption.AUTO_READ, false);             ProxyChannelManager.addUserChannelToCmdChannel(cmdChannel, userId, userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.TYPE_CONNECT);             proxyMessage.setUri(userId);             proxyMessage.setData(lanInfo.getBytes());             cmdChannel.writeAndFlush(proxyMessage);         }          super.channelActive(ctx);     }" compose:Replacement merge: LineBased]
													[T -> channelInactive(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelInactive(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {              // 用户连接断开，从控制连接中移除             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyChannelManager.removeUserChannelFromCmdChannel(cmdChannel, userId);             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null && proxyChannel.isActive()) {                 proxyChannel.attr(Constants.NEXT_CHANNEL).remove();                 proxyChannel.attr(Constants.CLIENT_KEY).remove();                 proxyChannel.attr(Constants.USER_ID).remove();                  proxyChannel.config().setOption(ChannelOption.AUTO_READ, true);                 // 通知客户端，用户连接已经断开                 ProxyMessage proxyMessage = new ProxyMessage();                 proxyMessage.setType(ProxyMessage.TYPE_DISCONNECT);                 proxyMessage.setUri(userId);                 proxyChannel.writeAndFlush(proxyMessage);             }         }          super.channelInactive(ctx);     }" compose:Replacement merge: LineBased]
													[T -> channelWritabilityChanged(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null) {                 proxyChannel.config().setOption(ChannelOption.AUTO_READ, userChannel.isWritable());             }         }          super.channelWritabilityChanged(ctx);     }" compose:Replacement merge: LineBased]
													[T -> newUserId({FormalParametersInternal}) : MethodDecl "private static String newUserId() {         return String.valueOf(userIdProducer.incrementAndGet());     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> proxy-server : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> fengfei : Folder]
							[NT -> lanproxy : Folder]
								[NT -> server : Folder]
									[NT -> handlers : Folder]
										[NT -> UserChannelHandler.java : Java-File]
											[NT -> - : CompilationUnit]
												[T -> - : PackageDeclaration "package org.fengfei.lanproxy.server.handlers;" compose:Replacement merge: Default]
												[T -> java.net.InetSocketAddress{ImportPackage} : ImportDeclaration "import java.net.InetSocketAddress;" compose:Replacement merge: Default]
												[T -> java.util.concurrent.atomic.AtomicLong{ImportPackage} : ImportDeclaration "import java.util.concurrent.atomic.AtomicLong;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.protocol.Constants{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.protocol.Constants;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.protocol.ProxyMessage{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.protocol.ProxyMessage;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.server.ProxyChannelManager{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.server.ProxyChannelManager;" compose:Replacement merge: Default]
												[T -> org.fengfei.lanproxy.server.config.ProxyConfig{ImportPackage} : ImportDeclaration "import org.fengfei.lanproxy.server.config.ProxyConfig;" compose:Replacement merge: Default]
												[T -> io.netty.buffer.ByteBuf{ImportPackage} : ImportDeclaration "import io.netty.buffer.ByteBuf;" compose:Replacement merge: Default]
												[T -> io.netty.buffer.Unpooled{ImportPackage} : ImportDeclaration "import io.netty.buffer.Unpooled;" compose:Replacement merge: Default]
												[T -> io.netty.channel.Channel{ImportPackage} : ImportDeclaration "import io.netty.channel.Channel;" compose:Replacement merge: Default]
												[T -> io.netty.channel.ChannelFutureListener{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelFutureListener;" compose:Replacement merge: Default]
												[T -> io.netty.channel.ChannelHandlerContext{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandlerContext;" compose:Replacement merge: Default]
												[T -> io.netty.channel.ChannelOption{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelOption;" compose:Replacement merge: Default]
												[T -> io.netty.channel.SimpleChannelInboundHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.SimpleChannelInboundHandler;" compose:Replacement merge: Default]
												[NT -> UserChannelHandler : ClassDeclaration]
													[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
													[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
													[T -> UserChannelHandler : Id "UserChannelHandler" compose:Replacement merge: Default]
													[T -> - : ExtendsList "extends SimpleChannelInboundHandler<ByteBuf>" compose:Replacement merge: Default]
													[T -> userIdProducer : FieldDecl "private static AtomicLong userIdProducer = new AtomicLong(0);" compose:Replacement merge: SemanticConflict]
													[T -> exceptionCaught(ChannelHandlerContext-ChannelHandlerContext-Throwable-Throwable) : MethodDecl "@Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {          // 当出现异常就关闭连接         ctx.close();     }" compose:Replacement merge: LineBased]
													[T -> channelRead0(ChannelHandlerContext-ChannelHandlerContext-ByteBuf-ByteBuf) : MethodDecl "@Override     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();         if (proxyChannel == null) {             // 该端口还没有代理客户端             ctx.writeAndFlush(Unpooled.copiedBuffer("HTTP/1.0 503 Service Unavailable\r\nContent-Length: 14\r\n\r\nCLIENT OFFLINE".getBytes())).addListener(ChannelFutureListener.CLOSE);         } else {             byte[] bytes = new byte[buf.readableBytes()];             buf.readBytes(bytes);             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.P_TYPE_TRANSFER);             proxyMessage.setUri(userId);             proxyMessage.setData(bytes);             proxyChannel.writeAndFlush(proxyMessage);         }     }" compose:Replacement merge: LineBased]
													[T -> channelActive(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());          if (cmdChannel == null) {              // 该端口还没有代理客户端             // ctx.channel().close();         } else {             String userId = newUserId();             String lanInfo = ProxyConfig.getInstance().getLanInfo(sa.getPort());             // 用户连接到代理服务器时，设置用户连接不可读，等待代理后端服务器连接成功后再改变为可读状态             userChannel.config().setOption(ChannelOption.AUTO_READ, false);             ProxyChannelManager.addUserChannelToCmdChannel(cmdChannel, userId, userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.TYPE_CONNECT);             proxyMessage.setUri(userId);             proxyMessage.setData(lanInfo.getBytes());             cmdChannel.writeAndFlush(proxyMessage);         }          super.channelActive(ctx);     }" compose:Replacement merge: LineBased]
													[T -> channelInactive(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelInactive(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {              // 用户连接断开，从控制连接中移除             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyChannelManager.removeUserChannelFromCmdChannel(cmdChannel, userId);             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null && proxyChannel.isActive()) {                 proxyChannel.attr(Constants.NEXT_CHANNEL).remove();                 proxyChannel.attr(Constants.CLIENT_KEY).remove();                 proxyChannel.attr(Constants.USER_ID).remove();                  proxyChannel.config().setOption(ChannelOption.AUTO_READ, true);                 // 通知客户端，用户连接已经断开                 ProxyMessage proxyMessage = new ProxyMessage();                 proxyMessage.setType(ProxyMessage.TYPE_DISCONNECT);                 proxyMessage.setUri(userId);                 proxyChannel.writeAndFlush(proxyMessage);             }         }          super.channelInactive(ctx);     }" compose:Replacement merge: LineBased]
													[T -> channelWritabilityChanged(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null) {                 proxyChannel.config().setOption(ChannelOption.AUTO_READ, userChannel.isWritable());             }         }          super.channelWritabilityChanged(ctx);     }" compose:Replacement merge: LineBased]
													[T -> newUserId({FormalParametersInternal}) : MethodDecl "private static String newUserId() {         return String.valueOf(userIdProducer.incrementAndGet());     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> proxy-server : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> fengfei : Folder]
							[NT -> lanproxy : Folder]
								[NT -> server : Folder]
									[NT -> handlers : Folder]
										[NT -> UserChannelHandler.java.merge : .java.merge-File]
											[T -> UserChannelHandler.java : .java-Content "package org.fengfei.lanproxy.server.handlers;  import java.net.InetSocketAddress; import java.util.concurrent.atomic.AtomicLong;  import io.netty.buffer.Unpooled; import io.netty.channel.*; import io.netty.handler.codec.http.DefaultFullHttpResponse; import io.netty.handler.codec.http.FullHttpResponse; import io.netty.handler.codec.http.HttpResponseStatus; import io.netty.handler.codec.http.HttpVersion; import org.fengfei.lanproxy.protocol.Constants; import org.fengfei.lanproxy.protocol.ProxyMessage; import org.fengfei.lanproxy.server.ProxyChannelManager; import org.fengfei.lanproxy.server.config.ProxyConfig;  import io.netty.buffer.ByteBuf;  /**  * 处理服务端 channel.  */ public class UserChannelHandler extends SimpleChannelInboundHandler<ByteBuf> {      private static AtomicLong userIdProducer = new AtomicLong(0);      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {          // 当出现异常就关闭连接         ctx.close();     }      @Override     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();         if (proxyChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             byte[] bytes = new byte[buf.readableBytes()];             buf.readBytes(bytes);             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.P_TYPE_TRANSFER);             proxyMessage.setUri(userId);             proxyMessage.setData(bytes);             proxyChannel.writeAndFlush(proxyMessage);         }     }      @Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());          if (cmdChannel == null) {              // 该端口还没有代理客户端             FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.SERVICE_UNAVAILABLE);             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             String userId = newUserId();             String lanInfo = ProxyConfig.getInstance().getLanInfo(sa.getPort());             // 用户连接到代理服务器时，设置用户连接不可读，等待代理后端服务器连接成功后再改变为可读状态             userChannel.config().setOption(ChannelOption.AUTO_READ, false);             ProxyChannelManager.addUserChannelToCmdChannel(cmdChannel, userId, userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.TYPE_CONNECT);             proxyMessage.setUri(userId);             proxyMessage.setData(lanInfo.getBytes());             cmdChannel.writeAndFlush(proxyMessage);         }          super.channelActive(ctx);     }      @Override     public void channelInactive(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {              // 用户连接断开，从控制连接中移除             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyChannelManager.removeUserChannelFromCmdChannel(cmdChannel, userId);             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null && proxyChannel.isActive()) {                 proxyChannel.attr(Constants.NEXT_CHANNEL).remove();                 proxyChannel.attr(Constants.CLIENT_KEY).remove();                 proxyChannel.attr(Constants.USER_ID).remove();                  proxyChannel.config().setOption(ChannelOption.AUTO_READ, true);                 // 通知客户端，用户连接已经断开                 ProxyMessage proxyMessage = new ProxyMessage();                 proxyMessage.setType(ProxyMessage.TYPE_DISCONNECT);                 proxyMessage.setUri(userId);                 proxyChannel.writeAndFlush(proxyMessage);             }         }          super.channelInactive(ctx);     }      @Override     public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null) {                 proxyChannel.config().setOption(ChannelOption.AUTO_READ, userChannel.isWritable());             }         }          super.channelWritabilityChanged(ctx);     }      /**      * 为用户连接产生ID      *      * @return      */     private static String newUserId() {         return String.valueOf(userIdProducer.incrementAndGet());     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> proxy-server : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> fengfei : Folder]
							[NT -> lanproxy : Folder]
								[NT -> server : Folder]
									[NT -> handlers : Folder]
										[NT -> UserChannelHandler.java.merge : .java.merge-File]
											[T -> UserChannelHandler.java : .java-Content "package org.fengfei.lanproxy.server.handlers;  import java.net.InetSocketAddress; import java.util.concurrent.atomic.AtomicLong;  import org.fengfei.lanproxy.protocol.Constants; import org.fengfei.lanproxy.protocol.ProxyMessage; import org.fengfei.lanproxy.server.ProxyChannelManager; import org.fengfei.lanproxy.server.config.ProxyConfig;  import io.netty.buffer.ByteBuf; import io.netty.channel.Channel; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelOption; import io.netty.channel.SimpleChannelInboundHandler;  /**  * 处理服务端 channel.  */ public class UserChannelHandler extends SimpleChannelInboundHandler<ByteBuf> {      private static AtomicLong userIdProducer = new AtomicLong(0);      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {          // 当出现异常就关闭连接         ctx.close();     }      @Override     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();         if (proxyChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             byte[] bytes = new byte[buf.readableBytes()];             buf.readBytes(bytes);             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.P_TYPE_TRANSFER);             proxyMessage.setUri(userId);             proxyMessage.setData(bytes);             proxyChannel.writeAndFlush(proxyMessage);         }     }      @Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());          if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             String userId = newUserId();             String lanInfo = ProxyConfig.getInstance().getLanInfo(sa.getPort());             // 用户连接到代理服务器时，设置用户连接不可读，等待代理后端服务器连接成功后再改变为可读状态             userChannel.config().setOption(ChannelOption.AUTO_READ, false);             ProxyChannelManager.addUserChannelToCmdChannel(cmdChannel, userId, userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.TYPE_CONNECT);             proxyMessage.setUri(userId);             proxyMessage.setData(lanInfo.getBytes());             cmdChannel.writeAndFlush(proxyMessage);         }          super.channelActive(ctx);     }      @Override     public void channelInactive(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {              // 用户连接断开，从控制连接中移除             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyChannelManager.removeUserChannelFromCmdChannel(cmdChannel, userId);             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null && proxyChannel.isActive()) {                 proxyChannel.attr(Constants.NEXT_CHANNEL).remove();                 proxyChannel.attr(Constants.CLIENT_KEY).remove();                 proxyChannel.attr(Constants.USER_ID).remove();                  proxyChannel.config().setOption(ChannelOption.AUTO_READ, true);                 // 通知客户端，用户连接已经断开                 ProxyMessage proxyMessage = new ProxyMessage();                 proxyMessage.setType(ProxyMessage.TYPE_DISCONNECT);                 proxyMessage.setUri(userId);                 proxyChannel.writeAndFlush(proxyMessage);             }         }          super.channelInactive(ctx);     }      @Override     public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null) {                 proxyChannel.config().setOption(ChannelOption.AUTO_READ, userChannel.isWritable());             }         }          super.channelWritabilityChanged(ctx);     }      /**      * 为用户连接产生ID      *      * @return      */     private static String newUserId() {         return String.valueOf(userIdProducer.incrementAndGet());     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> proxy-server : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> fengfei : Folder]
							[NT -> lanproxy : Folder]
								[NT -> server : Folder]
									[NT -> handlers : Folder]
										[NT -> UserChannelHandler.java.merge : .java.merge-File]
											[T -> UserChannelHandler.java : .java-Content "package org.fengfei.lanproxy.server.handlers;  import java.net.InetSocketAddress; import java.util.concurrent.atomic.AtomicLong;  import org.fengfei.lanproxy.protocol.Constants; import org.fengfei.lanproxy.protocol.ProxyMessage; import org.fengfei.lanproxy.server.ProxyChannelManager; import org.fengfei.lanproxy.server.config.ProxyConfig;  import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.Channel; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelOption; import io.netty.channel.SimpleChannelInboundHandler;  /**  * 处理服务端 channel.  */ public class UserChannelHandler extends SimpleChannelInboundHandler<ByteBuf> {      private static AtomicLong userIdProducer = new AtomicLong(0);      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {          // 当出现异常就关闭连接         ctx.close();     }      @Override     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();         if (proxyChannel == null) {             // 该端口还没有代理客户端             ctx.writeAndFlush(Unpooled.copiedBuffer("HTTP/1.0 503 Service Unavailable\r\nContent-Length: 14\r\n\r\nCLIENT OFFLINE".getBytes())).addListener(ChannelFutureListener.CLOSE);         } else {             byte[] bytes = new byte[buf.readableBytes()];             buf.readBytes(bytes);             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.P_TYPE_TRANSFER);             proxyMessage.setUri(userId);             proxyMessage.setData(bytes);             proxyChannel.writeAndFlush(proxyMessage);         }     }      @Override     public void channelActive(ChannelHandlerContext ctx) throws Exception {         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());          if (cmdChannel == null) {              // 该端口还没有代理客户端             // ctx.channel().close();         } else {             String userId = newUserId();             String lanInfo = ProxyConfig.getInstance().getLanInfo(sa.getPort());             // 用户连接到代理服务器时，设置用户连接不可读，等待代理后端服务器连接成功后再改变为可读状态             userChannel.config().setOption(ChannelOption.AUTO_READ, false);             ProxyChannelManager.addUserChannelToCmdChannel(cmdChannel, userId, userChannel);             ProxyMessage proxyMessage = new ProxyMessage();             proxyMessage.setType(ProxyMessage.TYPE_CONNECT);             proxyMessage.setUri(userId);             proxyMessage.setData(lanInfo.getBytes());             cmdChannel.writeAndFlush(proxyMessage);         }          super.channelActive(ctx);     }      @Override     public void channelInactive(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {              // 用户连接断开，从控制连接中移除             String userId = ProxyChannelManager.getUserChannelUserId(userChannel);             ProxyChannelManager.removeUserChannelFromCmdChannel(cmdChannel, userId);             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null && proxyChannel.isActive()) {                 proxyChannel.attr(Constants.NEXT_CHANNEL).remove();                 proxyChannel.attr(Constants.CLIENT_KEY).remove();                 proxyChannel.attr(Constants.USER_ID).remove();                  proxyChannel.config().setOption(ChannelOption.AUTO_READ, true);                 // 通知客户端，用户连接已经断开                 ProxyMessage proxyMessage = new ProxyMessage();                 proxyMessage.setType(ProxyMessage.TYPE_DISCONNECT);                 proxyMessage.setUri(userId);                 proxyChannel.writeAndFlush(proxyMessage);             }         }          super.channelInactive(ctx);     }      @Override     public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {          // 通知代理客户端         Channel userChannel = ctx.channel();         InetSocketAddress sa = (InetSocketAddress) userChannel.localAddress();         Channel cmdChannel = ProxyChannelManager.getCmdChannel(sa.getPort());         if (cmdChannel == null) {              // 该端口还没有代理客户端             ctx.channel().close();         } else {             Channel proxyChannel = userChannel.attr(Constants.NEXT_CHANNEL).get();             if (proxyChannel != null) {                 proxyChannel.config().setOption(ChannelOption.AUTO_READ, userChannel.isWritable());             }         }          super.channelWritabilityChanged(ctx);     }      /**      * 为用户连接产生ID      *      * @return      */     private static String newUserId() {         return String.valueOf(userIdProducer.incrementAndGet());     } } " compose:StringConcatenation merge: LineBased]
