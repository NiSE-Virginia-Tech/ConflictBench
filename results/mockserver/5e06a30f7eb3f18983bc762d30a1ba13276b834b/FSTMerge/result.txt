Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/mockserver-netty/src/main/java/org/mockserver/mockserver/MockServerHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/mockserver-netty/src/main/java/org/mockserver/mockserver/MockServerHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/mockserver-netty/src/main/java/org/mockserver/mockserver/MockServerHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/mockserver-netty/src/main/java/org/mockserver/mockserver/MockServerHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/mockserver-netty/src/main/java/org/mockserver/mockserver/MockServerHandler.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/mockserver-netty/src/main/java/org/mockserver/mockserver/MockServerHandler.java
[NT -> left : Feature]
	[NT -> mockserver-netty : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> mockserver : Folder]
							[NT -> mockserver : Folder]
								[NT -> MockServerHandler.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package org.mockserver.mockserver;" compose:Replacement merge: Default]
										[T -> com.google.common.base.Joiner{ImportPackage} : ImportDeclaration "import com.google.common.base.Joiner;" compose:Replacement merge: Default]
										[T -> com.google.common.net.MediaType{ImportPackage} : ImportDeclaration "import com.google.common.net.MediaType;" compose:Replacement merge: Default]
										[T -> io.netty.buffer.Unpooled{ImportPackage} : ImportDeclaration "import io.netty.buffer.Unpooled;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelFutureListener{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelFutureListener;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandler;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelHandlerContext{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandlerContext;" compose:Replacement merge: Default]
										[T -> io.netty.channel.SimpleChannelInboundHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.SimpleChannelInboundHandler;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpResponseStatus{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpResponseStatus;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpServerCodec{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpServerCodec;" compose:Replacement merge: Default]
										[T -> org.mockserver.client.serialization.* : ImportDeclaration "import org.mockserver.client.serialization.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.filters.RequestLogFilter{ImportPackage} : ImportDeclaration "import org.mockserver.filters.RequestLogFilter;" compose:Replacement merge: Default]
										[T -> org.mockserver.logging.LogFormatter{ImportPackage} : ImportDeclaration "import org.mockserver.logging.LogFormatter;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.Expectation{ImportPackage} : ImportDeclaration "import org.mockserver.mock.Expectation;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.MockServerMatcher{ImportPackage} : ImportDeclaration "import org.mockserver.mock.MockServerMatcher;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.action.ActionHandler{ImportPackage} : ImportDeclaration "import org.mockserver.mock.action.ActionHandler;" compose:Replacement merge: Default]
										[T -> org.mockserver.mockserver.callback.ExpectationCallbackResponse{ImportPackage} : ImportDeclaration "import org.mockserver.mockserver.callback.ExpectationCallbackResponse;" compose:Replacement merge: Default]
										[T -> org.mockserver.mockserver.callback.WebSocketClientRegistry{ImportPackage} : ImportDeclaration "import org.mockserver.mockserver.callback.WebSocketClientRegistry;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.* : ImportDeclaration "import org.mockserver.model.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.socket.KeyStoreFactory{ImportPackage} : ImportDeclaration "import org.mockserver.socket.KeyStoreFactory;" compose:Replacement merge: Default]
										[T -> org.mockserver.validator.ExpectationValidator{ImportPackage} : ImportDeclaration "import org.mockserver.validator.ExpectationValidator;" compose:Replacement merge: Default]
										[T -> org.mockserver.verify.Verification{ImportPackage} : ImportDeclaration "import org.mockserver.verify.Verification;" compose:Replacement merge: Default]
										[T -> org.mockserver.verify.VerificationSequence{ImportPackage} : ImportDeclaration "import org.mockserver.verify.VerificationSequence;" compose:Replacement merge: Default]
										[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
										[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
										[T -> java.net.BindException{ImportPackage} : ImportDeclaration "import java.net.BindException;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.HOST{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.HOST;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.CONNECTION{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderValues.CLOSE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpResponseStatus.* : ImportDeclaration "import static io.netty.handler.codec.http.HttpResponseStatus.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI{ImportPackage} : ImportDeclaration "import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI;" compose:Replacement merge: Default]
										[T -> org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses{ImportPackage} : ImportDeclaration "import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.ConnectionOptions.connectionOptions{ImportPackage} : ImportDeclaration "import static org.mockserver.model.ConnectionOptions.connectionOptions;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.ConnectionOptions.isFalseOrNull{ImportPackage} : ImportDeclaration "import static org.mockserver.model.ConnectionOptions.isFalseOrNull;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.Header.header{ImportPackage} : ImportDeclaration "import static org.mockserver.model.Header.header;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.HttpResponse.notFoundResponse{ImportPackage} : ImportDeclaration "import static org.mockserver.model.HttpResponse.notFoundResponse;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.HttpResponse.response{ImportPackage} : ImportDeclaration "import static org.mockserver.model.HttpResponse.response;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.PortBinding.portBinding{ImportPackage} : ImportDeclaration "import static org.mockserver.model.PortBinding.portBinding;" compose:Replacement merge: Default]
										[NT -> MockServerHandler : ClassDeclaration]
											[T -> - : Modifiers "@ChannelHandler.Sharable public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> MockServerHandler : Id "MockServerHandler" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends SimpleChannelInboundHandler<HttpRequest>" compose:Replacement merge: Default]
											[T -> logger : FieldDecl "private final Logger logger = LoggerFactory.getLogger(this.getClass());" compose:Replacement merge: SemanticConflict]
											[T -> logFormatter : FieldDecl "private LogFormatter logFormatter = new LogFormatter(logger);" compose:Replacement merge: SemanticConflict]
											[T -> server : FieldDecl "private MockServer server;" compose:Replacement merge: SemanticConflict]
											[T -> requestLogFilter : FieldDecl "private RequestLogFilter requestLogFilter;" compose:Replacement merge: SemanticConflict]
											[T -> mockServerMatcher : FieldDecl "private MockServerMatcher mockServerMatcher;" compose:Replacement merge: SemanticConflict]
											[T -> webSocketClientRegistry : FieldDecl "private WebSocketClientRegistry webSocketClientRegistry;" compose:Replacement merge: SemanticConflict]
											[T -> actionHandler : FieldDecl "private ActionHandler actionHandler;" compose:Replacement merge: SemanticConflict]
											[T -> expectationSerializer : FieldDecl "private ExpectationSerializer expectationSerializer = new ExpectationSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> httpRequestSerializer : FieldDecl "private HttpRequestSerializer httpRequestSerializer = new HttpRequestSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> portBindingSerializer : FieldDecl "private PortBindingSerializer portBindingSerializer = new PortBindingSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> verificationSerializer : FieldDecl "private VerificationSerializer verificationSerializer = new VerificationSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> verificationSequenceSerializer : FieldDecl "private VerificationSequenceSerializer verificationSequenceSerializer = new VerificationSequenceSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> expectationValidator : FieldDecl "private ExpectationValidator expectationValidator = new ExpectationValidator();" compose:Replacement merge: SemanticConflict]
											[T -> MockServerHandler(MockServer-MockServer-MockServerMatcher-MockServerMatcher-WebSocketClientRegistry-WebSocketClientRegistry-RequestLogFilter-RequestLogFilter) : ConstructorDecl "public MockServerHandler(MockServer server, MockServerMatcher mockServerMatcher, WebSocketClientRegistry webSocketClientRegistry, RequestLogFilter requestLogFilter) {         this.server = server;         this.requestLogFilter = requestLogFilter;         this.mockServerMatcher = mockServerMatcher;         this.webSocketClientRegistry = webSocketClientRegistry;         actionHandler = new ActionHandler(requestLogFilter);     }" compose:Replacement merge: LineBased]
											[T -> channelRead0(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest) : MethodDecl "@Override     protected void channelRead0(final ChannelHandlerContext ctx, final HttpRequest request) {          try {              if ((enableCORSForAPI() || enableCORSForAllResponses()) && request.getMethod().getValue().equals("OPTIONS") && !request.getFirstHeader("Origin").isEmpty()) {                  writeResponse(ctx, request, OK);              } else if (request.matches("PUT", "/status")) {                  List<Integer> actualPortBindings = server.getPorts();                 writeResponse(ctx, request, OK, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");              } else if (request.matches("PUT", "/bind")) {                  PortBinding requestedPortBindings = portBindingSerializer.deserialize(request.getBodyAsString());                 try {                     List<Integer> actualPortBindings = server.bindToPorts(requestedPortBindings.getPorts());                     writeResponse(ctx, request, ACCEPTED, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");                 } catch (RuntimeException e) {                     if (e.getCause() instanceof BindException) {                         writeResponse(ctx, request, NOT_ACCEPTABLE, e.getMessage() + " port already in use", MediaType.create("text", "plain").toString());                     } else {                         throw e;                     }                 }              } else if (request.matches("PUT", "/expectation")) {                  Expectation expectation = expectationSerializer.deserialize(request.getBodyAsString());                 List<String> validationErrors = expectationValidator.isValid(expectation);                 if (validationErrors.isEmpty()) {                     KeyStoreFactory.addSubjectAlternativeName(expectation.getHttpRequest().getFirstHeader(HOST.toString()));                     mockServerMatcher                             .when(expectation.getHttpRequest(), expectation.getTimes(), expectation.getTimeToLive())                             .thenRespond(expectation.getHttpResponse())                             .thenForward(expectation.getHttpForward())                             .thenError(expectation.getHttpError())                             .thenCallback(expectation.getHttpClassCallback())                             .thenCallback(expectation.getHttpObjectCallback());                     logFormatter.infoLog("creating expectation:{}", expectation);                     writeResponse(ctx, request, HttpResponseStatus.CREATED);                 } else {                     String errorMessage = validationErrors.size() + " errors:\n - " + Joiner.on("\n - ").join(validationErrors) + "\n";                     writeResponse(ctx, request, NOT_ACCEPTABLE, errorMessage, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/clear")) {                  org.mockserver.model.HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     logFormatter.infoLog("clearing expectations that match:{}", httpRequest);                     mockServerMatcher.clear(httpRequest);                 } else if (request.hasQueryStringParameter("type", "log")) {                     logFormatter.infoLog("clearing request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                 } else {                     logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                     mockServerMatcher.clear(httpRequest);                 }                 logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/reset")) {                  requestLogFilter.reset();                 mockServerMatcher.reset();                 logFormatter.infoLog("resetting all expectations and request logs");                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/dumpToLog")) {                  mockServerMatcher.dumpToLog(httpRequestSerializer.deserialize(request.getBodyAsString()));                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/retrieve")) {                  HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     Expectation[] expectations = mockServerMatcher.retrieveExpectations(httpRequest);                     logFormatter.infoLog("retrieving expectations that match:{}", httpRequest);                     writeResponse(ctx, request, OK, expectationSerializer.serialize(expectations), "application/json");                 } else {                     HttpRequest[] requests = requestLogFilter.retrieve(httpRequest);                     logFormatter.infoLog("retrieving requests that match:{}", httpRequest);                     writeResponse(ctx, request, OK, httpRequestSerializer.serialize(requests), "application/json");                 }              } else if (request.matches("PUT", "/verify")) {                  Verification verification = verificationSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verification);                 logFormatter.infoLog("verifying requests that match:{}", verification);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/verifySequence")) {                  VerificationSequence verificationSequence = verificationSequenceSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verificationSequence);                 logFormatter.infoLog("verifying sequence that match:{}", verificationSequence);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/stop")) {                  ctx.writeAndFlush(response().withStatusCode(ACCEPTED.code()));                 new Thread(new Runnable() {                     @Override                     public void run() {                         server.stop();                     }                 }).start();              } else {                  Action handle = mockServerMatcher.retrieveAction(request);                 if (handle instanceof HttpError) {                     HttpError httpError = ((HttpError) handle).applyDelay();                     if (httpError.getResponseBytes() != null) {                         // write byte directly by skipping over HTTP codec                         ChannelHandlerContext httpCodecContext = ctx.pipeline().context(HttpServerCodec.class);                         if (httpCodecContext != null) {                             httpCodecContext.writeAndFlush(Unpooled.wrappedBuffer(httpError.getResponseBytes())).awaitUninterruptibly();                         }                     }                     if (httpError.getDropConnection()) {                         ctx.close();                     }                 } else if (handle instanceof HttpObjectCallback) {                     String clientId = ((HttpObjectCallback) handle).getClientId();                     webSocketClientRegistry.registerCallbackResponseHandler(clientId, new ExpectationCallbackResponse() {                         @Override                         public void handle(HttpResponse response) {                             logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                             writeResponse(ctx, request, response.withConnectionOptions(connectionOptions().withCloseSocket(true)));                         }                     });                     webSocketClientRegistry.sendClientMessage(clientId, request);                 } else {                     HttpResponse response = actionHandler.processAction(handle, request);                     logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                     writeResponse(ctx, request, response);                 }              }         } catch (Exception e) {             logger.error("Exception processing " + request, e);             writeResponse(ctx, request, response().withStatusCode(BAD_REQUEST.code()).withBody(e.getMessage()));         }      }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponseStatus-HttpResponseStatus) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus) {         writeResponse(ctx, request, responseStatus, "", "application/json");     }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponseStatus-HttpResponseStatus-String-String-String-String) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus, String body, String contentType) {         HttpResponse response = response()                 .withStatusCode(responseStatus.code())                 .withBody(body);         if (body != null && !body.isEmpty()) {             response.updateHeader(header(CONTENT_TYPE.toString(), contentType + "; charset=utf-8"));         }         if (enableCORSForAPI()) {             addCORSHeaders(response);         }         writeResponse(ctx, request, response);     }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         if (response == null) {             response = notFoundResponse();         }         if (enableCORSForAllResponses()) {             addCORSHeaders(response);         }          addConnectionHeader(request, response);          writeAndCloseSocket(ctx, request, response);     }" compose:Replacement merge: LineBased]
											[T -> addCORSHeaders(HttpResponse-HttpResponse) : MethodDecl "private void addCORSHeaders(HttpResponse response) {         String methods = "CONNECT, DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE";         String headers = "Allow, Content-Encoding, Content-Length, Content-Type, ETag, Expires, Last-Modified, Location, Server, Vary";         if (response.getFirstHeader("Access-Control-Allow-Origin").isEmpty()) {             response.withHeader("Access-Control-Allow-Origin", "*");         }         if (response.getFirstHeader("Access-Control-Allow-Methods").isEmpty()) {             response.withHeader("Access-Control-Allow-Methods", methods);         }         if (response.getFirstHeader("Access-Control-Allow-Headers").isEmpty()) {             response.withHeader("Access-Control-Allow-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Expose-Headers").isEmpty()) {             response.withHeader("Access-Control-Expose-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Max-Age").isEmpty()) {             response.withHeader("Access-Control-Max-Age", "1");         }         if (response.getFirstHeader("X-CORS").isEmpty()) {             response.withHeader("X-CORS", "MockServer CORS support enabled by default, to disable ConfigurationProperties.enableCORSForAPI(false) or -Dmockserver.disableCORS=false");         }     }" compose:Replacement merge: LineBased]
											[T -> addConnectionHeader(HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void addConnectionHeader(HttpRequest request, HttpResponse response) {         ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getKeepAliveOverride() != null) {             if (connectionOptions.getKeepAliveOverride()) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         } else if (connectionOptions == null || isFalseOrNull(connectionOptions.getSuppressConnectionHeader())) {             if (request.isKeepAlive() != null && request.isKeepAlive()                     && (connectionOptions == null || isFalseOrNull(connectionOptions.getCloseSocket()))) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         }     }" compose:Replacement merge: LineBased]
											[T -> writeAndCloseSocket(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void writeAndCloseSocket(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         boolean closeChannel;          ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getCloseSocket() != null) {             closeChannel = connectionOptions.getCloseSocket();         } else {             closeChannel = !(request.isKeepAlive() != null && request.isKeepAlive());         }          if (closeChannel) {             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             ctx.write(response);         }     }" compose:Replacement merge: LineBased]
											[T -> channelReadComplete(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     }" compose:Replacement merge: LineBased]
											[T -> exceptionCaught(ChannelHandlerContext-ChannelHandlerContext-Throwable-Throwable) : MethodDecl "@Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         if (!cause.getMessage().contains("Connection reset by peer")) {             logger.warn("Exception caught by MockServer handler -> closing pipeline", cause);         }         ctx.close();     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> mockserver-netty : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> mockserver : Folder]
							[NT -> mockserver : Folder]
								[NT -> MockServerHandler.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package org.mockserver.mockserver;" compose:Replacement merge: Default]
										[T -> com.google.common.base.Joiner{ImportPackage} : ImportDeclaration "import com.google.common.base.Joiner;" compose:Replacement merge: Default]
										[T -> com.google.common.net.MediaType{ImportPackage} : ImportDeclaration "import com.google.common.net.MediaType;" compose:Replacement merge: Default]
										[T -> io.netty.buffer.Unpooled{ImportPackage} : ImportDeclaration "import io.netty.buffer.Unpooled;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelFutureListener{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelFutureListener;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandler;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelHandlerContext{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandlerContext;" compose:Replacement merge: Default]
										[T -> io.netty.channel.SimpleChannelInboundHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.SimpleChannelInboundHandler;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpResponseStatus{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpResponseStatus;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpServerCodec{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpServerCodec;" compose:Replacement merge: Default]
										[T -> org.mockserver.client.serialization.* : ImportDeclaration "import org.mockserver.client.serialization.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.filters.RequestLogFilter{ImportPackage} : ImportDeclaration "import org.mockserver.filters.RequestLogFilter;" compose:Replacement merge: Default]
										[T -> org.mockserver.logging.LogFormatter{ImportPackage} : ImportDeclaration "import org.mockserver.logging.LogFormatter;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.Expectation{ImportPackage} : ImportDeclaration "import org.mockserver.mock.Expectation;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.MockServerMatcher{ImportPackage} : ImportDeclaration "import org.mockserver.mock.MockServerMatcher;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.action.ActionHandler{ImportPackage} : ImportDeclaration "import org.mockserver.mock.action.ActionHandler;" compose:Replacement merge: Default]
										[T -> org.mockserver.mockserver.callback.ExpectationCallbackResponse{ImportPackage} : ImportDeclaration "import org.mockserver.mockserver.callback.ExpectationCallbackResponse;" compose:Replacement merge: Default]
										[T -> org.mockserver.mockserver.callback.WebSocketClientRegistry{ImportPackage} : ImportDeclaration "import org.mockserver.mockserver.callback.WebSocketClientRegistry;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.* : ImportDeclaration "import org.mockserver.model.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.socket.SSLFactory{ImportPackage} : ImportDeclaration "import org.mockserver.socket.SSLFactory;" compose:Replacement merge: Default]
										[T -> org.mockserver.validator.ExpectationValidator{ImportPackage} : ImportDeclaration "import org.mockserver.validator.ExpectationValidator;" compose:Replacement merge: Default]
										[T -> org.mockserver.verify.Verification{ImportPackage} : ImportDeclaration "import org.mockserver.verify.Verification;" compose:Replacement merge: Default]
										[T -> org.mockserver.verify.VerificationSequence{ImportPackage} : ImportDeclaration "import org.mockserver.verify.VerificationSequence;" compose:Replacement merge: Default]
										[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
										[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
										[T -> java.net.BindException{ImportPackage} : ImportDeclaration "import java.net.BindException;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.HOST{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.HOST;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.CONNECTION{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderValues.CLOSE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpResponseStatus.* : ImportDeclaration "import static io.netty.handler.codec.http.HttpResponseStatus.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI{ImportPackage} : ImportDeclaration "import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI;" compose:Replacement merge: Default]
										[T -> org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses{ImportPackage} : ImportDeclaration "import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.ConnectionOptions.connectionOptions{ImportPackage} : ImportDeclaration "import static org.mockserver.model.ConnectionOptions.connectionOptions;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.ConnectionOptions.isFalseOrNull{ImportPackage} : ImportDeclaration "import static org.mockserver.model.ConnectionOptions.isFalseOrNull;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.Header.header{ImportPackage} : ImportDeclaration "import static org.mockserver.model.Header.header;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.HttpResponse.notFoundResponse{ImportPackage} : ImportDeclaration "import static org.mockserver.model.HttpResponse.notFoundResponse;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.HttpResponse.response{ImportPackage} : ImportDeclaration "import static org.mockserver.model.HttpResponse.response;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.PortBinding.portBinding{ImportPackage} : ImportDeclaration "import static org.mockserver.model.PortBinding.portBinding;" compose:Replacement merge: Default]
										[NT -> MockServerHandler : ClassDeclaration]
											[T -> - : Modifiers "@ChannelHandler.Sharable public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> MockServerHandler : Id "MockServerHandler" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends SimpleChannelInboundHandler<HttpRequest>" compose:Replacement merge: Default]
											[T -> logger : FieldDecl "private final Logger logger = LoggerFactory.getLogger(this.getClass());" compose:Replacement merge: SemanticConflict]
											[T -> logFormatter : FieldDecl "private LogFormatter logFormatter = new LogFormatter(logger);" compose:Replacement merge: SemanticConflict]
											[T -> server : FieldDecl "private MockServer server;" compose:Replacement merge: SemanticConflict]
											[T -> requestLogFilter : FieldDecl "private RequestLogFilter requestLogFilter;" compose:Replacement merge: SemanticConflict]
											[T -> mockServerMatcher : FieldDecl "private MockServerMatcher mockServerMatcher;" compose:Replacement merge: SemanticConflict]
											[T -> webSocketClientRegistry : FieldDecl "private WebSocketClientRegistry webSocketClientRegistry;" compose:Replacement merge: SemanticConflict]
											[T -> actionHandler : FieldDecl "private ActionHandler actionHandler;" compose:Replacement merge: SemanticConflict]
											[T -> expectationSerializer : FieldDecl "private ExpectationSerializer expectationSerializer = new ExpectationSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> httpRequestSerializer : FieldDecl "private HttpRequestSerializer httpRequestSerializer = new HttpRequestSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> portBindingSerializer : FieldDecl "private PortBindingSerializer portBindingSerializer = new PortBindingSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> verificationSerializer : FieldDecl "private VerificationSerializer verificationSerializer = new VerificationSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> verificationSequenceSerializer : FieldDecl "private VerificationSequenceSerializer verificationSequenceSerializer = new VerificationSequenceSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> expectationValidator : FieldDecl "private ExpectationValidator expectationValidator = new ExpectationValidator();" compose:Replacement merge: SemanticConflict]
											[T -> MockServerHandler(MockServer-MockServer-MockServerMatcher-MockServerMatcher-WebSocketClientRegistry-WebSocketClientRegistry-RequestLogFilter-RequestLogFilter) : ConstructorDecl "public MockServerHandler(MockServer server, MockServerMatcher mockServerMatcher, WebSocketClientRegistry webSocketClientRegistry, RequestLogFilter requestLogFilter) {         this.server = server;         this.requestLogFilter = requestLogFilter;         this.mockServerMatcher = mockServerMatcher;         this.webSocketClientRegistry = webSocketClientRegistry;         actionHandler = new ActionHandler(requestLogFilter);     }" compose:Replacement merge: LineBased]
											[T -> channelRead0(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest) : MethodDecl "@Override     protected void channelRead0(final ChannelHandlerContext ctx, final HttpRequest request) {          try {              if ((enableCORSForAPI() || enableCORSForAllResponses()) && request.getMethod().getValue().equals("OPTIONS") && !request.getFirstHeader("Origin").isEmpty()) {                  writeResponse(ctx, request, OK);              } else if (request.matches("PUT", "/status")) {                  List<Integer> actualPortBindings = server.getPorts();                 writeResponse(ctx, request, OK, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");              } else if (request.matches("PUT", "/bind")) {                  PortBinding requestedPortBindings = portBindingSerializer.deserialize(request.getBodyAsString());                 try {                     List<Integer> actualPortBindings = server.bindToPorts(requestedPortBindings.getPorts());                     writeResponse(ctx, request, ACCEPTED, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");                 } catch (RuntimeException e) {                     if (e.getCause() instanceof BindException) {                         writeResponse(ctx, request, NOT_ACCEPTABLE, e.getMessage() + " port already in use", MediaType.create("text", "plain").toString());                     } else {                         throw e;                     }                 }              } else if (request.matches("PUT", "/expectation")) {                  Expectation expectation = expectationSerializer.deserialize(request.getBodyAsString());                 List<String> validationErrors = expectationValidator.isValid(expectation);                 if (validationErrors.isEmpty()) {                     SSLFactory.addSubjectAlternativeName(expectation.getHttpRequest().getFirstHeader(HOST.toString()));                     mockServerMatcher                             .when(expectation.getHttpRequest(), expectation.getTimes(), expectation.getTimeToLive())                             .thenRespond(expectation.getHttpResponse())                             .thenForward(expectation.getHttpForward())                             .thenError(expectation.getHttpError())                             .thenCallback(expectation.getHttpClassCallback())                             .thenCallback(expectation.getHttpObjectCallback());                     logFormatter.infoLog("creating expectation:{}", expectation);                     writeResponse(ctx, request, HttpResponseStatus.CREATED);                 } else {                     String errorMessage = validationErrors.size() + " errors:\n - " + Joiner.on("\n - ").join(validationErrors) + "\n";                     writeResponse(ctx, request, NOT_ACCEPTABLE, errorMessage, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/clear")) {                  org.mockserver.model.HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     logFormatter.infoLog("clearing expectations that match:{}", httpRequest);                     mockServerMatcher.clear(httpRequest);                 } else if (request.hasQueryStringParameter("type", "log")) {                     logFormatter.infoLog("clearing request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                 } else {                     logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                     mockServerMatcher.clear(httpRequest);                 }                 logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/reset")) {                  requestLogFilter.reset();                 mockServerMatcher.reset();                 logFormatter.infoLog("resetting all expectations and request logs");                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/dumpToLog")) {                  mockServerMatcher.dumpToLog(httpRequestSerializer.deserialize(request.getBodyAsString()));                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/retrieve")) {                  HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     Expectation[] expectations = mockServerMatcher.retrieveExpectations(httpRequest);                     logFormatter.infoLog("retrieving expectations that match:{}", httpRequest);                     writeResponse(ctx, request, OK, expectationSerializer.serialize(expectations), "application/json");                 } else {                     HttpRequest[] requests = requestLogFilter.retrieve(httpRequest);                     logFormatter.infoLog("retrieving requests that match:{}", httpRequest);                     writeResponse(ctx, request, OK, httpRequestSerializer.serialize(requests), "application/json");                 }              } else if (request.matches("PUT", "/verify")) {                  Verification verification = verificationSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verification);                 logFormatter.infoLog("verifying requests that match:{}", verification);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/verifySequence")) {                  VerificationSequence verificationSequence = verificationSequenceSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verificationSequence);                 logFormatter.infoLog("verifying sequence that match:{}", verificationSequence);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/stop")) {                  ctx.writeAndFlush(response().withStatusCode(ACCEPTED.code()));                 new Thread(new Runnable() {                     @Override                     public void run() {                         server.stop();                     }                 }).start();              } else {                  Action handle = mockServerMatcher.retrieveAction(request);                 if (handle instanceof HttpError) {                     HttpError httpError = ((HttpError) handle).applyDelay();                     if (httpError.getResponseBytes() != null) {                         // write byte directly by skipping over HTTP codec                         ChannelHandlerContext httpCodecContext = ctx.pipeline().context(HttpServerCodec.class);                         if (httpCodecContext != null) {                             httpCodecContext.writeAndFlush(Unpooled.wrappedBuffer(httpError.getResponseBytes())).awaitUninterruptibly();                         }                     }                     if (httpError.getDropConnection()) {                         ctx.close();                     }                 } else if (handle instanceof HttpObjectCallback) {                     String clientId = ((HttpObjectCallback) handle).getClientId();                     webSocketClientRegistry.registerCallbackResponseHandler(clientId, new ExpectationCallbackResponse() {                         @Override                         public void handle(HttpResponse response) {                             logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                             writeResponse(ctx, request, response.withConnectionOptions(connectionOptions().withCloseSocket(true)));                         }                     });                     webSocketClientRegistry.sendClientMessage(clientId, request);                 } else {                     HttpResponse response = actionHandler.processAction(handle, request);                     logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                     writeResponse(ctx, request, response);                 }              }         } catch (Exception e) {             logger.error("Exception processing " + request, e);             writeResponse(ctx, request, response().withStatusCode(BAD_REQUEST.code()).withBody(e.getMessage()));         }      }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponseStatus-HttpResponseStatus) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus) {         writeResponse(ctx, request, responseStatus, "", "application/json");     }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponseStatus-HttpResponseStatus-String-String-String-String) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus, String body, String contentType) {         HttpResponse response = response()                 .withStatusCode(responseStatus.code())                 .withBody(body);         if (body != null && !body.isEmpty()) {             response.updateHeader(header(CONTENT_TYPE.toString(), contentType + "; charset=utf-8"));         }         if (enableCORSForAPI()) {             addCORSHeaders(response);         }         writeResponse(ctx, request, response);     }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         if (response == null) {             response = notFoundResponse();         }         if (enableCORSForAllResponses()) {             addCORSHeaders(response);         }          addConnectionHeader(request, response);          writeAndCloseSocket(ctx, request, response);     }" compose:Replacement merge: LineBased]
											[T -> addCORSHeaders(HttpResponse-HttpResponse) : MethodDecl "private void addCORSHeaders(HttpResponse response) {         String methods = "CONNECT, DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE";         String headers = "Allow, Content-Encoding, Content-Length, Content-Type, ETag, Expires, Last-Modified, Location, Server, Vary";         if (response.getFirstHeader("Access-Control-Allow-Origin").isEmpty()) {             response.withHeader("Access-Control-Allow-Origin", "*");         }         if (response.getFirstHeader("Access-Control-Allow-Methods").isEmpty()) {             response.withHeader("Access-Control-Allow-Methods", methods);         }         if (response.getFirstHeader("Access-Control-Allow-Headers").isEmpty()) {             response.withHeader("Access-Control-Allow-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Expose-Headers").isEmpty()) {             response.withHeader("Access-Control-Expose-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Max-Age").isEmpty()) {             response.withHeader("Access-Control-Max-Age", "1");         }         if (response.getFirstHeader("X-CORS").isEmpty()) {             response.withHeader("X-CORS", "MockServer CORS support enabled by default, to disable ConfigurationProperties.enableCORSForAPI(false) or -Dmockserver.disableCORS=false");         }     }" compose:Replacement merge: LineBased]
											[T -> addConnectionHeader(HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void addConnectionHeader(HttpRequest request, HttpResponse response) {         ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getKeepAliveOverride() != null) {             if (connectionOptions.getKeepAliveOverride()) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         } else if (connectionOptions == null || isFalseOrNull(connectionOptions.getSuppressConnectionHeader())) {             if (request.isKeepAlive() != null && request.isKeepAlive()                     && (connectionOptions == null || isFalseOrNull(connectionOptions.getCloseSocket()))) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         }     }" compose:Replacement merge: LineBased]
											[T -> writeAndCloseSocket(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void writeAndCloseSocket(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         boolean closeChannel;          ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getCloseSocket() != null) {             closeChannel = connectionOptions.getCloseSocket();         } else {             closeChannel = !(request.isKeepAlive() != null && request.isKeepAlive());         }          if (closeChannel) {             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             ctx.write(response);         }     }" compose:Replacement merge: LineBased]
											[T -> channelReadComplete(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     }" compose:Replacement merge: LineBased]
											[T -> exceptionCaught(ChannelHandlerContext-ChannelHandlerContext-Throwable-Throwable) : MethodDecl "@Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         if (!cause.getMessage().contains("Connection reset by peer")) {             logger.warn("Exception caught by MockServer handler -> closing pipeline", cause);         }         ctx.close();     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> mockserver-netty : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> mockserver : Folder]
							[NT -> mockserver : Folder]
								[NT -> MockServerHandler.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package org.mockserver.mockserver;" compose:Replacement merge: Default]
										[T -> com.google.common.base.Joiner{ImportPackage} : ImportDeclaration "import com.google.common.base.Joiner;" compose:Replacement merge: Default]
										[T -> com.google.common.net.MediaType{ImportPackage} : ImportDeclaration "import com.google.common.net.MediaType;" compose:Replacement merge: Default]
										[T -> io.netty.buffer.Unpooled{ImportPackage} : ImportDeclaration "import io.netty.buffer.Unpooled;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelFutureListener{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelFutureListener;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandler;" compose:Replacement merge: Default]
										[T -> io.netty.channel.ChannelHandlerContext{ImportPackage} : ImportDeclaration "import io.netty.channel.ChannelHandlerContext;" compose:Replacement merge: Default]
										[T -> io.netty.channel.SimpleChannelInboundHandler{ImportPackage} : ImportDeclaration "import io.netty.channel.SimpleChannelInboundHandler;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpResponseStatus{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpResponseStatus;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpServerCodec{ImportPackage} : ImportDeclaration "import io.netty.handler.codec.http.HttpServerCodec;" compose:Replacement merge: Default]
										[T -> org.mockserver.client.serialization.* : ImportDeclaration "import org.mockserver.client.serialization.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.filters.RequestLogFilter{ImportPackage} : ImportDeclaration "import org.mockserver.filters.RequestLogFilter;" compose:Replacement merge: Default]
										[T -> org.mockserver.logging.LogFormatter{ImportPackage} : ImportDeclaration "import org.mockserver.logging.LogFormatter;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.Expectation{ImportPackage} : ImportDeclaration "import org.mockserver.mock.Expectation;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.MockServerMatcher{ImportPackage} : ImportDeclaration "import org.mockserver.mock.MockServerMatcher;" compose:Replacement merge: Default]
										[T -> org.mockserver.mock.action.ActionHandler{ImportPackage} : ImportDeclaration "import org.mockserver.mock.action.ActionHandler;" compose:Replacement merge: Default]
										[T -> org.mockserver.mockserver.callback.ExpectationCallbackResponse{ImportPackage} : ImportDeclaration "import org.mockserver.mockserver.callback.ExpectationCallbackResponse;" compose:Replacement merge: Default]
										[T -> org.mockserver.mockserver.callback.WebSocketClientRegistry{ImportPackage} : ImportDeclaration "import org.mockserver.mockserver.callback.WebSocketClientRegistry;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.* : ImportDeclaration "import org.mockserver.model.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.socket.KeyStoreFactory{ImportPackage} : ImportDeclaration "import org.mockserver.socket.KeyStoreFactory;" compose:Replacement merge: Default]
										[T -> org.mockserver.socket.SSLFactory{ImportPackage} : ImportDeclaration "import org.mockserver.socket.SSLFactory;" compose:Replacement merge: Default]
										[T -> org.mockserver.validator.ExpectationValidator{ImportPackage} : ImportDeclaration "import org.mockserver.validator.ExpectationValidator;" compose:Replacement merge: Default]
										[T -> org.mockserver.verify.Verification{ImportPackage} : ImportDeclaration "import org.mockserver.verify.Verification;" compose:Replacement merge: Default]
										[T -> org.mockserver.verify.VerificationSequence{ImportPackage} : ImportDeclaration "import org.mockserver.verify.VerificationSequence;" compose:Replacement merge: Default]
										[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
										[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
										[T -> java.net.BindException{ImportPackage} : ImportDeclaration "import java.net.BindException;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderNames.* : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderNames.*;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderValues.CLOSE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE{ImportPackage} : ImportDeclaration "import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;" compose:Replacement merge: Default]
										[T -> io.netty.handler.codec.http.HttpResponseStatus.* : ImportDeclaration "import static io.netty.handler.codec.http.HttpResponseStatus.*;" compose:Replacement merge: Default]
										[T -> org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI{ImportPackage} : ImportDeclaration "import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI;" compose:Replacement merge: Default]
										[T -> org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses{ImportPackage} : ImportDeclaration "import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.ConnectionOptions.connectionOptions{ImportPackage} : ImportDeclaration "import static org.mockserver.model.ConnectionOptions.connectionOptions;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.ConnectionOptions.isFalseOrNull{ImportPackage} : ImportDeclaration "import static org.mockserver.model.ConnectionOptions.isFalseOrNull;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.Header.header{ImportPackage} : ImportDeclaration "import static org.mockserver.model.Header.header;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.HttpResponse.notFoundResponse{ImportPackage} : ImportDeclaration "import static org.mockserver.model.HttpResponse.notFoundResponse;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.HttpResponse.response{ImportPackage} : ImportDeclaration "import static org.mockserver.model.HttpResponse.response;" compose:Replacement merge: Default]
										[T -> org.mockserver.model.PortBinding.portBinding{ImportPackage} : ImportDeclaration "import static org.mockserver.model.PortBinding.portBinding;" compose:Replacement merge: Default]
										[NT -> MockServerHandler : ClassDeclaration]
											[T -> - : Modifiers "@ChannelHandler.Sharable public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> MockServerHandler : Id "MockServerHandler" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends SimpleChannelInboundHandler<HttpRequest>" compose:Replacement merge: Default]
											[T -> logger : FieldDecl "private final Logger logger = LoggerFactory.getLogger(this.getClass());" compose:Replacement merge: SemanticConflict]
											[T -> logFormatter : FieldDecl "private LogFormatter logFormatter = new LogFormatter(logger);" compose:Replacement merge: SemanticConflict]
											[T -> server : FieldDecl "private MockServer server;" compose:Replacement merge: SemanticConflict]
											[T -> requestLogFilter : FieldDecl "private RequestLogFilter requestLogFilter;" compose:Replacement merge: SemanticConflict]
											[T -> mockServerMatcher : FieldDecl "private MockServerMatcher mockServerMatcher;" compose:Replacement merge: SemanticConflict]
											[T -> webSocketClientRegistry : FieldDecl "private WebSocketClientRegistry webSocketClientRegistry;" compose:Replacement merge: SemanticConflict]
											[T -> actionHandler : FieldDecl "private ActionHandler actionHandler;" compose:Replacement merge: SemanticConflict]
											[T -> expectationSerializer : FieldDecl "private ExpectationSerializer expectationSerializer = new ExpectationSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> httpRequestSerializer : FieldDecl "private HttpRequestSerializer httpRequestSerializer = new HttpRequestSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> portBindingSerializer : FieldDecl "private PortBindingSerializer portBindingSerializer = new PortBindingSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> verificationSerializer : FieldDecl "private VerificationSerializer verificationSerializer = new VerificationSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> verificationSequenceSerializer : FieldDecl "private VerificationSequenceSerializer verificationSequenceSerializer = new VerificationSequenceSerializer();" compose:Replacement merge: SemanticConflict]
											[T -> expectationValidator : FieldDecl "private ExpectationValidator expectationValidator = new ExpectationValidator();" compose:Replacement merge: SemanticConflict]
											[T -> MockServerHandler(MockServer-MockServer-MockServerMatcher-MockServerMatcher-WebSocketClientRegistry-WebSocketClientRegistry-RequestLogFilter-RequestLogFilter) : ConstructorDecl "public MockServerHandler(MockServer server, MockServerMatcher mockServerMatcher, WebSocketClientRegistry webSocketClientRegistry, RequestLogFilter requestLogFilter) {         this.server = server;         this.requestLogFilter = requestLogFilter;         this.mockServerMatcher = mockServerMatcher;         this.webSocketClientRegistry = webSocketClientRegistry;         actionHandler = new ActionHandler(requestLogFilter);     }" compose:Replacement merge: LineBased]
											[T -> channelRead0(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest) : MethodDecl "@Override     protected void channelRead0(final ChannelHandlerContext ctx, final HttpRequest request) {          try {              if ((enableCORSForAPI() || enableCORSForAllResponses()) && request.getMethod().getValue().equals("OPTIONS") && !request.getFirstHeader("Origin").isEmpty()) {                  writeResponse(ctx, request, OK);              } else if (request.matches("PUT", "/status")) {                  List<Integer> actualPortBindings = server.getPorts();                 writeResponse(ctx, request, OK, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");              } else if (request.matches("PUT", "/bind")) {                  PortBinding requestedPortBindings = portBindingSerializer.deserialize(request.getBodyAsString());                 try {                     List<Integer> actualPortBindings = server.bindToPorts(requestedPortBindings.getPorts());                     writeResponse(ctx, request, ACCEPTED, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");                 } catch (RuntimeException e) {                     if (e.getCause() instanceof BindException) {                         writeResponse(ctx, request, NOT_ACCEPTABLE, e.getMessage() + " port already in use", MediaType.create("text", "plain").toString());                     } else {                         throw e;                     }                 }              } else if (request.matches("PUT", "/expectation")) {                  for (Expectation expectation : expectationSerializer.deserializeArray(request.getBodyAsString())) {                     List<String> validationErrors = expectationValidator.isValid(expectation);                     if (validationErrors.isEmpty()) {                         SSLFactory.addSubjectAlternativeName(expectation.getHttpRequest().getFirstHeader(HOST.toString()));                         mockServerMatcher                                 .when(expectation.getHttpRequest(), expectation.getTimes(), expectation.getTimeToLive())                                 .thenRespond(expectation.getHttpResponse())                                 .thenForward(expectation.getHttpForward())                                 .thenError(expectation.getHttpError())                                 .thenCallback(expectation.getHttpClassCallback())                                 .thenCallback(expectation.getHttpObjectCallback());                         logFormatter.infoLog("creating expectation:{}", expectation);                         writeResponse(ctx, request, HttpResponseStatus.CREATED);                     } else {                         String errorMessage = validationErrors.size() + " errors:\n - " + Joiner.on("\n - ").join(validationErrors) + "\n";                         writeResponse(ctx, request, NOT_ACCEPTABLE, errorMessage, MediaType.create("text", "plain").toString());                     }                 }              } else if (request.matches("PUT", "/clear")) {                  org.mockserver.model.HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     logFormatter.infoLog("clearing expectations that match:{}", httpRequest);                     mockServerMatcher.clear(httpRequest);                 } else if (request.hasQueryStringParameter("type", "log")) {                     logFormatter.infoLog("clearing request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                 } else {                     logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                     mockServerMatcher.clear(httpRequest);                 }                 logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/reset")) {                  requestLogFilter.reset();                 mockServerMatcher.reset();                 logFormatter.infoLog("resetting all expectations and request logs");                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/dumpToLog")) {                  mockServerMatcher.dumpToLog(httpRequestSerializer.deserialize(request.getBodyAsString()));                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/retrieve")) {                  HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     Expectation[] expectations = mockServerMatcher.retrieveExpectations(httpRequest);                     logFormatter.infoLog("retrieving expectations that match:{}", httpRequest);                     writeResponse(ctx, request, OK, expectationSerializer.serialize(expectations), "application/json");                 } else {                     HttpRequest[] requests = requestLogFilter.retrieve(httpRequest);                     logFormatter.infoLog("retrieving requests that match:{}", httpRequest);                     writeResponse(ctx, request, OK, httpRequestSerializer.serialize(requests), "application/json");                 }              } else if (request.matches("PUT", "/verify")) {                  Verification verification = verificationSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verification);                 logFormatter.infoLog("verifying requests that match:{}", verification);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/verifySequence")) {                  VerificationSequence verificationSequence = verificationSequenceSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verificationSequence);                 logFormatter.infoLog("verifying sequence that match:{}", verificationSequence);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/stop")) {                  ctx.writeAndFlush(response().withStatusCode(ACCEPTED.code()));                 new Thread(new Runnable() {                     @Override                     public void run() {                         server.stop();                     }                 }).start();              } else {                  Action handle = mockServerMatcher.retrieveAction(request);                 if (handle instanceof HttpError) {                     HttpError httpError = ((HttpError) handle).applyDelay();                     if (httpError.getResponseBytes() != null) {                         // write byte directly by skipping over HTTP codec                         ChannelHandlerContext httpCodecContext = ctx.pipeline().context(HttpServerCodec.class);                         if (httpCodecContext != null) {                             httpCodecContext.writeAndFlush(Unpooled.wrappedBuffer(httpError.getResponseBytes())).awaitUninterruptibly();                         }                     }                     if (httpError.getDropConnection()) {                         ctx.close();                     }                 } else if (handle instanceof HttpObjectCallback) {                     String clientId = ((HttpObjectCallback) handle).getClientId();                     webSocketClientRegistry.registerCallbackResponseHandler(clientId, new ExpectationCallbackResponse() {                         @Override                         public void handle(HttpResponse response) {                             logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                             writeResponse(ctx, request, response.withConnectionOptions(connectionOptions().withCloseSocket(true)));                         }                     });                     webSocketClientRegistry.sendClientMessage(clientId, request);                 } else {                     HttpResponse response = actionHandler.processAction(handle, request);                     logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                     writeResponse(ctx, request, response);                 }              }         } catch (Exception e) {             logger.error("Exception processing " + request, e);             writeResponse(ctx, request, response().withStatusCode(BAD_REQUEST.code()).withBody(e.getMessage()));         }      }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponseStatus-HttpResponseStatus) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus) {         writeResponse(ctx, request, responseStatus, "", "application/json");     }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponseStatus-HttpResponseStatus-String-String-String-String) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus, String body, String contentType) {         HttpResponse response = response()                 .withStatusCode(responseStatus.code())                 .withBody(body);         if (body != null && !body.isEmpty()) {             response.updateHeader(header(CONTENT_TYPE.toString(), contentType + "; charset=utf-8"));         }         if (enableCORSForAPI()) {             addCORSHeaders(response);         }         writeResponse(ctx, request, response);     }" compose:Replacement merge: LineBased]
											[T -> writeResponse(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         if (response == null) {             response = notFoundResponse();         }         if (enableCORSForAllResponses()) {             addCORSHeaders(response);         }          addConnectionHeader(request, response);          writeAndCloseSocket(ctx, request, response);     }" compose:Replacement merge: LineBased]
											[T -> addCORSHeaders(HttpResponse-HttpResponse) : MethodDecl "private void addCORSHeaders(HttpResponse response) {         String methods = "CONNECT, DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE";         String headers = "Allow, Content-Encoding, Content-Length, Content-Type, ETag, Expires, Last-Modified, Location, Server, Vary";         if (response.getFirstHeader("Access-Control-Allow-Origin").isEmpty()) {             response.withHeader("Access-Control-Allow-Origin", "*");         }         if (response.getFirstHeader("Access-Control-Allow-Methods").isEmpty()) {             response.withHeader("Access-Control-Allow-Methods", methods);         }         if (response.getFirstHeader("Access-Control-Allow-Headers").isEmpty()) {             response.withHeader("Access-Control-Allow-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Expose-Headers").isEmpty()) {             response.withHeader("Access-Control-Expose-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Max-Age").isEmpty()) {             response.withHeader("Access-Control-Max-Age", "1");         }         if (response.getFirstHeader("X-CORS").isEmpty()) {             response.withHeader("X-CORS", "MockServer CORS support enabled by default, to disable ConfigurationProperties.enableCORSForAPI(false) or -Dmockserver.disableCORS=false");         }     }" compose:Replacement merge: LineBased]
											[T -> addConnectionHeader(HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void addConnectionHeader(HttpRequest request, HttpResponse response) {         ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getKeepAliveOverride() != null) {             if (connectionOptions.getKeepAliveOverride()) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         } else if (connectionOptions == null || isFalseOrNull(connectionOptions.getSuppressConnectionHeader())) {             if (request.isKeepAlive() != null && request.isKeepAlive()                     && (connectionOptions == null || isFalseOrNull(connectionOptions.getCloseSocket()))) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         }     }" compose:Replacement merge: LineBased]
											[T -> writeAndCloseSocket(ChannelHandlerContext-ChannelHandlerContext-HttpRequest-HttpRequest-HttpResponse-HttpResponse) : MethodDecl "private void writeAndCloseSocket(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         boolean closeChannel;          ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getCloseSocket() != null) {             closeChannel = connectionOptions.getCloseSocket();         } else {             closeChannel = !(request.isKeepAlive() != null && request.isKeepAlive());         }          if (closeChannel) {             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             ctx.write(response);         }     }" compose:Replacement merge: LineBased]
											[T -> channelReadComplete(ChannelHandlerContext-ChannelHandlerContext) : MethodDecl "@Override     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     }" compose:Replacement merge: LineBased]
											[T -> exceptionCaught(ChannelHandlerContext-ChannelHandlerContext-Throwable-Throwable) : MethodDecl "@Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         if (!cause.getMessage().contains("Connection reset by peer")) {             logger.warn("Exception caught by MockServer handler -> closing pipeline", cause);         }         ctx.close();     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> mockserver-netty : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> mockserver : Folder]
							[NT -> mockserver : Folder]
								[NT -> MockServerHandler.java.merge : .java.merge-File]
									[T -> MockServerHandler.java : .java-Content "package org.mockserver.mockserver;  import com.google.common.base.Joiner; import com.google.common.net.MediaType; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.HttpResponseStatus; import io.netty.handler.codec.http.HttpServerCodec; import org.mockserver.client.serialization.*; import org.mockserver.filters.RequestLogFilter; import org.mockserver.logging.LogFormatter; import org.mockserver.mock.Expectation; import org.mockserver.mock.MockServerMatcher; import org.mockserver.mock.action.ActionHandler; import org.mockserver.mockserver.callback.ExpectationCallbackResponse; import org.mockserver.mockserver.callback.WebSocketClientRegistry; import org.mockserver.model.*; import org.mockserver.socket.KeyStoreFactory; import org.mockserver.validator.ExpectationValidator; import org.mockserver.verify.Verification; import org.mockserver.verify.VerificationSequence; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import java.net.BindException; import java.util.List;  import static io.netty.handler.codec.http.HttpHeaderNames.HOST; import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION; import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE; import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE; import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE; import static io.netty.handler.codec.http.HttpResponseStatus.*; import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI; import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses; import static org.mockserver.model.ConnectionOptions.connectionOptions; import static org.mockserver.model.ConnectionOptions.isFalseOrNull; import static org.mockserver.model.Header.header; import static org.mockserver.model.HttpResponse.notFoundResponse; import static org.mockserver.model.HttpResponse.response; import static org.mockserver.model.PortBinding.portBinding;  @ChannelHandler.Sharable public class MockServerHandler extends SimpleChannelInboundHandler<HttpRequest> {      private final Logger logger = LoggerFactory.getLogger(this.getClass());     private LogFormatter logFormatter = new LogFormatter(logger);     // mockserver     private MockServer server;     private RequestLogFilter requestLogFilter;     private MockServerMatcher mockServerMatcher;     private WebSocketClientRegistry webSocketClientRegistry;     private ActionHandler actionHandler;     // serializers     private ExpectationSerializer expectationSerializer = new ExpectationSerializer();     private HttpRequestSerializer httpRequestSerializer = new HttpRequestSerializer();     private PortBindingSerializer portBindingSerializer = new PortBindingSerializer();     private VerificationSerializer verificationSerializer = new VerificationSerializer();     private VerificationSequenceSerializer verificationSequenceSerializer = new VerificationSequenceSerializer();     // validators     private ExpectationValidator expectationValidator = new ExpectationValidator();      public MockServerHandler(MockServer server, MockServerMatcher mockServerMatcher, WebSocketClientRegistry webSocketClientRegistry, RequestLogFilter requestLogFilter) {         this.server = server;         this.requestLogFilter = requestLogFilter;         this.mockServerMatcher = mockServerMatcher;         this.webSocketClientRegistry = webSocketClientRegistry;         actionHandler = new ActionHandler(requestLogFilter);     }      @Override     protected void channelRead0(final ChannelHandlerContext ctx, final HttpRequest request) {          try {              if ((enableCORSForAPI() || enableCORSForAllResponses()) && request.getMethod().getValue().equals("OPTIONS") && !request.getFirstHeader("Origin").isEmpty()) {                  writeResponse(ctx, request, OK);              } else if (request.matches("PUT", "/status")) {                  List<Integer> actualPortBindings = server.getPorts();                 writeResponse(ctx, request, OK, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");              } else if (request.matches("PUT", "/bind")) {                  PortBinding requestedPortBindings = portBindingSerializer.deserialize(request.getBodyAsString());                 try {                     List<Integer> actualPortBindings = server.bindToPorts(requestedPortBindings.getPorts());                     writeResponse(ctx, request, ACCEPTED, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");                 } catch (RuntimeException e) {                     if (e.getCause() instanceof BindException) {                         writeResponse(ctx, request, NOT_ACCEPTABLE, e.getMessage() + " port already in use", MediaType.create("text", "plain").toString());                     } else {                         throw e;                     }                 }              } else if (request.matches("PUT", "/expectation")) {                  Expectation expectation = expectationSerializer.deserialize(request.getBodyAsString());                 List<String> validationErrors = expectationValidator.isValid(expectation);                 if (validationErrors.isEmpty()) {                     KeyStoreFactory.addSubjectAlternativeName(expectation.getHttpRequest().getFirstHeader(HOST.toString()));                     mockServerMatcher                             .when(expectation.getHttpRequest(), expectation.getTimes(), expectation.getTimeToLive())                             .thenRespond(expectation.getHttpResponse())                             .thenForward(expectation.getHttpForward())                             .thenError(expectation.getHttpError())                             .thenCallback(expectation.getHttpClassCallback())                             .thenCallback(expectation.getHttpObjectCallback());                     logFormatter.infoLog("creating expectation:{}", expectation);                     writeResponse(ctx, request, HttpResponseStatus.CREATED);                 } else {                     String errorMessage = validationErrors.size() + " errors:\n - " + Joiner.on("\n - ").join(validationErrors) + "\n";                     writeResponse(ctx, request, NOT_ACCEPTABLE, errorMessage, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/clear")) {                  org.mockserver.model.HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     logFormatter.infoLog("clearing expectations that match:{}", httpRequest);                     mockServerMatcher.clear(httpRequest);                 } else if (request.hasQueryStringParameter("type", "log")) {                     logFormatter.infoLog("clearing request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                 } else {                     logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                     mockServerMatcher.clear(httpRequest);                 }                 logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/reset")) {                  requestLogFilter.reset();                 mockServerMatcher.reset();                 logFormatter.infoLog("resetting all expectations and request logs");                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/dumpToLog")) {                  mockServerMatcher.dumpToLog(httpRequestSerializer.deserialize(request.getBodyAsString()));                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/retrieve")) {                  HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     Expectation[] expectations = mockServerMatcher.retrieveExpectations(httpRequest);                     logFormatter.infoLog("retrieving expectations that match:{}", httpRequest);                     writeResponse(ctx, request, OK, expectationSerializer.serialize(expectations), "application/json");                 } else {                     HttpRequest[] requests = requestLogFilter.retrieve(httpRequest);                     logFormatter.infoLog("retrieving requests that match:{}", httpRequest);                     writeResponse(ctx, request, OK, httpRequestSerializer.serialize(requests), "application/json");                 }              } else if (request.matches("PUT", "/verify")) {                  Verification verification = verificationSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verification);                 logFormatter.infoLog("verifying requests that match:{}", verification);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/verifySequence")) {                  VerificationSequence verificationSequence = verificationSequenceSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verificationSequence);                 logFormatter.infoLog("verifying sequence that match:{}", verificationSequence);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/stop")) {                  ctx.writeAndFlush(response().withStatusCode(ACCEPTED.code()));                 new Thread(new Runnable() {                     @Override                     public void run() {                         server.stop();                     }                 }).start();              } else {                  Action handle = mockServerMatcher.retrieveAction(request);                 if (handle instanceof HttpError) {                     HttpError httpError = ((HttpError) handle).applyDelay();                     if (httpError.getResponseBytes() != null) {                         // write byte directly by skipping over HTTP codec                         ChannelHandlerContext httpCodecContext = ctx.pipeline().context(HttpServerCodec.class);                         if (httpCodecContext != null) {                             httpCodecContext.writeAndFlush(Unpooled.wrappedBuffer(httpError.getResponseBytes())).awaitUninterruptibly();                         }                     }                     if (httpError.getDropConnection()) {                         ctx.close();                     }                 } else if (handle instanceof HttpObjectCallback) {                     String clientId = ((HttpObjectCallback) handle).getClientId();                     webSocketClientRegistry.registerCallbackResponseHandler(clientId, new ExpectationCallbackResponse() {                         @Override                         public void handle(HttpResponse response) {                             logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                             writeResponse(ctx, request, response.withConnectionOptions(connectionOptions().withCloseSocket(true)));                         }                     });                     webSocketClientRegistry.sendClientMessage(clientId, request);                 } else {                     HttpResponse response = actionHandler.processAction(handle, request);                     logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                     writeResponse(ctx, request, response);                 }              }         } catch (Exception e) {             logger.error("Exception processing " + request, e);             writeResponse(ctx, request, response().withStatusCode(BAD_REQUEST.code()).withBody(e.getMessage()));         }      }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus) {         writeResponse(ctx, request, responseStatus, "", "application/json");     }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus, String body, String contentType) {         HttpResponse response = response()                 .withStatusCode(responseStatus.code())                 .withBody(body);         if (body != null && !body.isEmpty()) {             response.updateHeader(header(CONTENT_TYPE.toString(), contentType + "; charset=utf-8"));         }         if (enableCORSForAPI()) {             addCORSHeaders(response);         }         writeResponse(ctx, request, response);     }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         if (response == null) {             response = notFoundResponse();         }         if (enableCORSForAllResponses()) {             addCORSHeaders(response);         }          addConnectionHeader(request, response);          writeAndCloseSocket(ctx, request, response);     }      private void addCORSHeaders(HttpResponse response) {         String methods = "CONNECT, DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE";         String headers = "Allow, Content-Encoding, Content-Length, Content-Type, ETag, Expires, Last-Modified, Location, Server, Vary";         if (response.getFirstHeader("Access-Control-Allow-Origin").isEmpty()) {             response.withHeader("Access-Control-Allow-Origin", "*");         }         if (response.getFirstHeader("Access-Control-Allow-Methods").isEmpty()) {             response.withHeader("Access-Control-Allow-Methods", methods);         }         if (response.getFirstHeader("Access-Control-Allow-Headers").isEmpty()) {             response.withHeader("Access-Control-Allow-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Expose-Headers").isEmpty()) {             response.withHeader("Access-Control-Expose-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Max-Age").isEmpty()) {             response.withHeader("Access-Control-Max-Age", "1");         }         if (response.getFirstHeader("X-CORS").isEmpty()) {             response.withHeader("X-CORS", "MockServer CORS support enabled by default, to disable ConfigurationProperties.enableCORSForAPI(false) or -Dmockserver.disableCORS=false");         }     }      private void addConnectionHeader(HttpRequest request, HttpResponse response) {         ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getKeepAliveOverride() != null) {             if (connectionOptions.getKeepAliveOverride()) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         } else if (connectionOptions == null || isFalseOrNull(connectionOptions.getSuppressConnectionHeader())) {             if (request.isKeepAlive() != null && request.isKeepAlive()                     && (connectionOptions == null || isFalseOrNull(connectionOptions.getCloseSocket()))) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         }     }      private void writeAndCloseSocket(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         boolean closeChannel;          ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getCloseSocket() != null) {             closeChannel = connectionOptions.getCloseSocket();         } else {             closeChannel = !(request.isKeepAlive() != null && request.isKeepAlive());         }          if (closeChannel) {             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             ctx.write(response);         }     }      @Override     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     }      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         if (!cause.getMessage().contains("Connection reset by peer")) {             logger.warn("Exception caught by MockServer handler -> closing pipeline", cause);         }         ctx.close();     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> mockserver-netty : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> mockserver : Folder]
							[NT -> mockserver : Folder]
								[NT -> MockServerHandler.java.merge : .java.merge-File]
									[T -> MockServerHandler.java : .java-Content "package org.mockserver.mockserver;  import com.google.common.base.Joiner; import com.google.common.net.MediaType; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.HttpResponseStatus; import io.netty.handler.codec.http.HttpServerCodec; import org.mockserver.client.serialization.*; import org.mockserver.filters.RequestLogFilter; import org.mockserver.logging.LogFormatter; import org.mockserver.mock.Expectation; import org.mockserver.mock.MockServerMatcher; import org.mockserver.mock.action.ActionHandler; import org.mockserver.mockserver.callback.ExpectationCallbackResponse; import org.mockserver.mockserver.callback.WebSocketClientRegistry; import org.mockserver.model.*; import org.mockserver.socket.SSLFactory; import org.mockserver.validator.ExpectationValidator; import org.mockserver.verify.Verification; import org.mockserver.verify.VerificationSequence; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import java.net.BindException; import java.util.List;  import static io.netty.handler.codec.http.HttpHeaderNames.HOST; import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION; import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE; import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE; import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE; import static io.netty.handler.codec.http.HttpResponseStatus.*; import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI; import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses; import static org.mockserver.model.ConnectionOptions.connectionOptions; import static org.mockserver.model.ConnectionOptions.isFalseOrNull; import static org.mockserver.model.Header.header; import static org.mockserver.model.HttpResponse.notFoundResponse; import static org.mockserver.model.HttpResponse.response; import static org.mockserver.model.PortBinding.portBinding;  @ChannelHandler.Sharable public class MockServerHandler extends SimpleChannelInboundHandler<HttpRequest> {      private final Logger logger = LoggerFactory.getLogger(this.getClass());     private LogFormatter logFormatter = new LogFormatter(logger);     // mockserver     private MockServer server;     private RequestLogFilter requestLogFilter;     private MockServerMatcher mockServerMatcher;     private WebSocketClientRegistry webSocketClientRegistry;     private ActionHandler actionHandler;     // serializers     private ExpectationSerializer expectationSerializer = new ExpectationSerializer();     private HttpRequestSerializer httpRequestSerializer = new HttpRequestSerializer();     private PortBindingSerializer portBindingSerializer = new PortBindingSerializer();     private VerificationSerializer verificationSerializer = new VerificationSerializer();     private VerificationSequenceSerializer verificationSequenceSerializer = new VerificationSequenceSerializer();     // validators     private ExpectationValidator expectationValidator = new ExpectationValidator();      public MockServerHandler(MockServer server, MockServerMatcher mockServerMatcher, WebSocketClientRegistry webSocketClientRegistry, RequestLogFilter requestLogFilter) {         this.server = server;         this.requestLogFilter = requestLogFilter;         this.mockServerMatcher = mockServerMatcher;         this.webSocketClientRegistry = webSocketClientRegistry;         actionHandler = new ActionHandler(requestLogFilter);     }      @Override     protected void channelRead0(final ChannelHandlerContext ctx, final HttpRequest request) {          try {              if ((enableCORSForAPI() || enableCORSForAllResponses()) && request.getMethod().getValue().equals("OPTIONS") && !request.getFirstHeader("Origin").isEmpty()) {                  writeResponse(ctx, request, OK);              } else if (request.matches("PUT", "/status")) {                  List<Integer> actualPortBindings = server.getPorts();                 writeResponse(ctx, request, OK, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");              } else if (request.matches("PUT", "/bind")) {                  PortBinding requestedPortBindings = portBindingSerializer.deserialize(request.getBodyAsString());                 try {                     List<Integer> actualPortBindings = server.bindToPorts(requestedPortBindings.getPorts());                     writeResponse(ctx, request, ACCEPTED, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");                 } catch (RuntimeException e) {                     if (e.getCause() instanceof BindException) {                         writeResponse(ctx, request, NOT_ACCEPTABLE, e.getMessage() + " port already in use", MediaType.create("text", "plain").toString());                     } else {                         throw e;                     }                 }              } else if (request.matches("PUT", "/expectation")) {                  Expectation expectation = expectationSerializer.deserialize(request.getBodyAsString());                 List<String> validationErrors = expectationValidator.isValid(expectation);                 if (validationErrors.isEmpty()) {                     SSLFactory.addSubjectAlternativeName(expectation.getHttpRequest().getFirstHeader(HOST.toString()));                     mockServerMatcher                             .when(expectation.getHttpRequest(), expectation.getTimes(), expectation.getTimeToLive())                             .thenRespond(expectation.getHttpResponse())                             .thenForward(expectation.getHttpForward())                             .thenError(expectation.getHttpError())                             .thenCallback(expectation.getHttpClassCallback())                             .thenCallback(expectation.getHttpObjectCallback());                     logFormatter.infoLog("creating expectation:{}", expectation);                     writeResponse(ctx, request, HttpResponseStatus.CREATED);                 } else {                     String errorMessage = validationErrors.size() + " errors:\n - " + Joiner.on("\n - ").join(validationErrors) + "\n";                     writeResponse(ctx, request, NOT_ACCEPTABLE, errorMessage, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/clear")) {                  org.mockserver.model.HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     logFormatter.infoLog("clearing expectations that match:{}", httpRequest);                     mockServerMatcher.clear(httpRequest);                 } else if (request.hasQueryStringParameter("type", "log")) {                     logFormatter.infoLog("clearing request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                 } else {                     logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                     mockServerMatcher.clear(httpRequest);                 }                 logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/reset")) {                  requestLogFilter.reset();                 mockServerMatcher.reset();                 logFormatter.infoLog("resetting all expectations and request logs");                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/dumpToLog")) {                  mockServerMatcher.dumpToLog(httpRequestSerializer.deserialize(request.getBodyAsString()));                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/retrieve")) {                  HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     Expectation[] expectations = mockServerMatcher.retrieveExpectations(httpRequest);                     logFormatter.infoLog("retrieving expectations that match:{}", httpRequest);                     writeResponse(ctx, request, OK, expectationSerializer.serialize(expectations), "application/json");                 } else {                     HttpRequest[] requests = requestLogFilter.retrieve(httpRequest);                     logFormatter.infoLog("retrieving requests that match:{}", httpRequest);                     writeResponse(ctx, request, OK, httpRequestSerializer.serialize(requests), "application/json");                 }              } else if (request.matches("PUT", "/verify")) {                  Verification verification = verificationSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verification);                 logFormatter.infoLog("verifying requests that match:{}", verification);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/verifySequence")) {                  VerificationSequence verificationSequence = verificationSequenceSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verificationSequence);                 logFormatter.infoLog("verifying sequence that match:{}", verificationSequence);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/stop")) {                  ctx.writeAndFlush(response().withStatusCode(ACCEPTED.code()));                 new Thread(new Runnable() {                     @Override                     public void run() {                         server.stop();                     }                 }).start();              } else {                  Action handle = mockServerMatcher.retrieveAction(request);                 if (handle instanceof HttpError) {                     HttpError httpError = ((HttpError) handle).applyDelay();                     if (httpError.getResponseBytes() != null) {                         // write byte directly by skipping over HTTP codec                         ChannelHandlerContext httpCodecContext = ctx.pipeline().context(HttpServerCodec.class);                         if (httpCodecContext != null) {                             httpCodecContext.writeAndFlush(Unpooled.wrappedBuffer(httpError.getResponseBytes())).awaitUninterruptibly();                         }                     }                     if (httpError.getDropConnection()) {                         ctx.close();                     }                 } else if (handle instanceof HttpObjectCallback) {                     String clientId = ((HttpObjectCallback) handle).getClientId();                     webSocketClientRegistry.registerCallbackResponseHandler(clientId, new ExpectationCallbackResponse() {                         @Override                         public void handle(HttpResponse response) {                             logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                             writeResponse(ctx, request, response.withConnectionOptions(connectionOptions().withCloseSocket(true)));                         }                     });                     webSocketClientRegistry.sendClientMessage(clientId, request);                 } else {                     HttpResponse response = actionHandler.processAction(handle, request);                     logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                     writeResponse(ctx, request, response);                 }              }         } catch (Exception e) {             logger.error("Exception processing " + request, e);             writeResponse(ctx, request, response().withStatusCode(BAD_REQUEST.code()).withBody(e.getMessage()));         }      }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus) {         writeResponse(ctx, request, responseStatus, "", "application/json");     }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus, String body, String contentType) {         HttpResponse response = response()                 .withStatusCode(responseStatus.code())                 .withBody(body);         if (body != null && !body.isEmpty()) {             response.updateHeader(header(CONTENT_TYPE.toString(), contentType + "; charset=utf-8"));         }         if (enableCORSForAPI()) {             addCORSHeaders(response);         }         writeResponse(ctx, request, response);     }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         if (response == null) {             response = notFoundResponse();         }         if (enableCORSForAllResponses()) {             addCORSHeaders(response);         }          addConnectionHeader(request, response);          writeAndCloseSocket(ctx, request, response);     }      private void addCORSHeaders(HttpResponse response) {         String methods = "CONNECT, DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE";         String headers = "Allow, Content-Encoding, Content-Length, Content-Type, ETag, Expires, Last-Modified, Location, Server, Vary";         if (response.getFirstHeader("Access-Control-Allow-Origin").isEmpty()) {             response.withHeader("Access-Control-Allow-Origin", "*");         }         if (response.getFirstHeader("Access-Control-Allow-Methods").isEmpty()) {             response.withHeader("Access-Control-Allow-Methods", methods);         }         if (response.getFirstHeader("Access-Control-Allow-Headers").isEmpty()) {             response.withHeader("Access-Control-Allow-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Expose-Headers").isEmpty()) {             response.withHeader("Access-Control-Expose-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Max-Age").isEmpty()) {             response.withHeader("Access-Control-Max-Age", "1");         }         if (response.getFirstHeader("X-CORS").isEmpty()) {             response.withHeader("X-CORS", "MockServer CORS support enabled by default, to disable ConfigurationProperties.enableCORSForAPI(false) or -Dmockserver.disableCORS=false");         }     }      private void addConnectionHeader(HttpRequest request, HttpResponse response) {         ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getKeepAliveOverride() != null) {             if (connectionOptions.getKeepAliveOverride()) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         } else if (connectionOptions == null || isFalseOrNull(connectionOptions.getSuppressConnectionHeader())) {             if (request.isKeepAlive() != null && request.isKeepAlive()                     && (connectionOptions == null || isFalseOrNull(connectionOptions.getCloseSocket()))) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         }     }      private void writeAndCloseSocket(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         boolean closeChannel;          ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getCloseSocket() != null) {             closeChannel = connectionOptions.getCloseSocket();         } else {             closeChannel = !(request.isKeepAlive() != null && request.isKeepAlive());         }          if (closeChannel) {             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             ctx.write(response);         }     }      @Override     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     }      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         if (!cause.getMessage().contains("Connection reset by peer")) {             logger.warn("Exception caught by MockServer handler -> closing pipeline", cause);         }         ctx.close();     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> mockserver-netty : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> org : Folder]
						[NT -> mockserver : Folder]
							[NT -> mockserver : Folder]
								[NT -> MockServerHandler.java.merge : .java.merge-File]
									[T -> MockServerHandler.java : .java-Content "package org.mockserver.mockserver;  import com.google.common.base.Joiner; import com.google.common.net.MediaType; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.HttpResponseStatus; import io.netty.handler.codec.http.HttpServerCodec; import org.mockserver.client.serialization.*; import org.mockserver.filters.RequestLogFilter; import org.mockserver.logging.LogFormatter; import org.mockserver.mock.Expectation; import org.mockserver.mock.MockServerMatcher; import org.mockserver.mock.action.ActionHandler; import org.mockserver.mockserver.callback.ExpectationCallbackResponse; import org.mockserver.mockserver.callback.WebSocketClientRegistry; import org.mockserver.model.*; import org.mockserver.socket.KeyStoreFactory; import org.mockserver.socket.SSLFactory; import org.mockserver.validator.ExpectationValidator; import org.mockserver.verify.Verification; import org.mockserver.verify.VerificationSequence; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import java.net.BindException; import java.util.List;  import static io.netty.handler.codec.http.HttpHeaderNames.*; import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE; import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE; import static io.netty.handler.codec.http.HttpResponseStatus.*; import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAPI; import static org.mockserver.configuration.ConfigurationProperties.enableCORSForAllResponses; import static org.mockserver.model.ConnectionOptions.connectionOptions; import static org.mockserver.model.ConnectionOptions.isFalseOrNull; import static org.mockserver.model.Header.header; import static org.mockserver.model.HttpResponse.notFoundResponse; import static org.mockserver.model.HttpResponse.response; import static org.mockserver.model.PortBinding.portBinding;  @ChannelHandler.Sharable public class MockServerHandler extends SimpleChannelInboundHandler<HttpRequest> {      private final Logger logger = LoggerFactory.getLogger(this.getClass());     private LogFormatter logFormatter = new LogFormatter(logger);     // mockserver     private MockServer server;     private RequestLogFilter requestLogFilter;     private MockServerMatcher mockServerMatcher;     private WebSocketClientRegistry webSocketClientRegistry;     private ActionHandler actionHandler;     // serializers     private ExpectationSerializer expectationSerializer = new ExpectationSerializer();     private HttpRequestSerializer httpRequestSerializer = new HttpRequestSerializer();     private PortBindingSerializer portBindingSerializer = new PortBindingSerializer();     private VerificationSerializer verificationSerializer = new VerificationSerializer();     private VerificationSequenceSerializer verificationSequenceSerializer = new VerificationSequenceSerializer();     // validators     private ExpectationValidator expectationValidator = new ExpectationValidator();      public MockServerHandler(MockServer server, MockServerMatcher mockServerMatcher, WebSocketClientRegistry webSocketClientRegistry, RequestLogFilter requestLogFilter) {         this.server = server;         this.requestLogFilter = requestLogFilter;         this.mockServerMatcher = mockServerMatcher;         this.webSocketClientRegistry = webSocketClientRegistry;         actionHandler = new ActionHandler(requestLogFilter);     }      @Override     protected void channelRead0(final ChannelHandlerContext ctx, final HttpRequest request) {          try {              if ((enableCORSForAPI() || enableCORSForAllResponses()) && request.getMethod().getValue().equals("OPTIONS") && !request.getFirstHeader("Origin").isEmpty()) {                  writeResponse(ctx, request, OK);              } else if (request.matches("PUT", "/status")) {                  List<Integer> actualPortBindings = server.getPorts();                 writeResponse(ctx, request, OK, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");              } else if (request.matches("PUT", "/bind")) {                  PortBinding requestedPortBindings = portBindingSerializer.deserialize(request.getBodyAsString());                 try {                     List<Integer> actualPortBindings = server.bindToPorts(requestedPortBindings.getPorts());                     writeResponse(ctx, request, ACCEPTED, portBindingSerializer.serialize(portBinding(actualPortBindings)), "application/json");                 } catch (RuntimeException e) {                     if (e.getCause() instanceof BindException) {                         writeResponse(ctx, request, NOT_ACCEPTABLE, e.getMessage() + " port already in use", MediaType.create("text", "plain").toString());                     } else {                         throw e;                     }                 }              } else if (request.matches("PUT", "/expectation")) {                  for (Expectation expectation : expectationSerializer.deserializeArray(request.getBodyAsString())) {                     List<String> validationErrors = expectationValidator.isValid(expectation);                     if (validationErrors.isEmpty()) {                         SSLFactory.addSubjectAlternativeName(expectation.getHttpRequest().getFirstHeader(HOST.toString()));                         mockServerMatcher                                 .when(expectation.getHttpRequest(), expectation.getTimes(), expectation.getTimeToLive())                                 .thenRespond(expectation.getHttpResponse())                                 .thenForward(expectation.getHttpForward())                                 .thenError(expectation.getHttpError())                                 .thenCallback(expectation.getHttpClassCallback())                                 .thenCallback(expectation.getHttpObjectCallback());                         logFormatter.infoLog("creating expectation:{}", expectation);                         writeResponse(ctx, request, HttpResponseStatus.CREATED);                     } else {                         String errorMessage = validationErrors.size() + " errors:\n - " + Joiner.on("\n - ").join(validationErrors) + "\n";                         writeResponse(ctx, request, NOT_ACCEPTABLE, errorMessage, MediaType.create("text", "plain").toString());                     }                 }              } else if (request.matches("PUT", "/clear")) {                  org.mockserver.model.HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     logFormatter.infoLog("clearing expectations that match:{}", httpRequest);                     mockServerMatcher.clear(httpRequest);                 } else if (request.hasQueryStringParameter("type", "log")) {                     logFormatter.infoLog("clearing request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                 } else {                     logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                     requestLogFilter.clear(httpRequest);                     mockServerMatcher.clear(httpRequest);                 }                 logFormatter.infoLog("clearing expectations and request logs that match:{}", httpRequest);                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/reset")) {                  requestLogFilter.reset();                 mockServerMatcher.reset();                 logFormatter.infoLog("resetting all expectations and request logs");                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/dumpToLog")) {                  mockServerMatcher.dumpToLog(httpRequestSerializer.deserialize(request.getBodyAsString()));                 writeResponse(ctx, request, ACCEPTED);              } else if (request.matches("PUT", "/retrieve")) {                  HttpRequest httpRequest = httpRequestSerializer.deserialize(request.getBodyAsString());                 if (request.hasQueryStringParameter("type", "expectation")) {                     Expectation[] expectations = mockServerMatcher.retrieveExpectations(httpRequest);                     logFormatter.infoLog("retrieving expectations that match:{}", httpRequest);                     writeResponse(ctx, request, OK, expectationSerializer.serialize(expectations), "application/json");                 } else {                     HttpRequest[] requests = requestLogFilter.retrieve(httpRequest);                     logFormatter.infoLog("retrieving requests that match:{}", httpRequest);                     writeResponse(ctx, request, OK, httpRequestSerializer.serialize(requests), "application/json");                 }              } else if (request.matches("PUT", "/verify")) {                  Verification verification = verificationSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verification);                 logFormatter.infoLog("verifying requests that match:{}", verification);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/verifySequence")) {                  VerificationSequence verificationSequence = verificationSequenceSerializer.deserialize(request.getBodyAsString());                 String result = requestLogFilter.verify(verificationSequence);                 logFormatter.infoLog("verifying sequence that match:{}", verificationSequence);                 if (result.isEmpty()) {                     writeResponse(ctx, request, ACCEPTED);                 } else {                     writeResponse(ctx, request, NOT_ACCEPTABLE, result, MediaType.create("text", "plain").toString());                 }              } else if (request.matches("PUT", "/stop")) {                  ctx.writeAndFlush(response().withStatusCode(ACCEPTED.code()));                 new Thread(new Runnable() {                     @Override                     public void run() {                         server.stop();                     }                 }).start();              } else {                  Action handle = mockServerMatcher.retrieveAction(request);                 if (handle instanceof HttpError) {                     HttpError httpError = ((HttpError) handle).applyDelay();                     if (httpError.getResponseBytes() != null) {                         // write byte directly by skipping over HTTP codec                         ChannelHandlerContext httpCodecContext = ctx.pipeline().context(HttpServerCodec.class);                         if (httpCodecContext != null) {                             httpCodecContext.writeAndFlush(Unpooled.wrappedBuffer(httpError.getResponseBytes())).awaitUninterruptibly();                         }                     }                     if (httpError.getDropConnection()) {                         ctx.close();                     }                 } else if (handle instanceof HttpObjectCallback) {                     String clientId = ((HttpObjectCallback) handle).getClientId();                     webSocketClientRegistry.registerCallbackResponseHandler(clientId, new ExpectationCallbackResponse() {                         @Override                         public void handle(HttpResponse response) {                             logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                             writeResponse(ctx, request, response.withConnectionOptions(connectionOptions().withCloseSocket(true)));                         }                     });                     webSocketClientRegistry.sendClientMessage(clientId, request);                 } else {                     HttpResponse response = actionHandler.processAction(handle, request);                     logFormatter.infoLog("returning response:{}" + System.getProperty("line.separator") + " for request:{}", response, request);                     writeResponse(ctx, request, response);                 }              }         } catch (Exception e) {             logger.error("Exception processing " + request, e);             writeResponse(ctx, request, response().withStatusCode(BAD_REQUEST.code()).withBody(e.getMessage()));         }      }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus) {         writeResponse(ctx, request, responseStatus, "", "application/json");     }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponseStatus responseStatus, String body, String contentType) {         HttpResponse response = response()                 .withStatusCode(responseStatus.code())                 .withBody(body);         if (body != null && !body.isEmpty()) {             response.updateHeader(header(CONTENT_TYPE.toString(), contentType + "; charset=utf-8"));         }         if (enableCORSForAPI()) {             addCORSHeaders(response);         }         writeResponse(ctx, request, response);     }      private void writeResponse(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         if (response == null) {             response = notFoundResponse();         }         if (enableCORSForAllResponses()) {             addCORSHeaders(response);         }          addConnectionHeader(request, response);          writeAndCloseSocket(ctx, request, response);     }      private void addCORSHeaders(HttpResponse response) {         String methods = "CONNECT, DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE";         String headers = "Allow, Content-Encoding, Content-Length, Content-Type, ETag, Expires, Last-Modified, Location, Server, Vary";         if (response.getFirstHeader("Access-Control-Allow-Origin").isEmpty()) {             response.withHeader("Access-Control-Allow-Origin", "*");         }         if (response.getFirstHeader("Access-Control-Allow-Methods").isEmpty()) {             response.withHeader("Access-Control-Allow-Methods", methods);         }         if (response.getFirstHeader("Access-Control-Allow-Headers").isEmpty()) {             response.withHeader("Access-Control-Allow-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Expose-Headers").isEmpty()) {             response.withHeader("Access-Control-Expose-Headers", headers);         }         if (response.getFirstHeader("Access-Control-Max-Age").isEmpty()) {             response.withHeader("Access-Control-Max-Age", "1");         }         if (response.getFirstHeader("X-CORS").isEmpty()) {             response.withHeader("X-CORS", "MockServer CORS support enabled by default, to disable ConfigurationProperties.enableCORSForAPI(false) or -Dmockserver.disableCORS=false");         }     }      private void addConnectionHeader(HttpRequest request, HttpResponse response) {         ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getKeepAliveOverride() != null) {             if (connectionOptions.getKeepAliveOverride()) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         } else if (connectionOptions == null || isFalseOrNull(connectionOptions.getSuppressConnectionHeader())) {             if (request.isKeepAlive() != null && request.isKeepAlive()                     && (connectionOptions == null || isFalseOrNull(connectionOptions.getCloseSocket()))) {                 response.updateHeader(header(CONNECTION.toString(), KEEP_ALIVE.toString()));             } else {                 response.updateHeader(header(CONNECTION.toString(), CLOSE.toString()));             }         }     }      private void writeAndCloseSocket(ChannelHandlerContext ctx, HttpRequest request, HttpResponse response) {         boolean closeChannel;          ConnectionOptions connectionOptions = response.getConnectionOptions();         if (connectionOptions != null && connectionOptions.getCloseSocket() != null) {             closeChannel = connectionOptions.getCloseSocket();         } else {             closeChannel = !(request.isKeepAlive() != null && request.isKeepAlive());         }          if (closeChannel) {             ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);         } else {             ctx.write(response);         }     }      @Override     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {         ctx.flush();     }      @Override     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {         if (!cause.getMessage().contains("Connection reset by peer")) {             logger.warn("Exception caught by MockServer handler -> closing pipeline", cause);         }         ctx.close();     } } " compose:StringConcatenation merge: LineBased]
