Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/com/netflix/simianarmy/basic/chaos/BasicChaosMonkey.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/src/main/java/com/netflix/simianarmy/basic/chaos/BasicChaosMonkey.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/com/netflix/simianarmy/basic/chaos/BasicChaosMonkey.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/src/main/java/com/netflix/simianarmy/basic/chaos/BasicChaosMonkey.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/com/netflix/simianarmy/basic/chaos/BasicChaosMonkey.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/src/main/java/com/netflix/simianarmy/basic/chaos/BasicChaosMonkey.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> netflix : Folder]
						[NT -> simianarmy : Folder]
							[NT -> basic : Folder]
								[NT -> chaos : Folder]
									[NT -> BasicChaosMonkey.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.netflix.simianarmy.basic.chaos;" compose:Replacement merge: Default]
											[T -> java.util.Calendar{ImportPackage} : ImportDeclaration "import java.util.Calendar;" compose:Replacement merge: Default]
											[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: Default]
											[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.Random{ImportPackage} : ImportDeclaration "import java.util.Random;" compose:Replacement merge: Default]
											[T -> java.util.concurrent.TimeUnit{ImportPackage} : ImportDeclaration "import java.util.concurrent.TimeUnit;" compose:Replacement merge: Default]
											[T -> org.apache.commons.lang.Validate{ImportPackage} : ImportDeclaration "import org.apache.commons.lang.Validate;" compose:Replacement merge: Default]
											[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
											[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Lists{ImportPackage} : ImportDeclaration "import com.google.common.collect.Lists;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.CloudClient{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.CloudClient;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.FeatureNotEnabledException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.FeatureNotEnabledException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.InstanceGroupNotFoundException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.InstanceGroupNotFoundException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyCalendar{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyCalendar;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyConfiguration{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyConfiguration;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyRecorder.Event{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyRecorder.Event;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.NotFoundException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.NotFoundException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosEmailNotifier{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosEmailNotifier;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosMonkey{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosMonkey;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosType;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.DetachVolumesChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.DetachVolumesChaosType;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ShutdownInstanceChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ShutdownInstanceChaosType;" compose:Replacement merge: Default]
											[NT -> BasicChaosMonkey : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> BasicChaosMonkey : Id "BasicChaosMonkey" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends ChaosMonkey" compose:Replacement merge: Default]
												[T -> LOGGER : FieldDecl "private static final Logger LOGGER = LoggerFactory.getLogger(BasicChaosMonkey.class);" compose:Replacement merge: SemanticConflict]
												[T -> NS : FieldDecl "private static final String NS = "simianarmy.chaos.";" compose:Replacement merge: SemanticConflict]
												[T -> cfg : FieldDecl "private final MonkeyConfiguration cfg;" compose:Replacement merge: SemanticConflict]
												[T -> runsPerDay : FieldDecl "private final long runsPerDay;" compose:Replacement merge: SemanticConflict]
												[T -> MIN_MAX_TERMINATION_COUNT_PER_DAY : FieldDecl "private static final double MIN_MAX_TERMINATION_COUNT_PER_DAY = 0.001;" compose:Replacement merge: SemanticConflict]
												[T -> monkeyCalendar : FieldDecl "private final MonkeyCalendar monkeyCalendar;" compose:Replacement merge: SemanticConflict]
												[T -> DEFAULT_MANDATORY_TERMINATION_PROBABILITY : FieldDecl "private static final double DEFAULT_MANDATORY_TERMINATION_PROBABILITY = 0.5;" compose:Replacement merge: SemanticConflict]
												[T -> enabledChaosTypes : FieldDecl "private final List<ChaosType> enabledChaosTypes;" compose:Replacement merge: SemanticConflict]
												[T -> BasicChaosMonkey(ChaosMonkey.Context-ChaosMonkey.Context) : ConstructorDecl "public BasicChaosMonkey(ChaosMonkey.Context ctx) {         super(ctx);          this.cfg = ctx.configuration();         this.monkeyCalendar = ctx.calendar();          Calendar open = monkeyCalendar.now();         Calendar close = monkeyCalendar.now();         open.set(Calendar.HOUR, monkeyCalendar.openHour());         close.set(Calendar.HOUR, monkeyCalendar.closeHour());          enabledChaosTypes = Lists.newArrayList();         enabledChaosTypes.add(new ShutdownInstanceChaosType(cfg));         enabledChaosTypes.add(new DetachVolumesChaosType(cfg));          TimeUnit freqUnit = ctx.scheduler().frequencyUnit();         long units = freqUnit.convert(close.getTimeInMillis() - open.getTimeInMillis(), TimeUnit.MILLISECONDS);         runsPerDay = units / ctx.scheduler().frequency();     }" compose:Replacement merge: LineBased]
												[T -> doMonkeyBusiness({FormalParametersInternal}) : MethodDecl "@Override     public void doMonkeyBusiness() {         context().resetEventReport();         cfg.reload();         if (!isChaosMonkeyEnabled()) {             return;         }         for (InstanceGroup group : context().chaosCrawler().groups()) {             if (isGroupEnabled(group)) {                 if (isMaxTerminationCountExceeded(group)) {                     continue;                 }                 double prob = getEffectiveProbability(group);                 Collection<String> instances = context().chaosInstanceSelector().select(group, prob / runsPerDay);                 for (String inst : instances) {                     ChaosType chaosType = pickChaosType(context().cloudClient(), inst);                     if (chaosType == null) {                         // This is surprising ... normally we can always just terminate it                         LOGGER.warn("No chaos type was applicable to the instance: {}", inst);                         continue;                     }                     terminateInstance(group, inst, chaosType);                 }             }         }     }" compose:Replacement merge: LineBased]
												[T -> pickChaosType(CloudClient-CloudClient-String-String) : MethodDecl "private ChaosType pickChaosType(CloudClient cloudClient, String instanceId) {         Random random = new Random();          List<ChaosType> applicable = Lists.newArrayList();         for (ChaosType chaosType : enabledChaosTypes) {             if (chaosType.canApply(cloudClient, instanceId)) {                 applicable.add(chaosType);             }         }          if (applicable.isEmpty()) {             return null;         }          int index = random.nextInt(applicable.size());         return applicable.get(index);     }" compose:Replacement merge: LineBased]
												[T -> terminateNow(String-String-String-String-ChaosType-ChaosType) : MethodDecl "@Override     public Event terminateNow(String type, String name, ChaosType chaosType)             throws FeatureNotEnabledException, InstanceGroupNotFoundException {         Validate.notNull(type);         Validate.notNull(name);         cfg.reload(name);         if (!isChaosMonkeyEnabled()) {             String msg = String.format("Chaos monkey is not enabled for group %s [type %s]",                     name, type);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }         String prop = NS + "terminateOndemand.enabled";         if (cfg.getBool(prop)) {             InstanceGroup group = findInstanceGroup(type, name);             if (group == null) {                 throw new InstanceGroupNotFoundException(type, name);             }             Collection<String> instances = context().chaosInstanceSelector().select(group, 1.0);             Validate.isTrue(instances.size() <= 1);             if (instances.size() == 1) {                 return terminateInstance(group, instances.iterator().next(), chaosType);             } else {                 throw new NotFoundException(String.format("No instance is found in group %s [type %s]",                         name, type));             }         } else {             String msg = String.format("Group %s [type %s] does not allow on-demand termination, set %s=true",                     name, type, prop);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }     }" compose:Replacement merge: LineBased]
												[T -> reportEventForSummary(EventTypes-EventTypes-InstanceGroup-InstanceGroup-String-String) : MethodDecl "private void reportEventForSummary(EventTypes eventType, InstanceGroup group, String instanceId) {         context().reportEvent(createEvent(eventType, group, instanceId));     }" compose:Replacement merge: LineBased]
												[T -> handleTerminationError(String-String-Throwable-Throwable) : MethodDecl "protected void handleTerminationError(String instance, Throwable e) {         LOGGER.error("failed to terminate instance " + instance, e.getMessage());         throw new RuntimeException("failed to terminate instance " + instance, e);     }" compose:Replacement merge: LineBased]
												[T -> recordTermination(InstanceGroup-InstanceGroup-String-String-ChaosType-ChaosType) : MethodDecl "@Override     public Event recordTermination(InstanceGroup group, String instance, ChaosType chaosType) {         Event evt = context().recorder().newEvent(Type.CHAOS, EventTypes.CHAOS_TERMINATION, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         evt.addField("chaosType", chaosType.getKey());         context().recorder().recordEvent(evt);         return evt;     }" compose:Replacement merge: LineBased]
												[T -> getPreviousTerminationCount(InstanceGroup-InstanceGroup-Date-Date) : MethodDecl "@Override     public int getPreviousTerminationCount(InstanceGroup group, Date after) {         Map<String, String> query = new HashMap<String, String>();         query.put("groupType", group.type().name());         query.put("groupName", group.name());         List<Event> evts = context().recorder().findEvents(Type.CHAOS, EventTypes.CHAOS_TERMINATION, query, after);         return evts.size();     }" compose:Replacement merge: LineBased]
												[T -> createEvent(EventTypes-EventTypes-InstanceGroup-InstanceGroup-String-String) : MethodDecl "private Event createEvent(EventTypes chaosTermination, InstanceGroup group, String instance) {         Event evt = context().recorder().newEvent(Type.CHAOS, chaosTermination, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         return evt;     }" compose:Replacement merge: LineBased]
												[T -> getEffectiveProbability(InstanceGroup-InstanceGroup) : MethodDecl "protected double getEffectiveProbability(InstanceGroup group) {         if (!isGroupEnabled(group)) {             return 0;         }         return getEffectiveProbabilityFromCfg(group);     }" compose:Replacement merge: LineBased]
												[T -> getEffectiveProbabilityFromCfg(InstanceGroup-InstanceGroup) : MethodDecl "protected double getEffectiveProbabilityFromCfg(InstanceGroup group) {         String propName;         if (cfg.getBool(NS + "mandatoryTermination.enabled")) {             String mtwProp = NS + "mandatoryTermination.windowInDays";             int mandatoryTerminationWindowInDays = (int) cfg.getNumOrElse(mtwProp, 0);             if (mandatoryTerminationWindowInDays > 0                     && noTerminationInLastWindow(group, mandatoryTerminationWindowInDays)) {                 double mandatoryProb = cfg.getNumOrElse(NS + "mandatoryTermination.defaultProbability",                         DEFAULT_MANDATORY_TERMINATION_PROBABILITY);                 LOGGER.info("There has been no terminations for group {} [type {}] in the last {} days,"                         + "setting the probability to {} for mandatory termination.",                         new Object[]{group.name(), group.type(), mandatoryTerminationWindowInDays, mandatoryProb});                 return mandatoryProb;             }         }         propName = "probability";         String defaultProp = NS + group.type();         String probProp = NS + group.type() + "." + group.name() + "." + propName;         double prob = cfg.getNumOrElse(probProp, cfg.getNumOrElse(defaultProp + "." + propName, 1.0));         LOGGER.info("Group {} [type {}] enabled [prob {}]", new Object[]{group.name(), group.type(), prob});         return prob;     }" compose:Replacement merge: LineBased]
												[T -> getLastOptInMilliseconds(InstanceGroup-InstanceGroup) : MethodDecl "protected long getLastOptInMilliseconds(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".lastOptInTimeInMilliseconds";         long lastOptInTimeInMilliseconds = (long) cfg.getNumOrElse(prop, -1);         return lastOptInTimeInMilliseconds;     }" compose:Replacement merge: LineBased]
												[T -> noTerminationInLastWindow(InstanceGroup-InstanceGroup-int-int) : MethodDecl "private boolean noTerminationInLastWindow(InstanceGroup group, int mandatoryTerminationWindowInDays) {     long lastOptInTimeInMilliseconds = getLastOptInMilliseconds(group);         if (lastOptInTimeInMilliseconds < 0) {             return false;         }          Calendar windowStart = monkeyCalendar.now();         windowStart.add(Calendar.DATE, -1 * mandatoryTerminationWindowInDays);          // return true if the window start is after the last opt-in time and         // there has been no termination since the window start         if (windowStart.getTimeInMillis() > lastOptInTimeInMilliseconds                 && getPreviousTerminationCount(group, windowStart.getTime()) <= 0) {             return true;         }          return false;     }" compose:Replacement merge: LineBased]
												[T -> isGroupEnabled(InstanceGroup-InstanceGroup) : MethodDecl "protected boolean isGroupEnabled(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".enabled";         String defaultProp = NS + group.type() + ".enabled";         if (cfg.getBoolOrElse(prop, cfg.getBool(defaultProp))) {             return true;         } else {             LOGGER.info("Group {} [type {}] disabled, set {}=true or {}=true",                     new Object[]{group.name(), group.type(), prop, defaultProp});             return false;         }     }" compose:Replacement merge: LineBased]
												[T -> isChaosMonkeyEnabled({FormalParametersInternal}) : MethodDecl "private boolean isChaosMonkeyEnabled() {         String prop = NS + "enabled";         if (cfg.getBoolOrElse(prop, true)) {             return true;         }         LOGGER.info("ChaosMonkey disabled, set {}=true", prop);         return false;     }" compose:Replacement merge: LineBased]
												[T -> findInstanceGroup(String-String-String-String) : MethodDecl "private InstanceGroup findInstanceGroup(String type, String name) {         // Calling context().chaosCrawler().groups(name) causes a new crawl to get         // the up to date information for the group name.         for (InstanceGroup group : context().chaosCrawler().groups(name)) {             if (group.type().toString().equals(type) && group.name().equals(name)) {                 return group;             }         }         LOGGER.warn("Failed to find instance group for type {} and name {}", type, name);         return null;     }" compose:Replacement merge: LineBased]
												[T -> terminateInstance(InstanceGroup-InstanceGroup-String-String-ChaosType-ChaosType) : MethodDecl "private Event terminateInstance(InstanceGroup group, String inst, ChaosType chaosType) {         Validate.notNull(group);         Validate.notEmpty(inst);         String prop = NS + "leashed";         if (cfg.getBoolOrElse(prop, true)) {             LOGGER.info("leashed ChaosMonkey prevented from killing {} from group {} [{}], set {}=false",                     new Object[]{inst, group.name(), group.type(), prop});             reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);             return null;         } else {             try {                 Event evt = recordTermination(group, inst, chaosType);                 sendTerminationNotification(group, inst);                 chaosType.apply(context().cloudClient(), inst);                 LOGGER.info("Terminated {} from group {} [{}] with {}",                         new Object[]{inst, group.name(), group.type(), chaosType.getKey() });                 reportEventForSummary(EventTypes.CHAOS_TERMINATION, group, inst);                 return evt;             } catch (NotFoundException e) {                 LOGGER.warn("Failed to terminate " + inst + ", it does not exist. Perhaps it was already terminated");                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             } catch (Exception e) {                 handleTerminationError(inst, e);                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             }         }     }" compose:Replacement merge: LineBased]
												[T -> isMaxTerminationCountExceeded(InstanceGroup-InstanceGroup) : MethodDecl "protected boolean isMaxTerminationCountExceeded(InstanceGroup group) {         Validate.notNull(group);         String propName = "maxTerminationsPerDay";         String defaultProp = String.format("%s%s.%s", NS, group.type(), propName);         String prop = String.format("%s%s.%s.%s", NS, group.type(), group.name(), propName);         double maxTerminationsPerDay = cfg.getNumOrElse(prop, cfg.getNumOrElse(defaultProp, 1.0));         if (maxTerminationsPerDay <= MIN_MAX_TERMINATION_COUNT_PER_DAY) {             LOGGER.info("ChaosMonkey is configured to not allow any killing from group {} [{}] "                     + "with max daily count set as {}", new Object[]{group.name(), group.type(), prop});             return true;         } else {             int daysBack = 1;             int maxCount = (int) maxTerminationsPerDay;             if (maxTerminationsPerDay < 1.0) {                 daysBack = (int) Math.ceil(1 / maxTerminationsPerDay);                 maxCount = 1;             }             Calendar after = monkeyCalendar.now();             after.add(Calendar.DATE, -1 * daysBack);             // Check if the group has exceeded the maximum terminations for the last period             int terminationCount = getPreviousTerminationCount(group, after.getTime());             if (terminationCount >= maxCount) {                 LOGGER.info("The count of terminations for group {} [{}] in the last {} days is {},"                         + " equal or greater than the max count threshold {}",                         new Object[]{group.name(), group.type(), daysBack, terminationCount, maxCount});                 return true;             }         }         return false;     }" compose:Replacement merge: LineBased]
												[T -> sendTerminationNotification(InstanceGroup-InstanceGroup-String-String) : MethodDecl "@Override     public void sendTerminationNotification(InstanceGroup group, String instance) {         String propEmailGlobalEnabled = "simianarmy.chaos.notification.global.enabled";         String propEmailGroupEnabled = String.format("%s%s.%s.notification.enabled", NS, group.type(), group.name());          ChaosEmailNotifier notifier = context().chaosEmailNotifier();         if (notifier == null) {             String msg = "Chaos email notifier is not set.";             LOGGER.error(msg);             throw new RuntimeException(msg);         }         if (cfg.getBoolOrElse(propEmailGroupEnabled, false)) {             notifier.sendTerminationNotification(group, instance);         }         if (cfg.getBoolOrElse(propEmailGlobalEnabled, false)) {             notifier.sendTerminationGlobalNotification(group, instance);         }     }" compose:Replacement merge: LineBased]
												[T -> getChaosTypes({FormalParametersInternal}) : MethodDecl "@Override     public List<ChaosType> getChaosTypes() {         return Lists.newArrayList(enabledChaosTypes);     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> netflix : Folder]
						[NT -> simianarmy : Folder]
							[NT -> basic : Folder]
								[NT -> chaos : Folder]
									[NT -> BasicChaosMonkey.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.netflix.simianarmy.basic.chaos;" compose:Replacement merge: Default]
											[T -> java.util.Calendar{ImportPackage} : ImportDeclaration "import java.util.Calendar;" compose:Replacement merge: Default]
											[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: Default]
											[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.Random{ImportPackage} : ImportDeclaration "import java.util.Random;" compose:Replacement merge: Default]
											[T -> java.util.concurrent.TimeUnit{ImportPackage} : ImportDeclaration "import java.util.concurrent.TimeUnit;" compose:Replacement merge: Default]
											[T -> org.apache.commons.lang.Validate{ImportPackage} : ImportDeclaration "import org.apache.commons.lang.Validate;" compose:Replacement merge: Default]
											[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
											[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Lists{ImportPackage} : ImportDeclaration "import com.google.common.collect.Lists;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.CloudClient{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.CloudClient;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.FeatureNotEnabledException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.FeatureNotEnabledException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.InstanceGroupNotFoundException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.InstanceGroupNotFoundException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyCalendar{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyCalendar;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyConfiguration{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyConfiguration;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyRecorder.Event{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyRecorder.Event;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.NotFoundException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.NotFoundException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosEmailNotifier{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosEmailNotifier;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosMonkey{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosMonkey;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosType;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ShutdownInstanceChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ShutdownInstanceChaosType;" compose:Replacement merge: Default]
											[NT -> BasicChaosMonkey : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> BasicChaosMonkey : Id "BasicChaosMonkey" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends ChaosMonkey" compose:Replacement merge: Default]
												[T -> LOGGER : FieldDecl "private static final Logger LOGGER = LoggerFactory.getLogger(BasicChaosMonkey.class);" compose:Replacement merge: SemanticConflict]
												[T -> NS : FieldDecl "private static final String NS = "simianarmy.chaos.";" compose:Replacement merge: SemanticConflict]
												[T -> cfg : FieldDecl "private final MonkeyConfiguration cfg;" compose:Replacement merge: SemanticConflict]
												[T -> runsPerDay : FieldDecl "private final long runsPerDay;" compose:Replacement merge: SemanticConflict]
												[T -> MIN_MAX_TERMINATION_COUNT_PER_DAY : FieldDecl "private static final double MIN_MAX_TERMINATION_COUNT_PER_DAY = 0.001;" compose:Replacement merge: SemanticConflict]
												[T -> monkeyCalendar : FieldDecl "private final MonkeyCalendar monkeyCalendar;" compose:Replacement merge: SemanticConflict]
												[T -> DEFAULT_MANDATORY_TERMINATION_PROBABILITY : FieldDecl "private static final double DEFAULT_MANDATORY_TERMINATION_PROBABILITY = 0.5;" compose:Replacement merge: SemanticConflict]
												[T -> enabledChaosTypes : FieldDecl "private final List<ChaosType> enabledChaosTypes;" compose:Replacement merge: SemanticConflict]
												[T -> BasicChaosMonkey(ChaosMonkey.Context-ChaosMonkey.Context) : ConstructorDecl "public BasicChaosMonkey(ChaosMonkey.Context ctx) {         super(ctx);          this.cfg = ctx.configuration();         this.monkeyCalendar = ctx.calendar();          Calendar open = monkeyCalendar.now();         Calendar close = monkeyCalendar.now();         open.set(Calendar.HOUR, monkeyCalendar.openHour());         close.set(Calendar.HOUR, monkeyCalendar.closeHour());          enabledChaosTypes = Lists.newArrayList();         enabledChaosTypes.add(new ShutdownInstanceChaosType(cfg));          TimeUnit freqUnit = ctx.scheduler().frequencyUnit();         long units = freqUnit.convert(close.getTimeInMillis() - open.getTimeInMillis(), TimeUnit.MILLISECONDS);         runsPerDay = units / ctx.scheduler().frequency();     }" compose:Replacement merge: LineBased]
												[T -> doMonkeyBusiness({FormalParametersInternal}) : MethodDecl "@Override     public void doMonkeyBusiness() {         context().resetEventReport();         cfg.reload();         if (!isChaosMonkeyEnabled()) {             return;         }         for (InstanceGroup group : context().chaosCrawler().groups()) {             if (isGroupEnabled(group)) {                 if (isMaxTerminationCountExceeded(group)) {                     continue;                 }                 double prob = getEffectiveProbability(group);                 Collection<String> instances = context().chaosInstanceSelector().select(group, prob / runsPerDay);                 for (String inst : instances) {                     ChaosType chaosType = pickChaosType(context().cloudClient(), inst);                     if (chaosType == null) {                         // This is surprising ... normally we can always just terminate it                         LOGGER.warn("No chaos type was applicable to the instance: {}", inst);                         continue;                     }                     terminateInstance(group, inst, chaosType);                 }             }         }     }" compose:Replacement merge: LineBased]
												[T -> pickChaosType(CloudClient-CloudClient-String-String) : MethodDecl "private ChaosType pickChaosType(CloudClient cloudClient, String instanceId) {         Random random = new Random();          List<ChaosType> applicable = Lists.newArrayList();         for (ChaosType chaosType : enabledChaosTypes) {             if (chaosType.canApply(cloudClient, instanceId)) {                 applicable.add(chaosType);             }         }          if (applicable.isEmpty()) {             return null;         }          int index = random.nextInt(applicable.size());         return applicable.get(index);     }" compose:Replacement merge: LineBased]
												[T -> terminateNow(String-String-String-String-ChaosType-ChaosType) : MethodDecl "@Override     public Event terminateNow(String type, String name, ChaosType chaosType)             throws FeatureNotEnabledException, InstanceGroupNotFoundException {         Validate.notNull(type);         Validate.notNull(name);         cfg.reload(name);         if (!isChaosMonkeyEnabled()) {             String msg = String.format("Chaos monkey is not enabled for group %s [type %s]",                     name, type);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }         String prop = NS + "terminateOndemand.enabled";         if (cfg.getBool(prop)) {             InstanceGroup group = findInstanceGroup(type, name);             if (group == null) {                 throw new InstanceGroupNotFoundException(type, name);             }             Collection<String> instances = context().chaosInstanceSelector().select(group, 1.0);             Validate.isTrue(instances.size() <= 1);             if (instances.size() == 1) {                 return terminateInstance(group, instances.iterator().next(), chaosType);             } else {                 throw new NotFoundException(String.format("No instance is found in group %s [type %s]",                         name, type));             }         } else {             String msg = String.format("Group %s [type %s] does not allow on-demand termination, set %s=true",                     name, type, prop);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }     }" compose:Replacement merge: LineBased]
												[T -> reportEventForSummary(EventTypes-EventTypes-InstanceGroup-InstanceGroup-String-String) : MethodDecl "private void reportEventForSummary(EventTypes eventType, InstanceGroup group, String instanceId) {         context().reportEvent(createEvent(eventType, group, instanceId));     }" compose:Replacement merge: LineBased]
												[T -> handleTerminationError(String-String-Throwable-Throwable) : MethodDecl "protected void handleTerminationError(String instance, Throwable e) {         LOGGER.error("failed to terminate instance " + instance, e.getMessage());         throw new RuntimeException("failed to terminate instance " + instance, e);     }" compose:Replacement merge: LineBased]
												[T -> recordTermination(InstanceGroup-InstanceGroup-String-String-ChaosType-ChaosType) : MethodDecl "@Override     public Event recordTermination(InstanceGroup group, String instance, ChaosType chaosType) {         Event evt = context().recorder().newEvent(Type.CHAOS, EventTypes.CHAOS_TERMINATION, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         evt.addField("chaosType", chaosType.getKey());         context().recorder().recordEvent(evt);         return evt;     }" compose:Replacement merge: LineBased]
												[T -> getPreviousTerminationCount(InstanceGroup-InstanceGroup-Date-Date) : MethodDecl "@Override     public int getPreviousTerminationCount(InstanceGroup group, Date after) {         Map<String, String> query = new HashMap<String, String>();         query.put("groupType", group.type().name());         query.put("groupName", group.name());         List<Event> evts = context().recorder().findEvents(Type.CHAOS, EventTypes.CHAOS_TERMINATION, query, after);         return evts.size();     }" compose:Replacement merge: LineBased]
												[T -> createEvent(EventTypes-EventTypes-InstanceGroup-InstanceGroup-String-String) : MethodDecl "private Event createEvent(EventTypes chaosTermination, InstanceGroup group, String instance) {         Event evt = context().recorder().newEvent(Type.CHAOS, chaosTermination, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         return evt;     }" compose:Replacement merge: LineBased]
												[T -> getEffectiveProbability(InstanceGroup-InstanceGroup) : MethodDecl "protected double getEffectiveProbability(InstanceGroup group) {         if (!isGroupEnabled(group)) {             return 0;         }         return getEffectiveProbabilityFromCfg(group);     }" compose:Replacement merge: LineBased]
												[T -> getEffectiveProbabilityFromCfg(InstanceGroup-InstanceGroup) : MethodDecl "protected double getEffectiveProbabilityFromCfg(InstanceGroup group) {         String propName;         if (cfg.getBool(NS + "mandatoryTermination.enabled")) {             String mtwProp = NS + "mandatoryTermination.windowInDays";             int mandatoryTerminationWindowInDays = (int) cfg.getNumOrElse(mtwProp, 0);             if (mandatoryTerminationWindowInDays > 0                     && noTerminationInLastWindow(group, mandatoryTerminationWindowInDays)) {                 double mandatoryProb = cfg.getNumOrElse(NS + "mandatoryTermination.defaultProbability",                         DEFAULT_MANDATORY_TERMINATION_PROBABILITY);                 LOGGER.info("There has been no terminations for group {} [type {}] in the last {} days,"                         + "setting the probability to {} for mandatory termination.",                         new Object[]{group.name(), group.type(), mandatoryTerminationWindowInDays, mandatoryProb});                 return mandatoryProb;             }         }         propName = "probability";         String defaultProp = NS + group.type();         String probProp = NS + group.type() + "." + group.name() + "." + propName;         double prob = cfg.getNumOrElse(probProp, cfg.getNumOrElse(defaultProp + "." + propName, 1.0));         LOGGER.info("Group {} [type {}] enabled [prob {}]", new Object[]{group.name(), group.type(), prob});         return prob;     }" compose:Replacement merge: LineBased]
												[T -> getLastOptInMilliseconds(InstanceGroup-InstanceGroup) : MethodDecl "protected long getLastOptInMilliseconds(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".lastOptInTimeInMilliseconds";         long lastOptInTimeInMilliseconds = (long) cfg.getNumOrElse(prop, -1);         return lastOptInTimeInMilliseconds;     }" compose:Replacement merge: LineBased]
												[T -> noTerminationInLastWindow(InstanceGroup-InstanceGroup-int-int) : MethodDecl "private boolean noTerminationInLastWindow(InstanceGroup group, int mandatoryTerminationWindowInDays) {     long lastOptInTimeInMilliseconds = getLastOptInMilliseconds(group);         if (lastOptInTimeInMilliseconds < 0) {             return false;         }          Calendar windowStart = monkeyCalendar.now();         windowStart.add(Calendar.DATE, -1 * mandatoryTerminationWindowInDays);          // return true if the window start is after the last opt-in time and         // there has been no termination since the window start         if (windowStart.getTimeInMillis() > lastOptInTimeInMilliseconds                 && getPreviousTerminationCount(group, windowStart.getTime()) <= 0) {             return true;         }          return false;     }" compose:Replacement merge: LineBased]
												[T -> isGroupEnabled(InstanceGroup-InstanceGroup) : MethodDecl "protected boolean isGroupEnabled(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".enabled";         String defaultProp = NS + group.type() + ".enabled";         if (cfg.getBoolOrElse(prop, cfg.getBool(defaultProp))) {             return true;         } else {             LOGGER.info("Group {} [type {}] disabled, set {}=true or {}=true",                     new Object[]{group.name(), group.type(), prop, defaultProp});             return false;         }     }" compose:Replacement merge: LineBased]
												[T -> isChaosMonkeyEnabled({FormalParametersInternal}) : MethodDecl "private boolean isChaosMonkeyEnabled() {         String prop = NS + "enabled";         if (cfg.getBoolOrElse(prop, true)) {             return true;         }         LOGGER.info("ChaosMonkey disabled, set {}=true", prop);         return false;     }" compose:Replacement merge: LineBased]
												[T -> findInstanceGroup(String-String-String-String) : MethodDecl "private InstanceGroup findInstanceGroup(String type, String name) {         // Calling context().chaosCrawler().groups(name) causes a new crawl to get         // the up to date information for the group name.         for (InstanceGroup group : context().chaosCrawler().groups(name)) {             if (group.type().toString().equals(type) && group.name().equals(name)) {                 return group;             }         }         LOGGER.warn("Failed to find instance group for type {} and name {}", type, name);         return null;     }" compose:Replacement merge: LineBased]
												[T -> terminateInstance(InstanceGroup-InstanceGroup-String-String-ChaosType-ChaosType) : MethodDecl "private Event terminateInstance(InstanceGroup group, String inst, ChaosType chaosType) {         Validate.notNull(group);         Validate.notEmpty(inst);         String prop = NS + "leashed";         if (cfg.getBoolOrElse(prop, true)) {             LOGGER.info("leashed ChaosMonkey prevented from killing {} from group {} [{}], set {}=false",                     new Object[]{inst, group.name(), group.type(), prop});             reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);             return null;         } else {             try {                 Event evt = recordTermination(group, inst, chaosType);                 sendTerminationNotification(group, inst);                 chaosType.apply(context().cloudClient(), inst);                 LOGGER.info("Terminated {} from group {} [{}] with {}",                         new Object[]{inst, group.name(), group.type(), chaosType.getKey() });                 reportEventForSummary(EventTypes.CHAOS_TERMINATION, group, inst);                 return evt;             } catch (NotFoundException e) {                 LOGGER.warn("Failed to terminate " + inst + ", it does not exist. Perhaps it was already terminated");                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             } catch (Exception e) {                 handleTerminationError(inst, e);                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             }         }     }" compose:Replacement merge: LineBased]
												[T -> isMaxTerminationCountExceeded(InstanceGroup-InstanceGroup) : MethodDecl "protected boolean isMaxTerminationCountExceeded(InstanceGroup group) {         Validate.notNull(group);         String propName = "maxTerminationsPerDay";         String defaultProp = String.format("%s%s.%s", NS, group.type(), propName);         String prop = String.format("%s%s.%s.%s", NS, group.type(), group.name(), propName);         double maxTerminationsPerDay = cfg.getNumOrElse(prop, cfg.getNumOrElse(defaultProp, 1.0));         if (maxTerminationsPerDay <= MIN_MAX_TERMINATION_COUNT_PER_DAY) {             LOGGER.info("ChaosMonkey is configured to not allow any killing from group {} [{}] "                     + "with max daily count set as {}", new Object[]{group.name(), group.type(), prop});             return true;         } else {             int daysBack = 1;             int maxCount = (int) maxTerminationsPerDay;             if (maxTerminationsPerDay < 1.0) {                 daysBack = (int) Math.ceil(1 / maxTerminationsPerDay);                 maxCount = 1;             }             Calendar after = monkeyCalendar.now();             after.add(Calendar.DATE, -1 * daysBack);             // Check if the group has exceeded the maximum terminations for the last period             int terminationCount = getPreviousTerminationCount(group, after.getTime());             if (terminationCount >= maxCount) {                 LOGGER.info("The count of terminations for group {} [{}] in the last {} days is {},"                         + " equal or greater than the max count threshold {}",                         new Object[]{group.name(), group.type(), daysBack, terminationCount, maxCount});                 return true;             }         }         return false;     }" compose:Replacement merge: LineBased]
												[T -> sendTerminationNotification(InstanceGroup-InstanceGroup-String-String) : MethodDecl "@Override     public void sendTerminationNotification(InstanceGroup group, String instance) {         String propEmailGlobalEnabled = "simianarmy.chaos.notification.global.enabled";         String propEmailGroupEnabled = String.format("%s%s.%s.notification.enabled", NS, group.type(), group.name());          ChaosEmailNotifier notifier = context().chaosEmailNotifier();         if (notifier == null) {             String msg = "Chaos email notifier is not set.";             LOGGER.error(msg);             throw new RuntimeException(msg);         }         if (cfg.getBoolOrElse(propEmailGroupEnabled, false)) {             notifier.sendTerminationNotification(group, instance);         }         if (cfg.getBoolOrElse(propEmailGlobalEnabled, false)) {             notifier.sendTerminationGlobalNotification(group, instance);         }     }" compose:Replacement merge: LineBased]
												[T -> getChaosTypes({FormalParametersInternal}) : MethodDecl "@Override     public List<ChaosType> getChaosTypes() {         return Lists.newArrayList(enabledChaosTypes);     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> netflix : Folder]
						[NT -> simianarmy : Folder]
							[NT -> basic : Folder]
								[NT -> chaos : Folder]
									[NT -> BasicChaosMonkey.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.netflix.simianarmy.basic.chaos;" compose:Replacement merge: Default]
											[T -> java.util.Calendar{ImportPackage} : ImportDeclaration "import java.util.Calendar;" compose:Replacement merge: Default]
											[T -> java.util.Collection{ImportPackage} : ImportDeclaration "import java.util.Collection;" compose:Replacement merge: Default]
											[T -> java.util.Date{ImportPackage} : ImportDeclaration "import java.util.Date;" compose:Replacement merge: Default]
											[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
											[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
											[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
											[T -> java.util.Random{ImportPackage} : ImportDeclaration "import java.util.Random;" compose:Replacement merge: Default]
											[T -> java.util.concurrent.TimeUnit{ImportPackage} : ImportDeclaration "import java.util.concurrent.TimeUnit;" compose:Replacement merge: Default]
											[T -> org.apache.commons.lang.Validate{ImportPackage} : ImportDeclaration "import org.apache.commons.lang.Validate;" compose:Replacement merge: Default]
											[T -> org.slf4j.Logger{ImportPackage} : ImportDeclaration "import org.slf4j.Logger;" compose:Replacement merge: Default]
											[T -> org.slf4j.LoggerFactory{ImportPackage} : ImportDeclaration "import org.slf4j.LoggerFactory;" compose:Replacement merge: Default]
											[T -> com.google.common.collect.Lists{ImportPackage} : ImportDeclaration "import com.google.common.collect.Lists;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.CloudClient{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.CloudClient;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.FeatureNotEnabledException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.FeatureNotEnabledException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.InstanceGroupNotFoundException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.InstanceGroupNotFoundException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyCalendar{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyCalendar;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyConfiguration{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyConfiguration;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.MonkeyRecorder.Event{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.MonkeyRecorder.Event;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.NotFoundException{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.NotFoundException;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosEmailNotifier{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosEmailNotifier;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosMonkey{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosMonkey;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ChaosType;" compose:Replacement merge: Default]
											[T -> com.netflix.simianarmy.chaos.ShutdownInstanceChaosType{ImportPackage} : ImportDeclaration "import com.netflix.simianarmy.chaos.ShutdownInstanceChaosType;" compose:Replacement merge: Default]
											[NT -> BasicChaosMonkey : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> BasicChaosMonkey : Id "BasicChaosMonkey" compose:Replacement merge: Default]
												[T -> - : ExtendsList "extends ChaosMonkey" compose:Replacement merge: Default]
												[T -> LOGGER : FieldDecl "private static final Logger LOGGER = LoggerFactory.getLogger(BasicChaosMonkey.class);" compose:Replacement merge: SemanticConflict]
												[T -> NS : FieldDecl "private static final String NS = "simianarmy.chaos.";" compose:Replacement merge: SemanticConflict]
												[T -> cfg : FieldDecl "private final MonkeyConfiguration cfg;" compose:Replacement merge: SemanticConflict]
												[T -> runsPerDay : FieldDecl "private final long runsPerDay;" compose:Replacement merge: SemanticConflict]
												[T -> MIN_MAX_TERMINATION_COUNT_PER_DAY : FieldDecl "private static final double MIN_MAX_TERMINATION_COUNT_PER_DAY = 0.001;" compose:Replacement merge: SemanticConflict]
												[T -> monkeyCalendar : FieldDecl "private final MonkeyCalendar monkeyCalendar;" compose:Replacement merge: SemanticConflict]
												[T -> DEFAULT_MANDATORY_TERMINATION_PROBABILITY : FieldDecl "private static final double DEFAULT_MANDATORY_TERMINATION_PROBABILITY = 0.5;" compose:Replacement merge: SemanticConflict]
												[T -> allChaosTypes : FieldDecl "private final List<ChaosType> allChaosTypes;" compose:Replacement merge: SemanticConflict]
												[T -> BasicChaosMonkey(ChaosMonkey.Context-ChaosMonkey.Context) : ConstructorDecl "public BasicChaosMonkey(ChaosMonkey.Context ctx) {         super(ctx);          this.cfg = ctx.configuration();         this.monkeyCalendar = ctx.calendar();          Calendar open = monkeyCalendar.now();         Calendar close = monkeyCalendar.now();         open.set(Calendar.HOUR, monkeyCalendar.openHour());         close.set(Calendar.HOUR, monkeyCalendar.closeHour());          allChaosTypes = Lists.newArrayList();         allChaosTypes.add(new ShutdownInstanceChaosType(cfg));          TimeUnit freqUnit = ctx.scheduler().frequencyUnit();         long units = freqUnit.convert(close.getTimeInMillis() - open.getTimeInMillis(), TimeUnit.MILLISECONDS);         runsPerDay = units / ctx.scheduler().frequency();     }" compose:Replacement merge: LineBased]
												[T -> doMonkeyBusiness({FormalParametersInternal}) : MethodDecl "@Override     public void doMonkeyBusiness() {         context().resetEventReport();         cfg.reload();         if (!isChaosMonkeyEnabled()) {             return;         }         for (InstanceGroup group : context().chaosCrawler().groups()) {             if (isGroupEnabled(group)) {                 if (isMaxTerminationCountExceeded(group)) {                     continue;                 }                 double prob = getEffectiveProbability(group);                 Collection<String> instances = context().chaosInstanceSelector().select(group, prob / runsPerDay);                 for (String inst : instances) {                     ChaosType chaosType = pickChaosType(context().cloudClient(), inst);                     if (chaosType == null) {                         // This is surprising ... normally we can always just terminate it                         LOGGER.warn("No chaos type was applicable to the instance: {}", inst);                         continue;                     }                     terminateInstance(group, inst, chaosType);                 }             }         }     }" compose:Replacement merge: LineBased]
												[T -> pickChaosType(CloudClient-CloudClient-String-String) : MethodDecl "private ChaosType pickChaosType(CloudClient cloudClient, String instanceId) {         Random random = new Random();          List<ChaosType> applicable = Lists.newArrayList();         for (ChaosType chaosType : allChaosTypes) {             if (chaosType.canApply(cloudClient, instanceId)) {                 applicable.add(chaosType);             }         }          if (applicable.isEmpty()) {             return null;         }          int index = random.nextInt(applicable.size());         return applicable.get(index);     }" compose:Replacement merge: LineBased]
												[T -> terminateNow(String-String-String-String-ChaosType-ChaosType) : MethodDecl "@Override     public Event terminateNow(String type, String name, ChaosType chaosType)             throws FeatureNotEnabledException, InstanceGroupNotFoundException {         Validate.notNull(type);         Validate.notNull(name);         cfg.reload(name);         if (!isChaosMonkeyEnabled()) {             String msg = String.format("Chaos monkey is not enabled for group %s [type %s]",                     name, type);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }         String prop = NS + "terminateOndemand.enabled";         if (cfg.getBool(prop)) {             InstanceGroup group = findInstanceGroup(type, name);             if (group == null) {                 throw new InstanceGroupNotFoundException(type, name);             }             Collection<String> instances = context().chaosInstanceSelector().select(group, 1.0);             Validate.isTrue(instances.size() <= 1);             if (instances.size() == 1) {                 return terminateInstance(group, instances.iterator().next(), chaosType);             } else {                 throw new NotFoundException(String.format("No instance is found in group %s [type %s]",                         name, type));             }         } else {             String msg = String.format("Group %s [type %s] does not allow on-demand termination, set %s=true",                     name, type, prop);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }     }" compose:Replacement merge: LineBased]
												[T -> reportEventForSummary(EventTypes-EventTypes-InstanceGroup-InstanceGroup-String-String) : MethodDecl "private void reportEventForSummary(EventTypes eventType, InstanceGroup group, String instanceId) {         context().reportEvent(createEvent(eventType, group, instanceId));     }" compose:Replacement merge: LineBased]
												[T -> handleTerminationError(String-String-Throwable-Throwable) : MethodDecl "protected void handleTerminationError(String instance, Throwable e) {         LOGGER.error("failed to terminate instance " + instance, e.getMessage());         throw new RuntimeException("failed to terminate instance " + instance, e);     }" compose:Replacement merge: LineBased]
												[T -> recordTermination(InstanceGroup-InstanceGroup-String-String-ChaosType-ChaosType) : MethodDecl "@Override     public Event recordTermination(InstanceGroup group, String instance, ChaosType chaosType) {         Event evt = context().recorder().newEvent(Type.CHAOS, EventTypes.CHAOS_TERMINATION, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         evt.addField("chaosType", chaosType.getKey());         context().recorder().recordEvent(evt);         return evt;     }" compose:Replacement merge: LineBased]
												[T -> getPreviousTerminationCount(InstanceGroup-InstanceGroup-Date-Date) : MethodDecl "@Override     public int getPreviousTerminationCount(InstanceGroup group, Date after) {         Map<String, String> query = new HashMap<String, String>();         query.put("groupType", group.type().name());         query.put("groupName", group.name());         List<Event> evts = context().recorder().findEvents(Type.CHAOS, EventTypes.CHAOS_TERMINATION, query, after);         return evts.size();     }" compose:Replacement merge: LineBased]
												[T -> createEvent(EventTypes-EventTypes-InstanceGroup-InstanceGroup-String-String) : MethodDecl "private Event createEvent(EventTypes chaosTermination, InstanceGroup group, String instance) {         Event evt = context().recorder().newEvent(Type.CHAOS, chaosTermination, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         return evt;     }" compose:Replacement merge: LineBased]
												[T -> getEffectiveProbability(InstanceGroup-InstanceGroup) : MethodDecl "protected double getEffectiveProbability(InstanceGroup group) {         if (!isGroupEnabled(group)) {             return 0;         }         return getEffectiveProbabilityFromCfg(group);     }" compose:Replacement merge: LineBased]
												[T -> getEffectiveProbabilityFromCfg(InstanceGroup-InstanceGroup) : MethodDecl "protected double getEffectiveProbabilityFromCfg(InstanceGroup group) {         String propName;         if (cfg.getBool(NS + "mandatoryTermination.enabled")) {             String mtwProp = NS + "mandatoryTermination.windowInDays";             int mandatoryTerminationWindowInDays = (int) cfg.getNumOrElse(mtwProp, 0);             if (mandatoryTerminationWindowInDays > 0                     && noTerminationInLastWindow(group, mandatoryTerminationWindowInDays)) {                 double mandatoryProb = cfg.getNumOrElse(NS + "mandatoryTermination.defaultProbability",                         DEFAULT_MANDATORY_TERMINATION_PROBABILITY);                 LOGGER.info("There has been no terminations for group {} [type {}] in the last {} days,"                         + "setting the probability to {} for mandatory termination.",                         new Object[]{group.name(), group.type(), mandatoryTerminationWindowInDays, mandatoryProb});                 return mandatoryProb;             }         }         propName = "probability";         String defaultProp = NS + group.type();         String probProp = NS + group.type() + "." + group.name() + "." + propName;         double prob = cfg.getNumOrElse(probProp, cfg.getNumOrElse(defaultProp + "." + propName, 1.0));         LOGGER.info("Group {} [type {}] enabled [prob {}]", new Object[]{group.name(), group.type(), prob});         return prob;     }" compose:Replacement merge: LineBased]
												[T -> getLastOptInMilliseconds(InstanceGroup-InstanceGroup) : MethodDecl "protected long getLastOptInMilliseconds(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".lastOptInTimeInMilliseconds";         long lastOptInTimeInMilliseconds = (long) cfg.getNumOrElse(prop, -1);         return lastOptInTimeInMilliseconds;     }" compose:Replacement merge: LineBased]
												[T -> noTerminationInLastWindow(InstanceGroup-InstanceGroup-int-int) : MethodDecl "private boolean noTerminationInLastWindow(InstanceGroup group, int mandatoryTerminationWindowInDays) {     long lastOptInTimeInMilliseconds = getLastOptInMilliseconds(group);         if (lastOptInTimeInMilliseconds < 0) {             return false;         }          Calendar windowStart = monkeyCalendar.now();         windowStart.add(Calendar.DATE, -1 * mandatoryTerminationWindowInDays);          // return true if the window start is after the last opt-in time and         // there has been no termination since the window start         if (windowStart.getTimeInMillis() > lastOptInTimeInMilliseconds                 && getPreviousTerminationCount(group, windowStart.getTime()) <= 0) {             return true;         }          return false;     }" compose:Replacement merge: LineBased]
												[T -> isGroupEnabled(InstanceGroup-InstanceGroup) : MethodDecl "protected boolean isGroupEnabled(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".enabled";         String defaultProp = NS + group.type() + ".enabled";         if (cfg.getBoolOrElse(prop, cfg.getBool(defaultProp))) {             return true;         } else {             LOGGER.info("Group {} [type {}] disabled, set {}=true or {}=true",                     new Object[]{group.name(), group.type(), prop, defaultProp});             return false;         }     }" compose:Replacement merge: LineBased]
												[T -> isChaosMonkeyEnabled({FormalParametersInternal}) : MethodDecl "private boolean isChaosMonkeyEnabled() {         String prop = NS + "enabled";         if (cfg.getBoolOrElse(prop, true)) {             return true;         }         LOGGER.info("ChaosMonkey disabled, set {}=true", prop);         return false;     }" compose:Replacement merge: LineBased]
												[T -> findInstanceGroup(String-String-String-String) : MethodDecl "private InstanceGroup findInstanceGroup(String type, String name) {         // Calling context().chaosCrawler().groups(name) causes a new crawl to get         // the up to date information for the group name.         for (InstanceGroup group : context().chaosCrawler().groups(name)) {             if (group.type().toString().equals(type) && group.name().equals(name)) {                 return group;             }         }         LOGGER.warn("Failed to find instance group for type {} and name {}", type, name);         return null;     }" compose:Replacement merge: LineBased]
												[T -> terminateInstance(InstanceGroup-InstanceGroup-String-String-ChaosType-ChaosType) : MethodDecl "private Event terminateInstance(InstanceGroup group, String inst, ChaosType chaosType) {         Validate.notNull(group);         Validate.notEmpty(inst);         String prop = NS + "leashed";         if (cfg.getBoolOrElse(prop, true)) {             LOGGER.info("leashed ChaosMonkey prevented from killing {} from group {} [{}], set {}=false",                     new Object[]{inst, group.name(), group.type(), prop});             reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);             return null;         } else {             try {                 Event evt = recordTermination(group, inst, chaosType);                 sendTerminationNotification(group, inst);                 chaosType.apply(context().cloudClient(), inst);                 LOGGER.info("Terminated {} from group {} [{}] with {}",                         new Object[]{inst, group.name(), group.type(), chaosType.getKey() });                 reportEventForSummary(EventTypes.CHAOS_TERMINATION, group, inst);                 return evt;             } catch (NotFoundException e) {                 LOGGER.warn("Failed to terminate " + inst + ", it does not exist. Perhaps it was already terminated");                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             } catch (Exception e) {                 handleTerminationError(inst, e);                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             }         }     }" compose:Replacement merge: LineBased]
												[T -> isMaxTerminationCountExceeded(InstanceGroup-InstanceGroup) : MethodDecl "protected boolean isMaxTerminationCountExceeded(InstanceGroup group) {         Validate.notNull(group);         String propName = "maxTerminationsPerDay";         String defaultProp = String.format("%s%s.%s", NS, group.type(), propName);         String prop = String.format("%s%s.%s.%s", NS, group.type(), group.name(), propName);         double maxTerminationsPerDay = cfg.getNumOrElse(prop, cfg.getNumOrElse(defaultProp, 1.0));         if (maxTerminationsPerDay <= MIN_MAX_TERMINATION_COUNT_PER_DAY) {             LOGGER.info("ChaosMonkey is configured to not allow any killing from group {} [{}] "                     + "with max daily count set as {}", new Object[]{group.name(), group.type(), prop});             return true;         } else {             int daysBack = 1;             int maxCount = (int) maxTerminationsPerDay;             if (maxTerminationsPerDay < 1.0) {                 daysBack = (int) Math.ceil(1 / maxTerminationsPerDay);                 maxCount = 1;             }             Calendar after = monkeyCalendar.now();             after.add(Calendar.DATE, -1 * daysBack);             // Check if the group has exceeded the maximum terminations for the last period             int terminationCount = getPreviousTerminationCount(group, after.getTime());             if (terminationCount >= maxCount) {                 LOGGER.info("The count of terminations for group {} [{}] in the last {} days is {},"                         + " equal or greater than the max count threshold {}",                         new Object[]{group.name(), group.type(), daysBack, terminationCount, maxCount});                 return true;             }         }         return false;     }" compose:Replacement merge: LineBased]
												[T -> sendTerminationNotification(InstanceGroup-InstanceGroup-String-String) : MethodDecl "@Override     public void sendTerminationNotification(InstanceGroup group, String instance) {         String propEmailGlobalEnabled = "simianarmy.chaos.notification.global.enabled";         String propEmailGroupEnabled = String.format("%s%s.%s.notification.enabled", NS, group.type(), group.name());          ChaosEmailNotifier notifier = context().chaosEmailNotifier();         if (notifier == null) {             String msg = "Chaos email notifier is not set.";             LOGGER.error(msg);             throw new RuntimeException(msg);         }         if (cfg.getBoolOrElse(propEmailGroupEnabled, false)) {             notifier.sendTerminationNotification(group, instance);         }         if (cfg.getBoolOrElse(propEmailGlobalEnabled, false)) {             notifier.sendTerminationGlobalNotification(group, instance);         }     }" compose:Replacement merge: LineBased]
												[T -> getChaosTypes({FormalParametersInternal}) : MethodDecl "@Override     public List<ChaosType> getChaosTypes() {         return Lists.newArrayList(allChaosTypes);     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> netflix : Folder]
						[NT -> simianarmy : Folder]
							[NT -> basic : Folder]
								[NT -> chaos : Folder]
									[NT -> BasicChaosMonkey.java.merge : .java.merge-File]
										[T -> BasicChaosMonkey.java : .java-Content "/*  *  *  Copyright 2012 Netflix, Inc.  *  *     Licensed under the Apache License, Version 2.0 (the "License");  *     you may not use this file except in compliance with the License.  *     You may obtain a copy of the License at  *  *         http://www.apache.org/licenses/LICENSE-2.0  *  *     Unless required by applicable law or agreed to in writing, software  *     distributed under the License is distributed on an "AS IS" BASIS,  *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *     See the License for the specific language governing permissions and  *     limitations under the License.  *  */ package com.netflix.simianarmy.basic.chaos;  import java.util.Calendar; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Random; import java.util.concurrent.TimeUnit;  import org.apache.commons.lang.Validate; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import com.google.common.collect.Lists; import com.netflix.simianarmy.CloudClient; import com.netflix.simianarmy.FeatureNotEnabledException; import com.netflix.simianarmy.InstanceGroupNotFoundException; import com.netflix.simianarmy.MonkeyCalendar; import com.netflix.simianarmy.MonkeyConfiguration; import com.netflix.simianarmy.MonkeyRecorder.Event; import com.netflix.simianarmy.NotFoundException; import com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup; import com.netflix.simianarmy.chaos.ChaosEmailNotifier; import com.netflix.simianarmy.chaos.ChaosMonkey; import com.netflix.simianarmy.chaos.ChaosType; import com.netflix.simianarmy.chaos.DetachVolumesChaosType; import com.netflix.simianarmy.chaos.ShutdownInstanceChaosType;  /**  * The Class BasicChaosMonkey.  */ public class BasicChaosMonkey extends ChaosMonkey {      /** The Constant LOGGER. */     private static final Logger LOGGER = LoggerFactory.getLogger(BasicChaosMonkey.class);      /** The Constant NS. */     private static final String NS = "simianarmy.chaos.";      /** The cfg. */     private final MonkeyConfiguration cfg;      /** The runs per day. */     private final long runsPerDay;      /** The minimum value of the maxTerminationCountPerday property to be considered non-zero. **/     private static final double MIN_MAX_TERMINATION_COUNT_PER_DAY = 0.001;      private final MonkeyCalendar monkeyCalendar;      // When a mandatory termination is triggered due to the minimum termination limit is breached,     // the value below is used as the termination probability.     private static final double DEFAULT_MANDATORY_TERMINATION_PROBABILITY = 0.5;      private final List<ChaosType> enabledChaosTypes;      /**      * Instantiates a new basic chaos monkey.      * @param ctx      *            the ctx      */     public BasicChaosMonkey(ChaosMonkey.Context ctx) {         super(ctx);          this.cfg = ctx.configuration();         this.monkeyCalendar = ctx.calendar();          Calendar open = monkeyCalendar.now();         Calendar close = monkeyCalendar.now();         open.set(Calendar.HOUR, monkeyCalendar.openHour());         close.set(Calendar.HOUR, monkeyCalendar.closeHour());          enabledChaosTypes = Lists.newArrayList();         enabledChaosTypes.add(new ShutdownInstanceChaosType(cfg));         enabledChaosTypes.add(new DetachVolumesChaosType(cfg));          TimeUnit freqUnit = ctx.scheduler().frequencyUnit();         long units = freqUnit.convert(close.getTimeInMillis() - open.getTimeInMillis(), TimeUnit.MILLISECONDS);         runsPerDay = units / ctx.scheduler().frequency();     }      /** {@inheritDoc} */     @Override     public void doMonkeyBusiness() {         context().resetEventReport();         cfg.reload();         if (!isChaosMonkeyEnabled()) {             return;         }         for (InstanceGroup group : context().chaosCrawler().groups()) {             if (isGroupEnabled(group)) {                 if (isMaxTerminationCountExceeded(group)) {                     continue;                 }                 double prob = getEffectiveProbability(group);                 Collection<String> instances = context().chaosInstanceSelector().select(group, prob / runsPerDay);                 for (String inst : instances) {                     ChaosType chaosType = pickChaosType(context().cloudClient(), inst);                     if (chaosType == null) {                         // This is surprising ... normally we can always just terminate it                         LOGGER.warn("No chaos type was applicable to the instance: {}", inst);                         continue;                     }                     terminateInstance(group, inst, chaosType);                 }             }         }     }      private ChaosType pickChaosType(CloudClient cloudClient, String instanceId) {         Random random = new Random();          List<ChaosType> applicable = Lists.newArrayList();         for (ChaosType chaosType : enabledChaosTypes) {             if (chaosType.canApply(cloudClient, instanceId)) {                 applicable.add(chaosType);             }         }          if (applicable.isEmpty()) {             return null;         }          int index = random.nextInt(applicable.size());         return applicable.get(index);     }      @Override     public Event terminateNow(String type, String name, ChaosType chaosType)             throws FeatureNotEnabledException, InstanceGroupNotFoundException {         Validate.notNull(type);         Validate.notNull(name);         cfg.reload(name);         if (!isChaosMonkeyEnabled()) {             String msg = String.format("Chaos monkey is not enabled for group %s [type %s]",                     name, type);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }         String prop = NS + "terminateOndemand.enabled";         if (cfg.getBool(prop)) {             InstanceGroup group = findInstanceGroup(type, name);             if (group == null) {                 throw new InstanceGroupNotFoundException(type, name);             }             Collection<String> instances = context().chaosInstanceSelector().select(group, 1.0);             Validate.isTrue(instances.size() <= 1);             if (instances.size() == 1) {                 return terminateInstance(group, instances.iterator().next(), chaosType);             } else {                 throw new NotFoundException(String.format("No instance is found in group %s [type %s]",                         name, type));             }         } else {             String msg = String.format("Group %s [type %s] does not allow on-demand termination, set %s=true",                     name, type, prop);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }     }      private void reportEventForSummary(EventTypes eventType, InstanceGroup group, String instanceId) {         context().reportEvent(createEvent(eventType, group, instanceId));     }      /**      * Handle termination error. This has been abstracted so subclasses can decide to continue causing chaos if desired.      *      * @param instance      *            the instance      * @param e      *            the exception      */     protected void handleTerminationError(String instance, Throwable e) {         LOGGER.error("failed to terminate instance " + instance, e.getMessage());         throw new RuntimeException("failed to terminate instance " + instance, e);     }      /** {@inheritDoc} */     @Override     public Event recordTermination(InstanceGroup group, String instance, ChaosType chaosType) {         Event evt = context().recorder().newEvent(Type.CHAOS, EventTypes.CHAOS_TERMINATION, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         evt.addField("chaosType", chaosType.getKey());         context().recorder().recordEvent(evt);         return evt;     }      /** {@inheritDoc} */     @Override     public int getPreviousTerminationCount(InstanceGroup group, Date after) {         Map<String, String> query = new HashMap<String, String>();         query.put("groupType", group.type().name());         query.put("groupName", group.name());         List<Event> evts = context().recorder().findEvents(Type.CHAOS, EventTypes.CHAOS_TERMINATION, query, after);         return evts.size();     }      private Event createEvent(EventTypes chaosTermination, InstanceGroup group, String instance) {         Event evt = context().recorder().newEvent(Type.CHAOS, chaosTermination, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         return evt;     }      /**      * Gets the effective probability value, returns 0 if the group is not enabled. Otherwise calls      * getEffectiveProbability.      * @param group      * @return the effective probability value for the instance group      */     protected double getEffectiveProbability(InstanceGroup group) {         if (!isGroupEnabled(group)) {             return 0;         }         return getEffectiveProbabilityFromCfg(group);     }      /**      * Gets the effective probability value when the monkey processes an instance group, it uses the following      * logic in the order as listed below.      *      * 1) When minimum mandatory termination is enabled, a default non-zero probability is used for opted-in      * groups, if a) the application has been opted in for the last mandatory termination window      *        and b) there was no terminations in the last mandatory termination window      * 2) Use the probability configured for the group type and name      * 3) Use the probability configured for the group      * 4) Use 1.0      * @param group      * @return double      */     protected double getEffectiveProbabilityFromCfg(InstanceGroup group) {         String propName;         if (cfg.getBool(NS + "mandatoryTermination.enabled")) {             String mtwProp = NS + "mandatoryTermination.windowInDays";             int mandatoryTerminationWindowInDays = (int) cfg.getNumOrElse(mtwProp, 0);             if (mandatoryTerminationWindowInDays > 0                     && noTerminationInLastWindow(group, mandatoryTerminationWindowInDays)) {                 double mandatoryProb = cfg.getNumOrElse(NS + "mandatoryTermination.defaultProbability",                         DEFAULT_MANDATORY_TERMINATION_PROBABILITY);                 LOGGER.info("There has been no terminations for group {} [type {}] in the last {} days,"                         + "setting the probability to {} for mandatory termination.",                         new Object[]{group.name(), group.type(), mandatoryTerminationWindowInDays, mandatoryProb});                 return mandatoryProb;             }         }         propName = "probability";         String defaultProp = NS + group.type();         String probProp = NS + group.type() + "." + group.name() + "." + propName;         double prob = cfg.getNumOrElse(probProp, cfg.getNumOrElse(defaultProp + "." + propName, 1.0));         LOGGER.info("Group {} [type {}] enabled [prob {}]", new Object[]{group.name(), group.type(), prob});         return prob;     }      /**      * Returns lastOptInTimeInMilliseconds from the .properties file.      *      * @param group      * @return long      */     protected long getLastOptInMilliseconds(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".lastOptInTimeInMilliseconds";         long lastOptInTimeInMilliseconds = (long) cfg.getNumOrElse(prop, -1);         return lastOptInTimeInMilliseconds;     }      private boolean noTerminationInLastWindow(InstanceGroup group, int mandatoryTerminationWindowInDays) {     long lastOptInTimeInMilliseconds = getLastOptInMilliseconds(group);         if (lastOptInTimeInMilliseconds < 0) {             return false;         }          Calendar windowStart = monkeyCalendar.now();         windowStart.add(Calendar.DATE, -1 * mandatoryTerminationWindowInDays);          // return true if the window start is after the last opt-in time and         // there has been no termination since the window start         if (windowStart.getTimeInMillis() > lastOptInTimeInMilliseconds                 && getPreviousTerminationCount(group, windowStart.getTime()) <= 0) {             return true;         }          return false;     }      /**      * Checks to see if the given instance group is enabled.      * @param group      * @return boolean      */     protected boolean isGroupEnabled(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".enabled";         String defaultProp = NS + group.type() + ".enabled";         if (cfg.getBoolOrElse(prop, cfg.getBool(defaultProp))) {             return true;         } else {             LOGGER.info("Group {} [type {}] disabled, set {}=true or {}=true",                     new Object[]{group.name(), group.type(), prop, defaultProp});             return false;         }     }      private boolean isChaosMonkeyEnabled() {         String prop = NS + "enabled";         if (cfg.getBoolOrElse(prop, true)) {             return true;         }         LOGGER.info("ChaosMonkey disabled, set {}=true", prop);         return false;     }      private InstanceGroup findInstanceGroup(String type, String name) {         // Calling context().chaosCrawler().groups(name) causes a new crawl to get         // the up to date information for the group name.         for (InstanceGroup group : context().chaosCrawler().groups(name)) {             if (group.type().toString().equals(type) && group.name().equals(name)) {                 return group;             }         }         LOGGER.warn("Failed to find instance group for type {} and name {}", type, name);         return null;     }      private Event terminateInstance(InstanceGroup group, String inst, ChaosType chaosType) {         Validate.notNull(group);         Validate.notEmpty(inst);         String prop = NS + "leashed";         if (cfg.getBoolOrElse(prop, true)) {             LOGGER.info("leashed ChaosMonkey prevented from killing {} from group {} [{}], set {}=false",                     new Object[]{inst, group.name(), group.type(), prop});             reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);             return null;         } else {             try {                 Event evt = recordTermination(group, inst, chaosType);                 sendTerminationNotification(group, inst);                 chaosType.apply(context().cloudClient(), inst);                 LOGGER.info("Terminated {} from group {} [{}] with {}",                         new Object[]{inst, group.name(), group.type(), chaosType.getKey() });                 reportEventForSummary(EventTypes.CHAOS_TERMINATION, group, inst);                 return evt;             } catch (NotFoundException e) {                 LOGGER.warn("Failed to terminate " + inst + ", it does not exist. Perhaps it was already terminated");                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             } catch (Exception e) {                 handleTerminationError(inst, e);                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             }         }     }      /**      * Checks to see if the maximum termination window has been exceeded.      *      * @param group      * @return boolean      */     protected boolean isMaxTerminationCountExceeded(InstanceGroup group) {         Validate.notNull(group);         String propName = "maxTerminationsPerDay";         String defaultProp = String.format("%s%s.%s", NS, group.type(), propName);         String prop = String.format("%s%s.%s.%s", NS, group.type(), group.name(), propName);         double maxTerminationsPerDay = cfg.getNumOrElse(prop, cfg.getNumOrElse(defaultProp, 1.0));         if (maxTerminationsPerDay <= MIN_MAX_TERMINATION_COUNT_PER_DAY) {             LOGGER.info("ChaosMonkey is configured to not allow any killing from group {} [{}] "                     + "with max daily count set as {}", new Object[]{group.name(), group.type(), prop});             return true;         } else {             int daysBack = 1;             int maxCount = (int) maxTerminationsPerDay;             if (maxTerminationsPerDay < 1.0) {                 daysBack = (int) Math.ceil(1 / maxTerminationsPerDay);                 maxCount = 1;             }             Calendar after = monkeyCalendar.now();             after.add(Calendar.DATE, -1 * daysBack);             // Check if the group has exceeded the maximum terminations for the last period             int terminationCount = getPreviousTerminationCount(group, after.getTime());             if (terminationCount >= maxCount) {                 LOGGER.info("The count of terminations for group {} [{}] in the last {} days is {},"                         + " equal or greater than the max count threshold {}",                         new Object[]{group.name(), group.type(), daysBack, terminationCount, maxCount});                 return true;             }         }         return false;     }      @Override     public void sendTerminationNotification(InstanceGroup group, String instance) {         String propEmailGlobalEnabled = "simianarmy.chaos.notification.global.enabled";         String propEmailGroupEnabled = String.format("%s%s.%s.notification.enabled", NS, group.type(), group.name());          ChaosEmailNotifier notifier = context().chaosEmailNotifier();         if (notifier == null) {             String msg = "Chaos email notifier is not set.";             LOGGER.error(msg);             throw new RuntimeException(msg);         }         if (cfg.getBoolOrElse(propEmailGroupEnabled, false)) {             notifier.sendTerminationNotification(group, instance);         }         if (cfg.getBoolOrElse(propEmailGlobalEnabled, false)) {             notifier.sendTerminationGlobalNotification(group, instance);         }     }      /**      * {@inheritDoc}      */     @Override     public List<ChaosType> getChaosTypes() {         return Lists.newArrayList(enabledChaosTypes);     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> netflix : Folder]
						[NT -> simianarmy : Folder]
							[NT -> basic : Folder]
								[NT -> chaos : Folder]
									[NT -> BasicChaosMonkey.java.merge : .java.merge-File]
										[T -> BasicChaosMonkey.java : .java-Content "/*  *  *  Copyright 2012 Netflix, Inc.  *  *     Licensed under the Apache License, Version 2.0 (the "License");  *     you may not use this file except in compliance with the License.  *     You may obtain a copy of the License at  *  *         http://www.apache.org/licenses/LICENSE-2.0  *  *     Unless required by applicable law or agreed to in writing, software  *     distributed under the License is distributed on an "AS IS" BASIS,  *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *     See the License for the specific language governing permissions and  *     limitations under the License.  *  */ package com.netflix.simianarmy.basic.chaos;  import java.util.Calendar; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Random; import java.util.concurrent.TimeUnit;  import org.apache.commons.lang.Validate; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import com.google.common.collect.Lists; import com.netflix.simianarmy.CloudClient; import com.netflix.simianarmy.FeatureNotEnabledException; import com.netflix.simianarmy.InstanceGroupNotFoundException; import com.netflix.simianarmy.MonkeyCalendar; import com.netflix.simianarmy.MonkeyConfiguration; import com.netflix.simianarmy.MonkeyRecorder.Event; import com.netflix.simianarmy.NotFoundException; import com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup; import com.netflix.simianarmy.chaos.ChaosEmailNotifier; import com.netflix.simianarmy.chaos.ChaosMonkey; import com.netflix.simianarmy.chaos.ChaosType; import com.netflix.simianarmy.chaos.ShutdownInstanceChaosType;  /**  * The Class BasicChaosMonkey.  */ public class BasicChaosMonkey extends ChaosMonkey {      /** The Constant LOGGER. */     private static final Logger LOGGER = LoggerFactory.getLogger(BasicChaosMonkey.class);      /** The Constant NS. */     private static final String NS = "simianarmy.chaos.";      /** The cfg. */     private final MonkeyConfiguration cfg;      /** The runs per day. */     private final long runsPerDay;      /** The minimum value of the maxTerminationCountPerday property to be considered non-zero. **/     private static final double MIN_MAX_TERMINATION_COUNT_PER_DAY = 0.001;      private final MonkeyCalendar monkeyCalendar;      // When a mandatory termination is triggered due to the minimum termination limit is breached,     // the value below is used as the termination probability.     private static final double DEFAULT_MANDATORY_TERMINATION_PROBABILITY = 0.5;      private final List<ChaosType> enabledChaosTypes;      /**      * Instantiates a new basic chaos monkey.      * @param ctx      *            the ctx      */     public BasicChaosMonkey(ChaosMonkey.Context ctx) {         super(ctx);          this.cfg = ctx.configuration();         this.monkeyCalendar = ctx.calendar();          Calendar open = monkeyCalendar.now();         Calendar close = monkeyCalendar.now();         open.set(Calendar.HOUR, monkeyCalendar.openHour());         close.set(Calendar.HOUR, monkeyCalendar.closeHour());          enabledChaosTypes = Lists.newArrayList();         enabledChaosTypes.add(new ShutdownInstanceChaosType(cfg));          TimeUnit freqUnit = ctx.scheduler().frequencyUnit();         long units = freqUnit.convert(close.getTimeInMillis() - open.getTimeInMillis(), TimeUnit.MILLISECONDS);         runsPerDay = units / ctx.scheduler().frequency();     }      /** {@inheritDoc} */     @Override     public void doMonkeyBusiness() {         context().resetEventReport();         cfg.reload();         if (!isChaosMonkeyEnabled()) {             return;         }         for (InstanceGroup group : context().chaosCrawler().groups()) {             if (isGroupEnabled(group)) {                 if (isMaxTerminationCountExceeded(group)) {                     continue;                 }                 double prob = getEffectiveProbability(group);                 Collection<String> instances = context().chaosInstanceSelector().select(group, prob / runsPerDay);                 for (String inst : instances) {                     ChaosType chaosType = pickChaosType(context().cloudClient(), inst);                     if (chaosType == null) {                         // This is surprising ... normally we can always just terminate it                         LOGGER.warn("No chaos type was applicable to the instance: {}", inst);                         continue;                     }                     terminateInstance(group, inst, chaosType);                 }             }         }     }      private ChaosType pickChaosType(CloudClient cloudClient, String instanceId) {         Random random = new Random();          List<ChaosType> applicable = Lists.newArrayList();         for (ChaosType chaosType : enabledChaosTypes) {             if (chaosType.canApply(cloudClient, instanceId)) {                 applicable.add(chaosType);             }         }          if (applicable.isEmpty()) {             return null;         }          int index = random.nextInt(applicable.size());         return applicable.get(index);     }      @Override     public Event terminateNow(String type, String name, ChaosType chaosType)             throws FeatureNotEnabledException, InstanceGroupNotFoundException {         Validate.notNull(type);         Validate.notNull(name);         cfg.reload(name);         if (!isChaosMonkeyEnabled()) {             String msg = String.format("Chaos monkey is not enabled for group %s [type %s]",                     name, type);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }         String prop = NS + "terminateOndemand.enabled";         if (cfg.getBool(prop)) {             InstanceGroup group = findInstanceGroup(type, name);             if (group == null) {                 throw new InstanceGroupNotFoundException(type, name);             }             Collection<String> instances = context().chaosInstanceSelector().select(group, 1.0);             Validate.isTrue(instances.size() <= 1);             if (instances.size() == 1) {                 return terminateInstance(group, instances.iterator().next(), chaosType);             } else {                 throw new NotFoundException(String.format("No instance is found in group %s [type %s]",                         name, type));             }         } else {             String msg = String.format("Group %s [type %s] does not allow on-demand termination, set %s=true",                     name, type, prop);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }     }      private void reportEventForSummary(EventTypes eventType, InstanceGroup group, String instanceId) {         context().reportEvent(createEvent(eventType, group, instanceId));     }      /**      * Handle termination error. This has been abstracted so subclasses can decide to continue causing chaos if desired.      *      * @param instance      *            the instance      * @param e      *            the exception      */     protected void handleTerminationError(String instance, Throwable e) {         LOGGER.error("failed to terminate instance " + instance, e.getMessage());         throw new RuntimeException("failed to terminate instance " + instance, e);     }      /** {@inheritDoc} */     @Override     public Event recordTermination(InstanceGroup group, String instance, ChaosType chaosType) {         Event evt = context().recorder().newEvent(Type.CHAOS, EventTypes.CHAOS_TERMINATION, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         evt.addField("chaosType", chaosType.getKey());         context().recorder().recordEvent(evt);         return evt;     }      /** {@inheritDoc} */     @Override     public int getPreviousTerminationCount(InstanceGroup group, Date after) {         Map<String, String> query = new HashMap<String, String>();         query.put("groupType", group.type().name());         query.put("groupName", group.name());         List<Event> evts = context().recorder().findEvents(Type.CHAOS, EventTypes.CHAOS_TERMINATION, query, after);         return evts.size();     }      private Event createEvent(EventTypes chaosTermination, InstanceGroup group, String instance) {         Event evt = context().recorder().newEvent(Type.CHAOS, chaosTermination, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         return evt;     }      /**      * Gets the effective probability value, returns 0 if the group is not enabled. Otherwise calls      * getEffectiveProbability.      * @param group      * @return the effective probability value for the instance group      */     protected double getEffectiveProbability(InstanceGroup group) {         if (!isGroupEnabled(group)) {             return 0;         }         return getEffectiveProbabilityFromCfg(group);     }      /**      * Gets the effective probability value when the monkey processes an instance group, it uses the following      * logic in the order as listed below.      *      * 1) When minimum mandatory termination is enabled, a default non-zero probability is used for opted-in      * groups, if a) the application has been opted in for the last mandatory termination window      *        and b) there was no terminations in the last mandatory termination window      * 2) Use the probability configured for the group type and name      * 3) Use the probability configured for the group      * 4) Use 1.0      * @param group      * @return double      */     protected double getEffectiveProbabilityFromCfg(InstanceGroup group) {         String propName;         if (cfg.getBool(NS + "mandatoryTermination.enabled")) {             String mtwProp = NS + "mandatoryTermination.windowInDays";             int mandatoryTerminationWindowInDays = (int) cfg.getNumOrElse(mtwProp, 0);             if (mandatoryTerminationWindowInDays > 0                     && noTerminationInLastWindow(group, mandatoryTerminationWindowInDays)) {                 double mandatoryProb = cfg.getNumOrElse(NS + "mandatoryTermination.defaultProbability",                         DEFAULT_MANDATORY_TERMINATION_PROBABILITY);                 LOGGER.info("There has been no terminations for group {} [type {}] in the last {} days,"                         + "setting the probability to {} for mandatory termination.",                         new Object[]{group.name(), group.type(), mandatoryTerminationWindowInDays, mandatoryProb});                 return mandatoryProb;             }         }         propName = "probability";         String defaultProp = NS + group.type();         String probProp = NS + group.type() + "." + group.name() + "." + propName;         double prob = cfg.getNumOrElse(probProp, cfg.getNumOrElse(defaultProp + "." + propName, 1.0));         LOGGER.info("Group {} [type {}] enabled [prob {}]", new Object[]{group.name(), group.type(), prob});         return prob;     }      /**      * Returns lastOptInTimeInMilliseconds from the .properties file.      *      * @param group      * @return long      */     protected long getLastOptInMilliseconds(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".lastOptInTimeInMilliseconds";         long lastOptInTimeInMilliseconds = (long) cfg.getNumOrElse(prop, -1);         return lastOptInTimeInMilliseconds;     }      private boolean noTerminationInLastWindow(InstanceGroup group, int mandatoryTerminationWindowInDays) {     long lastOptInTimeInMilliseconds = getLastOptInMilliseconds(group);         if (lastOptInTimeInMilliseconds < 0) {             return false;         }          Calendar windowStart = monkeyCalendar.now();         windowStart.add(Calendar.DATE, -1 * mandatoryTerminationWindowInDays);          // return true if the window start is after the last opt-in time and         // there has been no termination since the window start         if (windowStart.getTimeInMillis() > lastOptInTimeInMilliseconds                 && getPreviousTerminationCount(group, windowStart.getTime()) <= 0) {             return true;         }          return false;     }      /**      * Checks to see if the given instance group is enabled.      * @param group      * @return boolean      */     protected boolean isGroupEnabled(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".enabled";         String defaultProp = NS + group.type() + ".enabled";         if (cfg.getBoolOrElse(prop, cfg.getBool(defaultProp))) {             return true;         } else {             LOGGER.info("Group {} [type {}] disabled, set {}=true or {}=true",                     new Object[]{group.name(), group.type(), prop, defaultProp});             return false;         }     }      private boolean isChaosMonkeyEnabled() {         String prop = NS + "enabled";         if (cfg.getBoolOrElse(prop, true)) {             return true;         }         LOGGER.info("ChaosMonkey disabled, set {}=true", prop);         return false;     }      private InstanceGroup findInstanceGroup(String type, String name) {         // Calling context().chaosCrawler().groups(name) causes a new crawl to get         // the up to date information for the group name.         for (InstanceGroup group : context().chaosCrawler().groups(name)) {             if (group.type().toString().equals(type) && group.name().equals(name)) {                 return group;             }         }         LOGGER.warn("Failed to find instance group for type {} and name {}", type, name);         return null;     }      private Event terminateInstance(InstanceGroup group, String inst, ChaosType chaosType) {         Validate.notNull(group);         Validate.notEmpty(inst);         String prop = NS + "leashed";         if (cfg.getBoolOrElse(prop, true)) {             LOGGER.info("leashed ChaosMonkey prevented from killing {} from group {} [{}], set {}=false",                     new Object[]{inst, group.name(), group.type(), prop});             reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);             return null;         } else {             try {                 Event evt = recordTermination(group, inst, chaosType);                 sendTerminationNotification(group, inst);                 chaosType.apply(context().cloudClient(), inst);                 LOGGER.info("Terminated {} from group {} [{}] with {}",                         new Object[]{inst, group.name(), group.type(), chaosType.getKey() });                 reportEventForSummary(EventTypes.CHAOS_TERMINATION, group, inst);                 return evt;             } catch (NotFoundException e) {                 LOGGER.warn("Failed to terminate " + inst + ", it does not exist. Perhaps it was already terminated");                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             } catch (Exception e) {                 handleTerminationError(inst, e);                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             }         }     }      /**      * Checks to see if the maximum termination window has been exceeded.      *      * @param group      * @return boolean      */     protected boolean isMaxTerminationCountExceeded(InstanceGroup group) {         Validate.notNull(group);         String propName = "maxTerminationsPerDay";         String defaultProp = String.format("%s%s.%s", NS, group.type(), propName);         String prop = String.format("%s%s.%s.%s", NS, group.type(), group.name(), propName);         double maxTerminationsPerDay = cfg.getNumOrElse(prop, cfg.getNumOrElse(defaultProp, 1.0));         if (maxTerminationsPerDay <= MIN_MAX_TERMINATION_COUNT_PER_DAY) {             LOGGER.info("ChaosMonkey is configured to not allow any killing from group {} [{}] "                     + "with max daily count set as {}", new Object[]{group.name(), group.type(), prop});             return true;         } else {             int daysBack = 1;             int maxCount = (int) maxTerminationsPerDay;             if (maxTerminationsPerDay < 1.0) {                 daysBack = (int) Math.ceil(1 / maxTerminationsPerDay);                 maxCount = 1;             }             Calendar after = monkeyCalendar.now();             after.add(Calendar.DATE, -1 * daysBack);             // Check if the group has exceeded the maximum terminations for the last period             int terminationCount = getPreviousTerminationCount(group, after.getTime());             if (terminationCount >= maxCount) {                 LOGGER.info("The count of terminations for group {} [{}] in the last {} days is {},"                         + " equal or greater than the max count threshold {}",                         new Object[]{group.name(), group.type(), daysBack, terminationCount, maxCount});                 return true;             }         }         return false;     }      @Override     public void sendTerminationNotification(InstanceGroup group, String instance) {         String propEmailGlobalEnabled = "simianarmy.chaos.notification.global.enabled";         String propEmailGroupEnabled = String.format("%s%s.%s.notification.enabled", NS, group.type(), group.name());          ChaosEmailNotifier notifier = context().chaosEmailNotifier();         if (notifier == null) {             String msg = "Chaos email notifier is not set.";             LOGGER.error(msg);             throw new RuntimeException(msg);         }         if (cfg.getBoolOrElse(propEmailGroupEnabled, false)) {             notifier.sendTerminationNotification(group, instance);         }         if (cfg.getBoolOrElse(propEmailGlobalEnabled, false)) {             notifier.sendTerminationGlobalNotification(group, instance);         }     }      /**      * {@inheritDoc}      */     @Override     public List<ChaosType> getChaosTypes() {         return Lists.newArrayList(enabledChaosTypes);     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> com : Folder]
					[NT -> netflix : Folder]
						[NT -> simianarmy : Folder]
							[NT -> basic : Folder]
								[NT -> chaos : Folder]
									[NT -> BasicChaosMonkey.java.merge : .java.merge-File]
										[T -> BasicChaosMonkey.java : .java-Content "/*  *  *  Copyright 2012 Netflix, Inc.  *  *     Licensed under the Apache License, Version 2.0 (the "License");  *     you may not use this file except in compliance with the License.  *     You may obtain a copy of the License at  *  *         http://www.apache.org/licenses/LICENSE-2.0  *  *     Unless required by applicable law or agreed to in writing, software  *     distributed under the License is distributed on an "AS IS" BASIS,  *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *     See the License for the specific language governing permissions and  *     limitations under the License.  *  */ package com.netflix.simianarmy.basic.chaos;  import java.util.Calendar; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Random; import java.util.concurrent.TimeUnit;  import org.apache.commons.lang.Validate; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import com.google.common.collect.Lists; import com.netflix.simianarmy.CloudClient; import com.netflix.simianarmy.FeatureNotEnabledException; import com.netflix.simianarmy.InstanceGroupNotFoundException; import com.netflix.simianarmy.MonkeyCalendar; import com.netflix.simianarmy.MonkeyConfiguration; import com.netflix.simianarmy.MonkeyRecorder.Event; import com.netflix.simianarmy.NotFoundException; import com.netflix.simianarmy.chaos.ChaosCrawler.InstanceGroup; import com.netflix.simianarmy.chaos.ChaosEmailNotifier; import com.netflix.simianarmy.chaos.ChaosMonkey; import com.netflix.simianarmy.chaos.ChaosType; import com.netflix.simianarmy.chaos.ShutdownInstanceChaosType;  /**  * The Class BasicChaosMonkey.  */ public class BasicChaosMonkey extends ChaosMonkey {      /** The Constant LOGGER. */     private static final Logger LOGGER = LoggerFactory.getLogger(BasicChaosMonkey.class);      /** The Constant NS. */     private static final String NS = "simianarmy.chaos.";      /** The cfg. */     private final MonkeyConfiguration cfg;      /** The runs per day. */     private final long runsPerDay;      /** The minimum value of the maxTerminationCountPerday property to be considered non-zero. **/     private static final double MIN_MAX_TERMINATION_COUNT_PER_DAY = 0.001;      private final MonkeyCalendar monkeyCalendar;      // When a mandatory termination is triggered due to the minimum termination limit is breached,     // the value below is used as the termination probability.     private static final double DEFAULT_MANDATORY_TERMINATION_PROBABILITY = 0.5;      private final List<ChaosType> allChaosTypes;      /**      * Instantiates a new basic chaos monkey.      * @param ctx      *            the ctx      */     public BasicChaosMonkey(ChaosMonkey.Context ctx) {         super(ctx);          this.cfg = ctx.configuration();         this.monkeyCalendar = ctx.calendar();          Calendar open = monkeyCalendar.now();         Calendar close = monkeyCalendar.now();         open.set(Calendar.HOUR, monkeyCalendar.openHour());         close.set(Calendar.HOUR, monkeyCalendar.closeHour());          allChaosTypes = Lists.newArrayList();         allChaosTypes.add(new ShutdownInstanceChaosType(cfg));          TimeUnit freqUnit = ctx.scheduler().frequencyUnit();         long units = freqUnit.convert(close.getTimeInMillis() - open.getTimeInMillis(), TimeUnit.MILLISECONDS);         runsPerDay = units / ctx.scheduler().frequency();     }      /** {@inheritDoc} */     @Override     public void doMonkeyBusiness() {         context().resetEventReport();         cfg.reload();         if (!isChaosMonkeyEnabled()) {             return;         }         for (InstanceGroup group : context().chaosCrawler().groups()) {             if (isGroupEnabled(group)) {                 if (isMaxTerminationCountExceeded(group)) {                     continue;                 }                 double prob = getEffectiveProbability(group);                 Collection<String> instances = context().chaosInstanceSelector().select(group, prob / runsPerDay);                 for (String inst : instances) {                     ChaosType chaosType = pickChaosType(context().cloudClient(), inst);                     if (chaosType == null) {                         // This is surprising ... normally we can always just terminate it                         LOGGER.warn("No chaos type was applicable to the instance: {}", inst);                         continue;                     }                     terminateInstance(group, inst, chaosType);                 }             }         }     }      private ChaosType pickChaosType(CloudClient cloudClient, String instanceId) {         Random random = new Random();          List<ChaosType> applicable = Lists.newArrayList();         for (ChaosType chaosType : allChaosTypes) {             if (chaosType.canApply(cloudClient, instanceId)) {                 applicable.add(chaosType);             }         }          if (applicable.isEmpty()) {             return null;         }          int index = random.nextInt(applicable.size());         return applicable.get(index);     }      @Override     public Event terminateNow(String type, String name, ChaosType chaosType)             throws FeatureNotEnabledException, InstanceGroupNotFoundException {         Validate.notNull(type);         Validate.notNull(name);         cfg.reload(name);         if (!isChaosMonkeyEnabled()) {             String msg = String.format("Chaos monkey is not enabled for group %s [type %s]",                     name, type);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }         String prop = NS + "terminateOndemand.enabled";         if (cfg.getBool(prop)) {             InstanceGroup group = findInstanceGroup(type, name);             if (group == null) {                 throw new InstanceGroupNotFoundException(type, name);             }             Collection<String> instances = context().chaosInstanceSelector().select(group, 1.0);             Validate.isTrue(instances.size() <= 1);             if (instances.size() == 1) {                 return terminateInstance(group, instances.iterator().next(), chaosType);             } else {                 throw new NotFoundException(String.format("No instance is found in group %s [type %s]",                         name, type));             }         } else {             String msg = String.format("Group %s [type %s] does not allow on-demand termination, set %s=true",                     name, type, prop);             LOGGER.info(msg);             throw new FeatureNotEnabledException(msg);         }     }      private void reportEventForSummary(EventTypes eventType, InstanceGroup group, String instanceId) {         context().reportEvent(createEvent(eventType, group, instanceId));     }      /**      * Handle termination error. This has been abstracted so subclasses can decide to continue causing chaos if desired.      *      * @param instance      *            the instance      * @param e      *            the exception      */     protected void handleTerminationError(String instance, Throwable e) {         LOGGER.error("failed to terminate instance " + instance, e.getMessage());         throw new RuntimeException("failed to terminate instance " + instance, e);     }      /** {@inheritDoc} */     @Override     public Event recordTermination(InstanceGroup group, String instance, ChaosType chaosType) {         Event evt = context().recorder().newEvent(Type.CHAOS, EventTypes.CHAOS_TERMINATION, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         evt.addField("chaosType", chaosType.getKey());         context().recorder().recordEvent(evt);         return evt;     }      /** {@inheritDoc} */     @Override     public int getPreviousTerminationCount(InstanceGroup group, Date after) {         Map<String, String> query = new HashMap<String, String>();         query.put("groupType", group.type().name());         query.put("groupName", group.name());         List<Event> evts = context().recorder().findEvents(Type.CHAOS, EventTypes.CHAOS_TERMINATION, query, after);         return evts.size();     }      private Event createEvent(EventTypes chaosTermination, InstanceGroup group, String instance) {         Event evt = context().recorder().newEvent(Type.CHAOS, chaosTermination, group.region(), instance);         evt.addField("groupType", group.type().name());         evt.addField("groupName", group.name());         return evt;     }      /**      * Gets the effective probability value, returns 0 if the group is not enabled. Otherwise calls      * getEffectiveProbability.      * @param group      * @return the effective probability value for the instance group      */     protected double getEffectiveProbability(InstanceGroup group) {         if (!isGroupEnabled(group)) {             return 0;         }         return getEffectiveProbabilityFromCfg(group);     }      /**      * Gets the effective probability value when the monkey processes an instance group, it uses the following      * logic in the order as listed below.      *      * 1) When minimum mandatory termination is enabled, a default non-zero probability is used for opted-in      * groups, if a) the application has been opted in for the last mandatory termination window      *        and b) there was no terminations in the last mandatory termination window      * 2) Use the probability configured for the group type and name      * 3) Use the probability configured for the group      * 4) Use 1.0      * @param group      * @return double      */     protected double getEffectiveProbabilityFromCfg(InstanceGroup group) {         String propName;         if (cfg.getBool(NS + "mandatoryTermination.enabled")) {             String mtwProp = NS + "mandatoryTermination.windowInDays";             int mandatoryTerminationWindowInDays = (int) cfg.getNumOrElse(mtwProp, 0);             if (mandatoryTerminationWindowInDays > 0                     && noTerminationInLastWindow(group, mandatoryTerminationWindowInDays)) {                 double mandatoryProb = cfg.getNumOrElse(NS + "mandatoryTermination.defaultProbability",                         DEFAULT_MANDATORY_TERMINATION_PROBABILITY);                 LOGGER.info("There has been no terminations for group {} [type {}] in the last {} days,"                         + "setting the probability to {} for mandatory termination.",                         new Object[]{group.name(), group.type(), mandatoryTerminationWindowInDays, mandatoryProb});                 return mandatoryProb;             }         }         propName = "probability";         String defaultProp = NS + group.type();         String probProp = NS + group.type() + "." + group.name() + "." + propName;         double prob = cfg.getNumOrElse(probProp, cfg.getNumOrElse(defaultProp + "." + propName, 1.0));         LOGGER.info("Group {} [type {}] enabled [prob {}]", new Object[]{group.name(), group.type(), prob});         return prob;     }      /**      * Returns lastOptInTimeInMilliseconds from the .properties file.      *      * @param group      * @return long      */     protected long getLastOptInMilliseconds(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".lastOptInTimeInMilliseconds";         long lastOptInTimeInMilliseconds = (long) cfg.getNumOrElse(prop, -1);         return lastOptInTimeInMilliseconds;     }      private boolean noTerminationInLastWindow(InstanceGroup group, int mandatoryTerminationWindowInDays) {     long lastOptInTimeInMilliseconds = getLastOptInMilliseconds(group);         if (lastOptInTimeInMilliseconds < 0) {             return false;         }          Calendar windowStart = monkeyCalendar.now();         windowStart.add(Calendar.DATE, -1 * mandatoryTerminationWindowInDays);          // return true if the window start is after the last opt-in time and         // there has been no termination since the window start         if (windowStart.getTimeInMillis() > lastOptInTimeInMilliseconds                 && getPreviousTerminationCount(group, windowStart.getTime()) <= 0) {             return true;         }          return false;     }      /**      * Checks to see if the given instance group is enabled.      * @param group      * @return boolean      */     protected boolean isGroupEnabled(InstanceGroup group) {         String prop = NS + group.type() + "." + group.name() + ".enabled";         String defaultProp = NS + group.type() + ".enabled";         if (cfg.getBoolOrElse(prop, cfg.getBool(defaultProp))) {             return true;         } else {             LOGGER.info("Group {} [type {}] disabled, set {}=true or {}=true",                     new Object[]{group.name(), group.type(), prop, defaultProp});             return false;         }     }      private boolean isChaosMonkeyEnabled() {         String prop = NS + "enabled";         if (cfg.getBoolOrElse(prop, true)) {             return true;         }         LOGGER.info("ChaosMonkey disabled, set {}=true", prop);         return false;     }      private InstanceGroup findInstanceGroup(String type, String name) {         // Calling context().chaosCrawler().groups(name) causes a new crawl to get         // the up to date information for the group name.         for (InstanceGroup group : context().chaosCrawler().groups(name)) {             if (group.type().toString().equals(type) && group.name().equals(name)) {                 return group;             }         }         LOGGER.warn("Failed to find instance group for type {} and name {}", type, name);         return null;     }      private Event terminateInstance(InstanceGroup group, String inst, ChaosType chaosType) {         Validate.notNull(group);         Validate.notEmpty(inst);         String prop = NS + "leashed";         if (cfg.getBoolOrElse(prop, true)) {             LOGGER.info("leashed ChaosMonkey prevented from killing {} from group {} [{}], set {}=false",                     new Object[]{inst, group.name(), group.type(), prop});             reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);             return null;         } else {             try {                 Event evt = recordTermination(group, inst, chaosType);                 sendTerminationNotification(group, inst);                 chaosType.apply(context().cloudClient(), inst);                 LOGGER.info("Terminated {} from group {} [{}] with {}",                         new Object[]{inst, group.name(), group.type(), chaosType.getKey() });                 reportEventForSummary(EventTypes.CHAOS_TERMINATION, group, inst);                 return evt;             } catch (NotFoundException e) {                 LOGGER.warn("Failed to terminate " + inst + ", it does not exist. Perhaps it was already terminated");                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             } catch (Exception e) {                 handleTerminationError(inst, e);                 reportEventForSummary(EventTypes.CHAOS_TERMINATION_SKIPPED, group, inst);                 return null;             }         }     }      /**      * Checks to see if the maximum termination window has been exceeded.      *      * @param group      * @return boolean      */     protected boolean isMaxTerminationCountExceeded(InstanceGroup group) {         Validate.notNull(group);         String propName = "maxTerminationsPerDay";         String defaultProp = String.format("%s%s.%s", NS, group.type(), propName);         String prop = String.format("%s%s.%s.%s", NS, group.type(), group.name(), propName);         double maxTerminationsPerDay = cfg.getNumOrElse(prop, cfg.getNumOrElse(defaultProp, 1.0));         if (maxTerminationsPerDay <= MIN_MAX_TERMINATION_COUNT_PER_DAY) {             LOGGER.info("ChaosMonkey is configured to not allow any killing from group {} [{}] "                     + "with max daily count set as {}", new Object[]{group.name(), group.type(), prop});             return true;         } else {             int daysBack = 1;             int maxCount = (int) maxTerminationsPerDay;             if (maxTerminationsPerDay < 1.0) {                 daysBack = (int) Math.ceil(1 / maxTerminationsPerDay);                 maxCount = 1;             }             Calendar after = monkeyCalendar.now();             after.add(Calendar.DATE, -1 * daysBack);             // Check if the group has exceeded the maximum terminations for the last period             int terminationCount = getPreviousTerminationCount(group, after.getTime());             if (terminationCount >= maxCount) {                 LOGGER.info("The count of terminations for group {} [{}] in the last {} days is {},"                         + " equal or greater than the max count threshold {}",                         new Object[]{group.name(), group.type(), daysBack, terminationCount, maxCount});                 return true;             }         }         return false;     }      @Override     public void sendTerminationNotification(InstanceGroup group, String instance) {         String propEmailGlobalEnabled = "simianarmy.chaos.notification.global.enabled";         String propEmailGroupEnabled = String.format("%s%s.%s.notification.enabled", NS, group.type(), group.name());          ChaosEmailNotifier notifier = context().chaosEmailNotifier();         if (notifier == null) {             String msg = "Chaos email notifier is not set.";             LOGGER.error(msg);             throw new RuntimeException(msg);         }         if (cfg.getBoolOrElse(propEmailGroupEnabled, false)) {             notifier.sendTerminationNotification(group, instance);         }         if (cfg.getBoolOrElse(propEmailGlobalEnabled, false)) {             notifier.sendTerminationGlobalNotification(group, instance);         }     }      /**      * {@inheritDoc}      */     @Override     public List<ChaosType> getChaosTypes() {         return Lists.newArrayList(allChaosTypes);     } } " compose:StringConcatenation merge: LineBased]
