Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/retrofit/src/main/java/retrofit/http/RequestBuilder.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/retrofit/src/main/java/retrofit/http/RequestBuilder.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/retrofit/src/main/java/retrofit/http/RequestBuilder.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/retrofit/src/main/java/retrofit/http/RequestBuilder.java
[NT -> left : Feature]
	[NT -> retrofit : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> retrofit : Folder]
						[NT -> http : Folder]
							[NT -> RequestBuilder.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package retrofit.http;" compose:Replacement merge: Default]
									[T -> java.io.UnsupportedEncodingException{ImportPackage} : ImportDeclaration "import java.io.UnsupportedEncodingException;" compose:Replacement merge: Default]
									[T -> java.net.URLEncoder{ImportPackage} : ImportDeclaration "import java.net.URLEncoder;" compose:Replacement merge: Default]
									[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
									[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
									[T -> retrofit.http.client.Header{ImportPackage} : ImportDeclaration "import retrofit.http.client.Header;" compose:Replacement merge: Default]
									[T -> retrofit.http.client.Request{ImportPackage} : ImportDeclaration "import retrofit.http.client.Request;" compose:Replacement merge: Default]
									[T -> retrofit.http.mime.FormUrlEncodedTypedOutput{ImportPackage} : ImportDeclaration "import retrofit.http.mime.FormUrlEncodedTypedOutput;" compose:Replacement merge: Default]
									[T -> retrofit.http.mime.MultipartTypedOutput{ImportPackage} : ImportDeclaration "import retrofit.http.mime.MultipartTypedOutput;" compose:Replacement merge: Default]
									[T -> retrofit.http.mime.TypedOutput{ImportPackage} : ImportDeclaration "import retrofit.http.mime.TypedOutput;" compose:Replacement merge: Default]
									[T -> retrofit.http.RestMethodInfo.NO_BODY{ImportPackage} : ImportDeclaration "import static retrofit.http.RestMethodInfo.NO_BODY;" compose:Replacement merge: Default]
									[NT -> RequestBuilder : ClassDeclaration]
										[T -> - : Modifiers "final" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> RequestBuilder : Id "RequestBuilder" compose:Replacement merge: Default]
										[T -> converter : FieldDecl "private final Converter converter;" compose:Replacement merge: SemanticConflict]
										[T -> methodInfo : FieldDecl "private RestMethodInfo methodInfo;" compose:Replacement merge: SemanticConflict]
										[T -> args : FieldDecl "private Object[] args;" compose:Replacement merge: SemanticConflict]
										[T -> apiUrl : FieldDecl "private String apiUrl;" compose:Replacement merge: SemanticConflict]
										[T -> headers : FieldDecl "private List<retrofit.http.client.Header> headers;" compose:Replacement merge: SemanticConflict]
										[T -> RequestBuilder(Converter-Converter) : ConstructorDecl "RequestBuilder(Converter converter) {     this.converter = converter;   }" compose:Replacement merge: LineBased]
										[T -> methodInfo(RestMethodInfo-RestMethodInfo) : MethodDecl "RequestBuilder methodInfo(RestMethodInfo methodDetails) {     this.methodInfo = methodDetails;     return this;   }" compose:Replacement merge: LineBased]
										[T -> apiUrl(String-String) : MethodDecl "RequestBuilder apiUrl(String apiUrl) {     this.apiUrl = apiUrl;     return this;   }" compose:Replacement merge: LineBased]
										[T -> args(Object[]-Object[]) : MethodDecl "RequestBuilder args(Object[] args) {     this.args = args;     return this;   }" compose:Replacement merge: LineBased]
										[T -> headers(List<retrofit.http.client.Header>-List<retrofit.http.client.Header>) : MethodDecl "RequestBuilder headers(List<retrofit.http.client.Header> headers) {     this.headers = headers;     return this;   }" compose:Replacement merge: LineBased]
										[T -> build({FormalParametersInternal}) : MethodDecl "Request build() throws UnsupportedEncodingException {     String apiUrl = this.apiUrl;      StringBuilder url = new StringBuilder(apiUrl);     if (apiUrl.endsWith("/")) {       // We require relative paths to start with '/'. Prevent a double-slash.       url.deleteCharAt(url.length() - 1);     }      // Append the method relative URL.     url.append(buildRelativeUrl());      // Append query parameters, if needed.     if (methodInfo.hasQueryParams) {       boolean first = true;       String requestQuery = methodInfo.requestQuery;       if (requestQuery != null) {         url.append(requestQuery);         first = false;       }       String[] requestQueryName = methodInfo.requestQueryName;       for (int i = 0; i < requestQueryName.length; i++) {         String query = requestQueryName[i];         if (query != null) {           String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");           url.append(first ? '?' : '&').append(query).append('=').append(value);           first = false;         }       }     }      List<retrofit.http.client.Header> headers = new ArrayList<retrofit.http.client.Header>();     if (this.headers != null) {       headers.addAll(this.headers);     }     List<Header> methodHeaders = methodInfo.headers;     if (methodHeaders != null) {       headers.addAll(methodHeaders);     }     // RFC 2616: Header names are case-insensitive.     String[] requestParamHeader = methodInfo.requestParamHeader;     if (requestParamHeader != null) {       for (int i = 0; i < requestParamHeader.length; i++) {         String name = requestParamHeader[i];         if (name == null) continue;         Object arg = args[i];         if (arg != null) {           headers.add(new retrofit.http.client.Header(name, String.valueOf(arg)));         }       }     }      return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());   }" compose:Replacement merge: LineBased]
										[T -> buildRelativeUrl({FormalParametersInternal}) : MethodDecl "private String buildRelativeUrl() throws UnsupportedEncodingException {     String replacedPath = methodInfo.requestUrl;     String[] requestUrlParam = methodInfo.requestUrlParam;     for (int i = 0; i < requestUrlParam.length; i++) {       String param = requestUrlParam[i];       if (param != null) {         String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");         replacedPath = replacedPath.replace("{" + param + "}", value);       }     }     return replacedPath;   }" compose:Replacement merge: LineBased]
										[T -> buildBody({FormalParametersInternal}) : MethodDecl "private TypedOutput buildBody() {     switch (methodInfo.requestType) {       case SIMPLE: {         int bodyIndex = methodInfo.bodyIndex;         if (bodyIndex == NO_BODY) {           return null;         }         Object body = args[bodyIndex];         if (body instanceof TypedOutput) {           return (TypedOutput) body;         } else {           return converter.toBody(body);         }       }        case FORM_URL_ENCODED: {         FormUrlEncodedTypedOutput body = new FormUrlEncodedTypedOutput();         String[] requestFormPair = methodInfo.requestFormPair;         for (int i = 0; i < requestFormPair.length; i++) {           String name = requestFormPair[i];           if (name != null) {             body.addField(name, String.valueOf(args[i]));           }         }         return body;       }        case MULTIPART: {         MultipartTypedOutput body = new MultipartTypedOutput();         String[] requestMultipartPart = methodInfo.requestMultipartPart;         for (int i = 0; i < requestMultipartPart.length; i++) {           String name = requestMultipartPart[i];           if (name != null) {             Object value = args[i];             if (value instanceof TypedOutput) {               body.addPart(name, (TypedOutput) value);             } else {               body.addPart(name, converter.toBody(value));             }           }         }         return body;       }        default:         throw new IllegalArgumentException("Unknown request type " + methodInfo.requestType);     }   }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> retrofit : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> retrofit : Folder]
						[NT -> http : Folder]
							[NT -> RequestBuilder.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package retrofit.http;" compose:Replacement merge: Default]
									[T -> java.io.UnsupportedEncodingException{ImportPackage} : ImportDeclaration "import java.io.UnsupportedEncodingException;" compose:Replacement merge: Default]
									[T -> java.net.URLEncoder{ImportPackage} : ImportDeclaration "import java.net.URLEncoder;" compose:Replacement merge: Default]
									[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
									[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
									[T -> retrofit.http.client.Header{ImportPackage} : ImportDeclaration "import retrofit.http.client.Header;" compose:Replacement merge: Default]
									[T -> retrofit.http.client.Request{ImportPackage} : ImportDeclaration "import retrofit.http.client.Request;" compose:Replacement merge: Default]
									[T -> retrofit.http.mime.FormUrlEncodedTypedOutput{ImportPackage} : ImportDeclaration "import retrofit.http.mime.FormUrlEncodedTypedOutput;" compose:Replacement merge: Default]
									[T -> retrofit.http.mime.MultipartTypedOutput{ImportPackage} : ImportDeclaration "import retrofit.http.mime.MultipartTypedOutput;" compose:Replacement merge: Default]
									[T -> retrofit.http.mime.TypedOutput{ImportPackage} : ImportDeclaration "import retrofit.http.mime.TypedOutput;" compose:Replacement merge: Default]
									[T -> retrofit.http.RestMethodInfo.NO_BODY{ImportPackage} : ImportDeclaration "import static retrofit.http.RestMethodInfo.NO_BODY;" compose:Replacement merge: Default]
									[NT -> RequestBuilder : ClassDeclaration]
										[T -> - : Modifiers "final" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> RequestBuilder : Id "RequestBuilder" compose:Replacement merge: Default]
										[T -> converter : FieldDecl "private final Converter converter;" compose:Replacement merge: SemanticConflict]
										[T -> methodInfo : FieldDecl "private RestMethodInfo methodInfo;" compose:Replacement merge: SemanticConflict]
										[T -> args : FieldDecl "private Object[] args;" compose:Replacement merge: SemanticConflict]
										[T -> apiUrl : FieldDecl "private String apiUrl;" compose:Replacement merge: SemanticConflict]
										[T -> headers : FieldDecl "private List<retrofit.http.client.Header> headers;" compose:Replacement merge: SemanticConflict]
										[T -> RequestBuilder(Converter-Converter) : ConstructorDecl "RequestBuilder(Converter converter) {     this.converter = converter;   }" compose:Replacement merge: LineBased]
										[T -> methodInfo(RestMethodInfo-RestMethodInfo) : MethodDecl "RequestBuilder methodInfo(RestMethodInfo methodDetails) {     this.methodInfo = methodDetails;     return this;   }" compose:Replacement merge: LineBased]
										[T -> apiUrl(String-String) : MethodDecl "RequestBuilder apiUrl(String apiUrl) {     this.apiUrl = apiUrl;     return this;   }" compose:Replacement merge: LineBased]
										[T -> args(Object[]-Object[]) : MethodDecl "RequestBuilder args(Object[] args) {     this.args = args;     return this;   }" compose:Replacement merge: LineBased]
										[T -> headers(List<retrofit.http.client.Header>-List<retrofit.http.client.Header>) : MethodDecl "RequestBuilder headers(List<retrofit.http.client.Header> headers) {     this.headers = headers;     return this;   }" compose:Replacement merge: LineBased]
										[T -> build({FormalParametersInternal}) : MethodDecl "Request build() throws UnsupportedEncodingException {     String apiUrl = this.apiUrl;      StringBuilder url = new StringBuilder(apiUrl);     if (apiUrl.endsWith("/")) {       // We require relative paths to start with '/'. Prevent a double-slash.       url.deleteCharAt(url.length() - 1);     }      // Append the method relative URL.     url.append(buildRelativeUrl());      // Append query parameters, if needed.     if (methodInfo.hasQueryParams) {       boolean first = true;       String requestQuery = methodInfo.requestQuery;       if (requestQuery != null) {         url.append(requestQuery);         first = false;       }       String[] requestQueryName = methodInfo.requestQueryName;       for (int i = 0; i < requestQueryName.length; i++) {         String query = requestQueryName[i];         if (query != null) {           String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");           url.append(first ? '?' : '&').append(query).append('=').append(value);           first = false;         }       }     }      List<retrofit.http.client.Header> headers = new ArrayList<retrofit.http.client.Header>();     if (this.headers != null) {       headers.addAll(this.headers);     }     List<Header> methodHeaders = methodInfo.headers;     if (methodHeaders != null) {       headers.addAll(methodHeaders);     }     // RFC 2616: Header names are case-insensitive.     String[] requestParamHeader = methodInfo.requestParamHeader;     if (requestParamHeader != null) {       for (int i = 0; i < requestParamHeader.length; i++) {         String name = requestParamHeader[i];         if (name == null) continue;         Object arg = args[i];         if (arg != null) {           headers.add(new retrofit.http.client.Header(name, String.valueOf(arg)));         }       }     }      return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());   }" compose:Replacement merge: LineBased]
										[T -> buildRelativeUrl({FormalParametersInternal}) : MethodDecl "private String buildRelativeUrl() throws UnsupportedEncodingException {     String replacedPath = methodInfo.requestUrl;     String[] requestUrlParam = methodInfo.requestUrlParam;     for (int i = 0; i < requestUrlParam.length; i++) {       String param = requestUrlParam[i];       if (param != null) {         String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");         replacedPath = replacedPath.replace("{" + param + "}", value);       }     }     return replacedPath;   }" compose:Replacement merge: LineBased]
										[T -> buildBody({FormalParametersInternal}) : MethodDecl "private TypedOutput buildBody() {     switch (methodInfo.requestType) {       case SIMPLE: {         int bodyIndex = methodInfo.bodyIndex;         if (bodyIndex == NO_BODY) {           return null;         }         Object body = args[bodyIndex];         if (body instanceof TypedOutput) {           return (TypedOutput) body;         } else {           return converter.toBody(body);         }       }        case FORM_URL_ENCODED: {         FormUrlEncodedTypedOutput body = new FormUrlEncodedTypedOutput();         String[] requestFormPair = methodInfo.requestFormPair;         for (int i = 0; i < requestFormPair.length; i++) {           String name = requestFormPair[i];           if (name != null) {             body.addPair(name, String.valueOf(args[i]));           }         }         return body;       }        case MULTIPART: {         MultipartTypedOutput body = new MultipartTypedOutput();         String[] requestMultipartPart = methodInfo.requestMultipartPart;         for (int i = 0; i < requestMultipartPart.length; i++) {           String name = requestMultipartPart[i];           if (name != null) {             Object value = args[i];             if (value instanceof TypedOutput) {               body.addPart(name, (TypedOutput) value);             } else {               body.addPart(name, converter.toBody(value));             }           }         }         return body;       }        default:         throw new IllegalArgumentException("Unknown request type " + methodInfo.requestType);     }   }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> retrofit : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> retrofit : Folder]
						[NT -> http : Folder]
							[NT -> RequestBuilder.java.merge : .java.merge-File]
								[T -> RequestBuilder.java : .java-Content "/*  * Copyright (C) 2012 Square, Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package retrofit.http;  import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.ArrayList; import java.util.List; import retrofit.http.client.Header; import retrofit.http.client.Request; import retrofit.http.mime.FormUrlEncodedTypedOutput; import retrofit.http.mime.MultipartTypedOutput; import retrofit.http.mime.TypedOutput;  import static retrofit.http.RestMethodInfo.NO_BODY;  /** Builds HTTP requests from Java method invocations. */ final class RequestBuilder {   private final Converter converter;    private RestMethodInfo methodInfo;   private Object[] args;   private String apiUrl;   private List<retrofit.http.client.Header> headers;    RequestBuilder(Converter converter) {     this.converter = converter;   }    /** Supply cached method metadata info. */   RequestBuilder methodInfo(RestMethodInfo methodDetails) {     this.methodInfo = methodDetails;     return this;   }    /** Base API url. */   RequestBuilder apiUrl(String apiUrl) {     this.apiUrl = apiUrl;     return this;   }    /** Arguments from method invocation. */   RequestBuilder args(Object[] args) {     this.args = args;     return this;   }    /** A list of custom headers. */   RequestBuilder headers(List<retrofit.http.client.Header> headers) {     this.headers = headers;     return this;   }    /**    * Construct a {@link Request} from the supplied information. You <strong>must</strong> call    * {@link #methodInfo}, {@link #apiUrl}, {@link #args}, and {@link #headers} before invoking this    * method.    */   Request build() throws UnsupportedEncodingException {     String apiUrl = this.apiUrl;      StringBuilder url = new StringBuilder(apiUrl);     if (apiUrl.endsWith("/")) {       // We require relative paths to start with '/'. Prevent a double-slash.       url.deleteCharAt(url.length() - 1);     }      // Append the method relative URL.     url.append(buildRelativeUrl());      // Append query parameters, if needed.     if (methodInfo.hasQueryParams) {       boolean first = true;       String requestQuery = methodInfo.requestQuery;       if (requestQuery != null) {         url.append(requestQuery);         first = false;       }       String[] requestQueryName = methodInfo.requestQueryName;       for (int i = 0; i < requestQueryName.length; i++) {         String query = requestQueryName[i];         if (query != null) {           String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");           url.append(first ? '?' : '&').append(query).append('=').append(value);           first = false;         }       }     }      List<retrofit.http.client.Header> headers = new ArrayList<retrofit.http.client.Header>();     if (this.headers != null) {       headers.addAll(this.headers);     }     List<Header> methodHeaders = methodInfo.headers;     if (methodHeaders != null) {       headers.addAll(methodHeaders);     }     // RFC 2616: Header names are case-insensitive.     String[] requestParamHeader = methodInfo.requestParamHeader;     if (requestParamHeader != null) {       for (int i = 0; i < requestParamHeader.length; i++) {         String name = requestParamHeader[i];         if (name == null) continue;         Object arg = args[i];         if (arg != null) {           headers.add(new retrofit.http.client.Header(name, String.valueOf(arg)));         }       }     }      return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());   }    /** Create the final relative URL by performing parameter replacement. */   private String buildRelativeUrl() throws UnsupportedEncodingException {     String replacedPath = methodInfo.requestUrl;     String[] requestUrlParam = methodInfo.requestUrlParam;     for (int i = 0; i < requestUrlParam.length; i++) {       String param = requestUrlParam[i];       if (param != null) {         String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");         replacedPath = replacedPath.replace("{" + param + "}", value);       }     }     return replacedPath;   }    /** Create the request body using the method info and invocation arguments. */   private TypedOutput buildBody() {     switch (methodInfo.requestType) {       case SIMPLE: {         int bodyIndex = methodInfo.bodyIndex;         if (bodyIndex == NO_BODY) {           return null;         }         Object body = args[bodyIndex];         if (body instanceof TypedOutput) {           return (TypedOutput) body;         } else {           return converter.toBody(body);         }       }        case FORM_URL_ENCODED: {         FormUrlEncodedTypedOutput body = new FormUrlEncodedTypedOutput();         String[] requestFormPair = methodInfo.requestFormPair;         for (int i = 0; i < requestFormPair.length; i++) {           String name = requestFormPair[i];           if (name != null) {             body.addField(name, String.valueOf(args[i]));           }         }         return body;       }        case MULTIPART: {         MultipartTypedOutput body = new MultipartTypedOutput();         String[] requestMultipartPart = methodInfo.requestMultipartPart;         for (int i = 0; i < requestMultipartPart.length; i++) {           String name = requestMultipartPart[i];           if (name != null) {             Object value = args[i];             if (value instanceof TypedOutput) {               body.addPart(name, (TypedOutput) value);             } else {               body.addPart(name, converter.toBody(value));             }           }         }         return body;       }        default:         throw new IllegalArgumentException("Unknown request type " + methodInfo.requestType);     }   } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> retrofit : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> retrofit : Folder]
						[NT -> http : Folder]
							[NT -> RequestBuilder.java.merge : .java.merge-File]
								[T -> RequestBuilder.java : .java-Content "/*  * Copyright (C) 2012 Square, Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package retrofit.http;  import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.ArrayList; import java.util.List; import retrofit.http.client.Header; import retrofit.http.client.Request; import retrofit.http.mime.FormUrlEncodedTypedOutput; import retrofit.http.mime.MultipartTypedOutput; import retrofit.http.mime.TypedOutput;  import static retrofit.http.RestMethodInfo.NO_BODY;  /** Builds HTTP requests from Java method invocations. */ final class RequestBuilder {   private final Converter converter;    private RestMethodInfo methodInfo;   private Object[] args;   private String apiUrl;   private List<retrofit.http.client.Header> headers;    RequestBuilder(Converter converter) {     this.converter = converter;   }    /** Supply cached method metadata info. */   RequestBuilder methodInfo(RestMethodInfo methodDetails) {     this.methodInfo = methodDetails;     return this;   }    /** Base API url. */   RequestBuilder apiUrl(String apiUrl) {     this.apiUrl = apiUrl;     return this;   }    /** Arguments from method invocation. */   RequestBuilder args(Object[] args) {     this.args = args;     return this;   }    /** A list of custom headers. */   RequestBuilder headers(List<retrofit.http.client.Header> headers) {     this.headers = headers;     return this;   }    /**    * Construct a {@link Request} from the supplied information. You <strong>must</strong> call    * {@link #methodInfo}, {@link #apiUrl}, {@link #args}, and {@link #headers} before invoking this    * method.    */   Request build() throws UnsupportedEncodingException {     String apiUrl = this.apiUrl;      StringBuilder url = new StringBuilder(apiUrl);     if (apiUrl.endsWith("/")) {       // We require relative paths to start with '/'. Prevent a double-slash.       url.deleteCharAt(url.length() - 1);     }      // Append the method relative URL.     url.append(buildRelativeUrl());      // Append query parameters, if needed.     if (methodInfo.hasQueryParams) {       boolean first = true;       String requestQuery = methodInfo.requestQuery;       if (requestQuery != null) {         url.append(requestQuery);         first = false;       }       String[] requestQueryName = methodInfo.requestQueryName;       for (int i = 0; i < requestQueryName.length; i++) {         String query = requestQueryName[i];         if (query != null) {           String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");           url.append(first ? '?' : '&').append(query).append('=').append(value);           first = false;         }       }     }      List<retrofit.http.client.Header> headers = new ArrayList<retrofit.http.client.Header>();     if (this.headers != null) {       headers.addAll(this.headers);     }     List<Header> methodHeaders = methodInfo.headers;     if (methodHeaders != null) {       headers.addAll(methodHeaders);     }     // RFC 2616: Header names are case-insensitive.     String[] requestParamHeader = methodInfo.requestParamHeader;     if (requestParamHeader != null) {       for (int i = 0; i < requestParamHeader.length; i++) {         String name = requestParamHeader[i];         if (name == null) continue;         Object arg = args[i];         if (arg != null) {           headers.add(new retrofit.http.client.Header(name, String.valueOf(arg)));         }       }     }      return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());   }    /** Create the final relative URL by performing parameter replacement. */   private String buildRelativeUrl() throws UnsupportedEncodingException {     String replacedPath = methodInfo.requestUrl;     String[] requestUrlParam = methodInfo.requestUrlParam;     for (int i = 0; i < requestUrlParam.length; i++) {       String param = requestUrlParam[i];       if (param != null) {         String value = URLEncoder.encode(String.valueOf(args[i]), "UTF-8");         replacedPath = replacedPath.replace("{" + param + "}", value);       }     }     return replacedPath;   }    /** Create the request body using the method info and invocation arguments. */   private TypedOutput buildBody() {     switch (methodInfo.requestType) {       case SIMPLE: {         int bodyIndex = methodInfo.bodyIndex;         if (bodyIndex == NO_BODY) {           return null;         }         Object body = args[bodyIndex];         if (body instanceof TypedOutput) {           return (TypedOutput) body;         } else {           return converter.toBody(body);         }       }        case FORM_URL_ENCODED: {         FormUrlEncodedTypedOutput body = new FormUrlEncodedTypedOutput();         String[] requestFormPair = methodInfo.requestFormPair;         for (int i = 0; i < requestFormPair.length; i++) {           String name = requestFormPair[i];           if (name != null) {             body.addPair(name, String.valueOf(args[i]));           }         }         return body;       }        case MULTIPART: {         MultipartTypedOutput body = new MultipartTypedOutput();         String[] requestMultipartPart = methodInfo.requestMultipartPart;         for (int i = 0; i < requestMultipartPart.length; i++) {           String name = requestMultipartPart[i];           if (name != null) {             Object value = args[i];             if (value instanceof TypedOutput) {               body.addPart(name, (TypedOutput) value);             } else {               body.addPart(name, converter.toBody(value));             }           }         }         return body;       }        default:         throw new IllegalArgumentException("Unknown request type " + methodInfo.requestType);     }   } } " compose:StringConcatenation merge: LineBased]
