Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/processor/src/main/java/com/bluelinelabs/logansquare/processor/type/field/TypeConverterFieldType.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/processor/src/main/java/com/bluelinelabs/logansquare/processor/type/field/TypeConverterFieldType.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/processor/src/main/java/com/bluelinelabs/logansquare/processor/type/field/TypeConverterFieldType.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/processor/src/main/java/com/bluelinelabs/logansquare/processor/type/field/TypeConverterFieldType.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/processor/src/main/java/com/bluelinelabs/logansquare/processor/type/field/TypeConverterFieldType.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/processor/src/main/java/com/bluelinelabs/logansquare/processor/type/field/TypeConverterFieldType.java
[NT -> left : Feature]
	[NT -> processor : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> bluelinelabs : Folder]
							[NT -> logansquare : Folder]
								[NT -> processor : Folder]
									[NT -> type : Folder]
										[NT -> field : Folder]
											[NT -> TypeConverterFieldType.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package com.bluelinelabs.logansquare.processor.type.field;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.TextUtils{ImportPackage} : ImportDeclaration "import com.bluelinelabs.logansquare.processor.TextUtils;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.ClassName{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.ClassName;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.MethodSpec.Builder{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.MethodSpec.Builder;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.TypeName{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.TypeName;" compose:Replacement merge: Default]
													[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME{ImportPackage} : ImportDeclaration "import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME{ImportPackage} : ImportDeclaration "import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME;" compose:Replacement merge: Default]
													[NT -> TypeConverterFieldType : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> TypeConverterFieldType : Id "TypeConverterFieldType" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends FieldType" compose:Replacement merge: Default]
														[T -> mTypeName : FieldDecl "private TypeName mTypeName;" compose:Replacement merge: SemanticConflict]
														[T -> mTypeConverter : FieldDecl "private ClassName mTypeConverter;" compose:Replacement merge: SemanticConflict]
														[T -> TypeConverterFieldType(TypeName-TypeName-ClassName-ClassName) : ConstructorDecl "public TypeConverterFieldType(TypeName typeName, ClassName typeConverterClassName) {         mTypeName = typeName;         mTypeConverter = typeConverterClassName;     }" compose:Replacement merge: LineBased]
														[T -> getTypeName({FormalParametersInternal}) : MethodDecl "@Override     public TypeName getTypeName() {         return mTypeName;     }" compose:Replacement merge: LineBased]
														[T -> getNonPrimitiveTypeName({FormalParametersInternal}) : MethodDecl "@Override     public TypeName getNonPrimitiveTypeName() {         return mTypeName;     }" compose:Replacement merge: LineBased]
														[T -> getTypeConverterClassName({FormalParametersInternal}) : MethodDecl "public ClassName getTypeConverterClassName() {         return mTypeConverter;     }" compose:Replacement merge: LineBased]
														[T -> parse(Builder-Builder-int-int-String-String-Object-Object) : MethodDecl "@Override     public void parse(Builder builder, int depth, String setter, Object... setterFormatArgs) {         setter = replaceLastLiteral(setter, "$L.parse($L)");         builder.addStatement(setter, expandStringArgs(setterFormatArgs, TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), JSON_PARSER_VARIABLE_NAME));     }" compose:Replacement merge: LineBased]
														[T -> serialize(Builder-Builder-int-int-String-String-List<String>-List<String>-String-String-boolean-boolean-boolean-boolean-boolean-boolean-boolean-boolean) : MethodDecl "@Override     public void serialize(Builder builder, int depth, String fieldName, List<String> processedFieldNames, String getter, boolean isObjectProperty, boolean checkIfNull, boolean writeIfNull, boolean writeCollectionElementIfNull) {         builder.addStatement("$L.serialize($L, $S, $L, $L)", TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), getter, fieldName, isObjectProperty, JSON_GENERATOR_VARIABLE_NAME);     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> processor : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> bluelinelabs : Folder]
							[NT -> logansquare : Folder]
								[NT -> processor : Folder]
									[NT -> type : Folder]
										[NT -> field : Folder]
											[NT -> TypeConverterFieldType.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package com.bluelinelabs.logansquare.processor.type.field;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.TextUtils{ImportPackage} : ImportDeclaration "import com.bluelinelabs.logansquare.processor.TextUtils;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.ClassName{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.ClassName;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.MethodSpec.Builder{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.MethodSpec.Builder;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.TypeName{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.TypeName;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME{ImportPackage} : ImportDeclaration "import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME{ImportPackage} : ImportDeclaration "import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME;" compose:Replacement merge: Default]
													[NT -> TypeConverterFieldType : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> TypeConverterFieldType : Id "TypeConverterFieldType" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends FieldType" compose:Replacement merge: Default]
														[T -> mTypeName : FieldDecl "private TypeName mTypeName;" compose:Replacement merge: SemanticConflict]
														[T -> mTypeConverter : FieldDecl "private ClassName mTypeConverter;" compose:Replacement merge: SemanticConflict]
														[T -> TypeConverterFieldType(TypeName-TypeName-ClassName-ClassName) : ConstructorDecl "public TypeConverterFieldType(TypeName typeName, ClassName typeConverterClassName) {         mTypeName = typeName;         mTypeConverter = typeConverterClassName;     }" compose:Replacement merge: LineBased]
														[T -> getTypeName({FormalParametersInternal}) : MethodDecl "@Override     public TypeName getTypeName() {         return mTypeName;     }" compose:Replacement merge: LineBased]
														[T -> getNonPrimitiveTypeName({FormalParametersInternal}) : MethodDecl "@Override     public TypeName getNonPrimitiveTypeName() {         return mTypeName;     }" compose:Replacement merge: LineBased]
														[T -> getTypeConverterClassName({FormalParametersInternal}) : MethodDecl "public ClassName getTypeConverterClassName() {         return mTypeConverter;     }" compose:Replacement merge: LineBased]
														[T -> parse(Builder-Builder-int-int-String-String-Object-Object) : MethodDecl "@Override     public void parse(Builder builder, int depth, String setter, Object... setterFormatArgs) {         setter = replaceLastLiteral(setter, "$L.parse($L)");         builder.addStatement(setter, expandStringArgs(setterFormatArgs, TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), JSON_PARSER_VARIABLE_NAME));     }" compose:Replacement merge: LineBased]
														[T -> serialize(Builder-Builder-int-int-String-String-String-String-boolean-boolean-boolean-boolean-boolean-boolean-boolean-boolean) : MethodDecl "@Override     public void serialize(Builder builder, int depth, String fieldName, String getter, boolean isObjectProperty, boolean checkIfNull, boolean writeIfNull, boolean writeCollectionElementIfNull) {         builder.addStatement("$L.serialize($L, $S, $L, $L)", TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), getter, fieldName, isObjectProperty, JSON_GENERATOR_VARIABLE_NAME);     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> processor : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> bluelinelabs : Folder]
							[NT -> logansquare : Folder]
								[NT -> processor : Folder]
									[NT -> type : Folder]
										[NT -> field : Folder]
											[NT -> TypeConverterFieldType.java : Java-File]
												[NT -> - : CompilationUnit]
													[T -> - : PackageDeclaration "package com.bluelinelabs.logansquare.processor.type.field;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector{ImportPackage} : ImportDeclaration "import com.bluelinelabs.logansquare.processor.ObjectMapperInjector;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.ClassName{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.ClassName;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.MethodSpec.Builder{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.MethodSpec.Builder;" compose:Replacement merge: Default]
													[T -> com.squareup.javapoet.TypeName{ImportPackage} : ImportDeclaration "import com.squareup.javapoet.TypeName;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME{ImportPackage} : ImportDeclaration "import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME;" compose:Replacement merge: Default]
													[T -> com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME{ImportPackage} : ImportDeclaration "import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME;" compose:Replacement merge: Default]
													[NT -> TypeConverterFieldType : ClassDeclaration]
														[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
														[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
														[T -> TypeConverterFieldType : Id "TypeConverterFieldType" compose:Replacement merge: Default]
														[T -> - : ExtendsList "extends FieldType" compose:Replacement merge: Default]
														[T -> mTypeName : FieldDecl "private TypeName mTypeName;" compose:Replacement merge: SemanticConflict]
														[T -> mTypeConverter : FieldDecl "private ClassName mTypeConverter;" compose:Replacement merge: SemanticConflict]
														[T -> TypeConverterFieldType(TypeName-TypeName-ClassName-ClassName) : ConstructorDecl "public TypeConverterFieldType(TypeName typeName, ClassName typeConverterClassName) {         mTypeName = typeName;         mTypeConverter = typeConverterClassName;     }" compose:Replacement merge: LineBased]
														[T -> getTypeName({FormalParametersInternal}) : MethodDecl "@Override     public TypeName getTypeName() {         return mTypeName;     }" compose:Replacement merge: LineBased]
														[T -> getNonPrimitiveTypeName({FormalParametersInternal}) : MethodDecl "@Override     public TypeName getNonPrimitiveTypeName() {         return mTypeName;     }" compose:Replacement merge: LineBased]
														[T -> getTypeConverterClassName({FormalParametersInternal}) : MethodDecl "public ClassName getTypeConverterClassName() {         return mTypeConverter;     }" compose:Replacement merge: LineBased]
														[T -> parse(Builder-Builder-int-int-String-String-Object-Object) : MethodDecl "@Override     public void parse(Builder builder, int depth, String setter, Object... setterFormatArgs) {         setter = replaceLastLiteral(setter, "$L.parse($L)");         builder.addStatement(setter, expandStringArgs(setterFormatArgs, ObjectMapperInjector.getTypeConverterVariableName(mTypeConverter), JSON_PARSER_VARIABLE_NAME));     }" compose:Replacement merge: LineBased]
														[T -> serialize(Builder-Builder-int-int-String-String-String-String-boolean-boolean-boolean-boolean-boolean-boolean-boolean-boolean) : MethodDecl "@Override     public void serialize(Builder builder, int depth, String fieldName, String getter, boolean isObjectProperty, boolean checkIfNull, boolean writeIfNull, boolean writeCollectionElementIfNull) {         builder.addStatement("$L.serialize($L, $S, $L, $L)", ObjectMapperInjector.getTypeConverterVariableName(mTypeConverter), getter, fieldName, isObjectProperty, JSON_GENERATOR_VARIABLE_NAME);     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> processor : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> bluelinelabs : Folder]
							[NT -> logansquare : Folder]
								[NT -> processor : Folder]
									[NT -> type : Folder]
										[NT -> field : Folder]
											[NT -> TypeConverterFieldType.java.merge : .java.merge-File]
												[T -> TypeConverterFieldType.java : .java-Content "package com.bluelinelabs.logansquare.processor.type.field;  import com.bluelinelabs.logansquare.processor.TextUtils; import com.squareup.javapoet.ClassName; import com.squareup.javapoet.MethodSpec.Builder; import com.squareup.javapoet.TypeName;  import java.util.List;  import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME; import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME;  public class TypeConverterFieldType extends FieldType {      private TypeName mTypeName;     private ClassName mTypeConverter;      public TypeConverterFieldType(TypeName typeName, ClassName typeConverterClassName) {         mTypeName = typeName;         mTypeConverter = typeConverterClassName;     }      @Override     public TypeName getTypeName() {         return mTypeName;     }      @Override     public TypeName getNonPrimitiveTypeName() {         return mTypeName;     }      public ClassName getTypeConverterClassName() {         return mTypeConverter;     }      @Override     public void parse(Builder builder, int depth, String setter, Object... setterFormatArgs) {         setter = replaceLastLiteral(setter, "$L.parse($L)");         builder.addStatement(setter, expandStringArgs(setterFormatArgs, TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), JSON_PARSER_VARIABLE_NAME));     }      @Override     public void serialize(Builder builder, int depth, String fieldName, List<String> processedFieldNames, String getter, boolean isObjectProperty, boolean checkIfNull, boolean writeIfNull, boolean writeCollectionElementIfNull) {         builder.addStatement("$L.serialize($L, $S, $L, $L)", TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), getter, fieldName, isObjectProperty, JSON_GENERATOR_VARIABLE_NAME);     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> processor : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> bluelinelabs : Folder]
							[NT -> logansquare : Folder]
								[NT -> processor : Folder]
									[NT -> type : Folder]
										[NT -> field : Folder]
											[NT -> TypeConverterFieldType.java.merge : .java.merge-File]
												[T -> TypeConverterFieldType.java : .java-Content "package com.bluelinelabs.logansquare.processor.type.field;  import com.bluelinelabs.logansquare.processor.TextUtils; import com.squareup.javapoet.ClassName; import com.squareup.javapoet.MethodSpec.Builder; import com.squareup.javapoet.TypeName;  import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME; import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME;  public class TypeConverterFieldType extends FieldType {      private TypeName mTypeName;     private ClassName mTypeConverter;      public TypeConverterFieldType(TypeName typeName, ClassName typeConverterClassName) {         mTypeName = typeName;         mTypeConverter = typeConverterClassName;     }      @Override     public TypeName getTypeName() {         return mTypeName;     }      @Override     public TypeName getNonPrimitiveTypeName() {         return mTypeName;     }      public ClassName getTypeConverterClassName() {         return mTypeConverter;     }      @Override     public void parse(Builder builder, int depth, String setter, Object... setterFormatArgs) {         setter = replaceLastLiteral(setter, "$L.parse($L)");         builder.addStatement(setter, expandStringArgs(setterFormatArgs, TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), JSON_PARSER_VARIABLE_NAME));     }      @Override     public void serialize(Builder builder, int depth, String fieldName, String getter, boolean isObjectProperty, boolean checkIfNull, boolean writeIfNull, boolean writeCollectionElementIfNull) {         builder.addStatement("$L.serialize($L, $S, $L, $L)", TextUtils.toUpperCaseWithUnderscores(mTypeConverter.simpleName()), getter, fieldName, isObjectProperty, JSON_GENERATOR_VARIABLE_NAME);     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> processor : Folder]
		[NT -> src : Folder]
			[NT -> main : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> bluelinelabs : Folder]
							[NT -> logansquare : Folder]
								[NT -> processor : Folder]
									[NT -> type : Folder]
										[NT -> field : Folder]
											[NT -> TypeConverterFieldType.java.merge : .java.merge-File]
												[T -> TypeConverterFieldType.java : .java-Content "package com.bluelinelabs.logansquare.processor.type.field;  import com.bluelinelabs.logansquare.processor.ObjectMapperInjector; import com.squareup.javapoet.ClassName; import com.squareup.javapoet.MethodSpec.Builder; import com.squareup.javapoet.TypeName;  import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_GENERATOR_VARIABLE_NAME; import static com.bluelinelabs.logansquare.processor.ObjectMapperInjector.JSON_PARSER_VARIABLE_NAME;  public class TypeConverterFieldType extends FieldType {      private TypeName mTypeName;     private ClassName mTypeConverter;      public TypeConverterFieldType(TypeName typeName, ClassName typeConverterClassName) {         mTypeName = typeName;         mTypeConverter = typeConverterClassName;     }      @Override     public TypeName getTypeName() {         return mTypeName;     }      @Override     public TypeName getNonPrimitiveTypeName() {         return mTypeName;     }      public ClassName getTypeConverterClassName() {         return mTypeConverter;     }      @Override     public void parse(Builder builder, int depth, String setter, Object... setterFormatArgs) {         setter = replaceLastLiteral(setter, "$L.parse($L)");         builder.addStatement(setter, expandStringArgs(setterFormatArgs, ObjectMapperInjector.getTypeConverterVariableName(mTypeConverter), JSON_PARSER_VARIABLE_NAME));     }      @Override     public void serialize(Builder builder, int depth, String fieldName, String getter, boolean isObjectProperty, boolean checkIfNull, boolean writeIfNull, boolean writeCollectionElementIfNull) {         builder.addStatement("$L.serialize($L, $S, $L, $L)", ObjectMapperInjector.getTypeConverterVariableName(mTypeConverter), getter, fieldName, isObjectProperty, JSON_GENERATOR_VARIABLE_NAME);     } } " compose:StringConcatenation merge: LineBased]
