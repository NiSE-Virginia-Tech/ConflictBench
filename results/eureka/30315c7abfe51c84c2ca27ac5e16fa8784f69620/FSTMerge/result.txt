Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/eureka2-core/src/test/java/com/netflix/eureka2/registry/NotifyingInstanceInfoHolderTest.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/left/eureka2-core/src/test/java/com/netflix/eureka2/registry/NotifyingInstanceInfoHolderTest.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/eureka2-core/src/test/java/com/netflix/eureka2/registry/NotifyingInstanceInfoHolderTest.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/base/eureka2-core/src/test/java/com/netflix/eureka2/registry/NotifyingInstanceInfoHolderTest.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/eureka2-core/src/test/java/com/netflix/eureka2/registry/NotifyingInstanceInfoHolderTest.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/right/eureka2-core/src/test/java/com/netflix/eureka2/registry/NotifyingInstanceInfoHolderTest.java
[NT -> left : Feature]
	[NT -> eureka2-core : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> netflix : Folder]
							[NT -> eureka2 : Folder]
								[NT -> registry : Folder]
									[NT -> NotifyingInstanceInfoHolderTest.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.netflix.eureka2.registry;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.interests.NotificationsSubject{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.interests.NotificationsSubject;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.registry.instance.InstanceInfo{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.registry.instance.InstanceInfo;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;" compose:Replacement merge: Default]
											[T -> org.junit.Rule{ImportPackage} : ImportDeclaration "import org.junit.Rule;" compose:Replacement merge: Default]
											[T -> org.junit.Test{ImportPackage} : ImportDeclaration "import org.junit.Test;" compose:Replacement merge: Default]
											[T -> org.junit.rules.ExternalResource{ImportPackage} : ImportDeclaration "import org.junit.rules.ExternalResource;" compose:Replacement merge: Default]
											[T -> rx.schedulers.Schedulers{ImportPackage} : ImportDeclaration "import rx.schedulers.Schedulers;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.metric.client.EurekaClientMetricFactory.clientMetrics{ImportPackage} : ImportDeclaration "import static com.netflix.eureka2.metric.client.EurekaClientMetricFactory.clientMetrics;" compose:Replacement merge: Default]
											[T -> org.hamcrest.MatcherAssert.assertThat{ImportPackage} : ImportDeclaration "import static org.hamcrest.MatcherAssert.assertThat;" compose:Replacement merge: Default]
											[T -> org.hamcrest.Matchers.equalTo{ImportPackage} : ImportDeclaration "import static org.hamcrest.Matchers.equalTo;" compose:Replacement merge: Default]
											[T -> org.hamcrest.Matchers.not{ImportPackage} : ImportDeclaration "import static org.hamcrest.Matchers.not;" compose:Replacement merge: Default]
											[NT -> NotifyingInstanceInfoHolderTest : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> NotifyingInstanceInfoHolderTest : Id "NotifyingInstanceInfoHolderTest" compose:Replacement merge: Default]
												[T -> notificationSubject : FieldDecl "private NotificationsSubject<InstanceInfo> notificationSubject;" compose:Replacement merge: SemanticConflict]
												[T -> storeAccessor : FieldDecl "private MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder> storeAccessor;" compose:Replacement merge: SemanticConflict]
												[T -> invoker : FieldDecl "private NotificationTaskInvoker invoker;" compose:Replacement merge: SemanticConflict]
												[T -> localSource : FieldDecl "private Source localSource;" compose:Replacement merge: SemanticConflict]
												[T -> testResource : FieldDecl "@Rule     public final ExternalResource testResource = new ExternalResource() {         @Override         protected void before() throws Throwable {             notificationSubject = NotificationsSubject.create();             storeAccessor = new MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder>() {                 @Override                 public void add(NotifyingInstanceInfoHolder holder) {                 }                  @Override                 public NotifyingInstanceInfoHolder get(String id) {                     return null;                 }                  @Override                 public void remove(String id) {                 }                  @Override                 public boolean contains(String id) {                     return false;                 }             };             invoker = new NotificationTaskInvoker(                     clientMetrics().getSerializedTaskInvokerMetrics(NotificationTaskInvoker.class),                     Schedulers.computation()             );             localSource = new Source(Source.Origin.LOCAL);         }     };" compose:Replacement merge: SemanticConflict]
												[T -> testUpdateSameSource({FormalParametersInternal}) : MethodDecl "@Test     public void testUpdateSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          holder.update(localSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), not(equalTo(firstInfo)));         assertThat(holder.get(), equalTo(secondInfo));     }" compose:Replacement merge: LineBased]
												[T -> testUpdateDifferentSources({FormalParametersInternal}) : MethodDecl "@Test     public void testUpdateDifferentSources() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(secondInfo));          InstanceInfo thirdInfo = builder                 .withStatus(InstanceInfo.Status.DOWN)                 .build();          holder.update(fooSource, thirdInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(thirdInfo));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveSameSource({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(0));         assertThat(holder.get(), equalTo(null));         assertThat(holder.get(localSource), equalTo(null));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveNonSnapshotCopy({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveNonSnapshotCopy() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(fooSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(fooSource), equalTo(null));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveSnapshotCopyPromoteAnother({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveSnapshotCopyPromoteAnother() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(fooInfo));         assertThat(holder.get(fooSource), equalTo(fooInfo));         assertThat(holder.get(localSource), not(equalTo(localInfo)));     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> eureka2-core : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> netflix : Folder]
							[NT -> eureka2 : Folder]
								[NT -> registry : Folder]
									[NT -> NotifyingInstanceInfoHolderTest.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.netflix.eureka2.registry;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.interests.NotificationsSubject{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.interests.NotificationsSubject;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.metric.SerializedTaskInvokerMetrics{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.metric.SerializedTaskInvokerMetrics;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.registry.instance.InstanceInfo{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.registry.instance.InstanceInfo;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;" compose:Replacement merge: Default]
											[T -> org.junit.Rule{ImportPackage} : ImportDeclaration "import org.junit.Rule;" compose:Replacement merge: Default]
											[T -> org.junit.Test{ImportPackage} : ImportDeclaration "import org.junit.Test;" compose:Replacement merge: Default]
											[T -> org.junit.rules.ExternalResource{ImportPackage} : ImportDeclaration "import org.junit.rules.ExternalResource;" compose:Replacement merge: Default]
											[T -> rx.schedulers.Schedulers{ImportPackage} : ImportDeclaration "import rx.schedulers.Schedulers;" compose:Replacement merge: Default]
											[T -> java.util.UUID{ImportPackage} : ImportDeclaration "import java.util.UUID;" compose:Replacement merge: Default]
											[T -> org.hamcrest.MatcherAssert.assertThat{ImportPackage} : ImportDeclaration "import static org.hamcrest.MatcherAssert.assertThat;" compose:Replacement merge: Default]
											[T -> org.hamcrest.Matchers.equalTo{ImportPackage} : ImportDeclaration "import static org.hamcrest.Matchers.equalTo;" compose:Replacement merge: Default]
											[T -> org.hamcrest.Matchers.not{ImportPackage} : ImportDeclaration "import static org.hamcrest.Matchers.not;" compose:Replacement merge: Default]
											[NT -> NotifyingInstanceInfoHolderTest : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> NotifyingInstanceInfoHolderTest : Id "NotifyingInstanceInfoHolderTest" compose:Replacement merge: Default]
												[T -> notificationSubject : FieldDecl "private NotificationsSubject<InstanceInfo> notificationSubject;" compose:Replacement merge: SemanticConflict]
												[T -> storeAccessor : FieldDecl "private MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder> storeAccessor;" compose:Replacement merge: SemanticConflict]
												[T -> invoker : FieldDecl "private NotificationTaskInvoker invoker;" compose:Replacement merge: SemanticConflict]
												[T -> localSource : FieldDecl "private Source localSource;" compose:Replacement merge: SemanticConflict]
												[T -> testResource : FieldDecl "@Rule     public final ExternalResource testResource = new ExternalResource() {         @Override         protected void before() throws Throwable {             notificationSubject = NotificationsSubject.create();             storeAccessor = new MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder>() {                 @Override                 public void add(NotifyingInstanceInfoHolder holder) {                 }                  @Override                 public NotifyingInstanceInfoHolder get(String id) {                     return null;                 }                  @Override                 public void remove(String id) {                 }                  @Override                 public boolean contains(String id) {                     return false;                 }             };             invoker = new NotificationTaskInvoker(SerializedTaskInvokerMetrics.dummyMetrics(), Schedulers.computation());             localSource = new Source(Source.Origin.LOCAL);         }     };" compose:Replacement merge: SemanticConflict]
												[T -> testUpdateSameSource({FormalParametersInternal}) : MethodDecl "@Test     public void testUpdateSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          holder.update(localSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), not(equalTo(firstInfo)));         assertThat(holder.get(), equalTo(secondInfo));     }" compose:Replacement merge: LineBased]
												[T -> testUpdateDifferentSources({FormalParametersInternal}) : MethodDecl "@Test     public void testUpdateDifferentSources() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(secondInfo));          InstanceInfo thirdInfo = builder                 .withStatus(InstanceInfo.Status.DOWN)                 .build();          holder.update(fooSource, thirdInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(thirdInfo));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveSameSource({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(0));         assertThat(holder.get(), equalTo(null));         assertThat(holder.get(localSource), equalTo(null));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveNonSnapshotCopy({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveNonSnapshotCopy() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(fooSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(fooSource), equalTo(null));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveSnapshotCopyPromoteAnother({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveSnapshotCopyPromoteAnother() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(fooInfo));         assertThat(holder.get(fooSource), equalTo(fooInfo));         assertThat(holder.get(localSource), not(equalTo(localInfo)));     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> eureka2-core : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> netflix : Folder]
							[NT -> eureka2 : Folder]
								[NT -> registry : Folder]
									[NT -> NotifyingInstanceInfoHolderTest.java : Java-File]
										[NT -> - : CompilationUnit]
											[T -> - : PackageDeclaration "package com.netflix.eureka2.registry;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.interests.NotificationsSubject{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.interests.NotificationsSubject;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.metric.SerializedTaskInvokerMetrics{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.metric.SerializedTaskInvokerMetrics;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.registry.instance.InstanceInfo{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.registry.instance.InstanceInfo;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker;" compose:Replacement merge: Default]
											[T -> com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo{ImportPackage} : ImportDeclaration "import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo;" compose:Replacement merge: Default]
											[T -> org.junit.Rule{ImportPackage} : ImportDeclaration "import org.junit.Rule;" compose:Replacement merge: Default]
											[T -> org.junit.Test{ImportPackage} : ImportDeclaration "import org.junit.Test;" compose:Replacement merge: Default]
											[T -> org.junit.rules.ExternalResource{ImportPackage} : ImportDeclaration "import org.junit.rules.ExternalResource;" compose:Replacement merge: Default]
											[T -> rx.schedulers.Schedulers{ImportPackage} : ImportDeclaration "import rx.schedulers.Schedulers;" compose:Replacement merge: Default]
											[T -> org.hamcrest.MatcherAssert.assertThat{ImportPackage} : ImportDeclaration "import static org.hamcrest.MatcherAssert.assertThat;" compose:Replacement merge: Default]
											[T -> org.hamcrest.Matchers.equalTo{ImportPackage} : ImportDeclaration "import static org.hamcrest.Matchers.equalTo;" compose:Replacement merge: Default]
											[T -> org.hamcrest.Matchers.not{ImportPackage} : ImportDeclaration "import static org.hamcrest.Matchers.not;" compose:Replacement merge: Default]
											[NT -> NotifyingInstanceInfoHolderTest : ClassDeclaration]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
												[T -> NotifyingInstanceInfoHolderTest : Id "NotifyingInstanceInfoHolderTest" compose:Replacement merge: Default]
												[T -> notificationSubject : FieldDecl "private NotificationsSubject<InstanceInfo> notificationSubject;" compose:Replacement merge: SemanticConflict]
												[T -> storeAccessor : FieldDecl "private MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder> storeAccessor;" compose:Replacement merge: SemanticConflict]
												[T -> invoker : FieldDecl "private NotificationTaskInvoker invoker;" compose:Replacement merge: SemanticConflict]
												[T -> localSource : FieldDecl "private Source localSource;" compose:Replacement merge: SemanticConflict]
												[T -> testResource : FieldDecl "@Rule     public final ExternalResource testResource = new ExternalResource() {         @Override         protected void before() throws Throwable {             notificationSubject = NotificationsSubject.create();             storeAccessor = new MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder>() {                 @Override                 public void add(NotifyingInstanceInfoHolder holder) {                 }                  @Override                 public NotifyingInstanceInfoHolder get(String id) {                     return null;                 }                  @Override                 public void remove(String id) {                 }                  @Override                 public boolean contains(String id) {                     return false;                 }             };             invoker = new NotificationTaskInvoker(SerializedTaskInvokerMetrics.dummyMetrics(), Schedulers.computation());             localSource = new Source(Source.Origin.LOCAL);         }     };" compose:Replacement merge: SemanticConflict]
												[T -> testUpdateSameSource({FormalParametersInternal}) : MethodDecl "@Test     public void testUpdateSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          holder.update(localSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), not(equalTo(firstInfo)));         assertThat(holder.get(), equalTo(secondInfo));     }" compose:Replacement merge: LineBased]
												[T -> testUpdateDifferentSources({FormalParametersInternal}) : MethodDecl "@Test     public void testUpdateDifferentSources() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(secondInfo));          InstanceInfo thirdInfo = builder                 .withStatus(InstanceInfo.Status.DOWN)                 .build();          holder.update(fooSource, thirdInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(thirdInfo));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveSameSource({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(0));         assertThat(holder.get(), equalTo(null));         assertThat(holder.get(localSource), equalTo(null));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveNonSnapshotCopy({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveNonSnapshotCopy() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(fooSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(fooSource), equalTo(null));     }" compose:Replacement merge: LineBased]
												[T -> testRemoveSnapshotCopyPromoteAnother({FormalParametersInternal}) : MethodDecl "@Test     public void testRemoveSnapshotCopyPromoteAnother() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(fooInfo));         assertThat(holder.get(fooSource), equalTo(fooInfo));         assertThat(holder.get(localSource), not(equalTo(localInfo)));     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> eureka2-core : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> netflix : Folder]
							[NT -> eureka2 : Folder]
								[NT -> registry : Folder]
									[NT -> NotifyingInstanceInfoHolderTest.java.merge : .java.merge-File]
										[T -> NotifyingInstanceInfoHolderTest.java : .java-Content "package com.netflix.eureka2.registry;  import com.netflix.eureka2.interests.NotificationsSubject; import com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker; import com.netflix.eureka2.registry.instance.InstanceInfo; import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExternalResource; import rx.schedulers.Schedulers;  import static com.netflix.eureka2.metric.client.EurekaClientMetricFactory.clientMetrics; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.not;  /**  * @author David Liu  */ public class NotifyingInstanceInfoHolderTest {      private NotificationsSubject<InstanceInfo> notificationSubject;     private MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder> storeAccessor;     private NotificationTaskInvoker invoker;     private Source localSource;      @Rule     public final ExternalResource testResource = new ExternalResource() {         @Override         protected void before() throws Throwable {             notificationSubject = NotificationsSubject.create();             storeAccessor = new MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder>() {                 @Override                 public void add(NotifyingInstanceInfoHolder holder) {                 }                  @Override                 public NotifyingInstanceInfoHolder get(String id) {                     return null;                 }                  @Override                 public void remove(String id) {                 }                  @Override                 public boolean contains(String id) {                     return false;                 }             };             invoker = new NotificationTaskInvoker(                     clientMetrics().getSerializedTaskInvokerMetrics(NotificationTaskInvoker.class),                     Schedulers.computation()             );             localSource = new Source(Source.Origin.LOCAL);         }     };      @Test     public void testUpdateSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          holder.update(localSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), not(equalTo(firstInfo)));         assertThat(holder.get(), equalTo(secondInfo));     }      @Test     public void testUpdateDifferentSources() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(secondInfo));          InstanceInfo thirdInfo = builder                 .withStatus(InstanceInfo.Status.DOWN)                 .build();          holder.update(fooSource, thirdInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(thirdInfo));     }      @Test     public void testRemoveSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(0));         assertThat(holder.get(), equalTo(null));         assertThat(holder.get(localSource), equalTo(null));     }      @Test     public void testRemoveNonSnapshotCopy() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(fooSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(fooSource), equalTo(null));     }      @Test     public void testRemoveSnapshotCopyPromoteAnother() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(fooInfo));         assertThat(holder.get(fooSource), equalTo(fooInfo));         assertThat(holder.get(localSource), not(equalTo(localInfo)));     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> eureka2-core : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> netflix : Folder]
							[NT -> eureka2 : Folder]
								[NT -> registry : Folder]
									[NT -> NotifyingInstanceInfoHolderTest.java.merge : .java.merge-File]
										[T -> NotifyingInstanceInfoHolderTest.java : .java-Content "package com.netflix.eureka2.registry;  import com.netflix.eureka2.interests.NotificationsSubject; import com.netflix.eureka2.metric.SerializedTaskInvokerMetrics; import com.netflix.eureka2.registry.instance.InstanceInfo; import com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker; import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExternalResource; import rx.schedulers.Schedulers;  import java.util.UUID;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.not;  /**  * @author David Liu  */ public class NotifyingInstanceInfoHolderTest {      private NotificationsSubject<InstanceInfo> notificationSubject;     private MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder> storeAccessor;     private NotificationTaskInvoker invoker;     private Source localSource;      @Rule     public final ExternalResource testResource = new ExternalResource() {         @Override         protected void before() throws Throwable {             notificationSubject = NotificationsSubject.create();             storeAccessor = new MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder>() {                 @Override                 public void add(NotifyingInstanceInfoHolder holder) {                 }                  @Override                 public NotifyingInstanceInfoHolder get(String id) {                     return null;                 }                  @Override                 public void remove(String id) {                 }                  @Override                 public boolean contains(String id) {                     return false;                 }             };             invoker = new NotificationTaskInvoker(SerializedTaskInvokerMetrics.dummyMetrics(), Schedulers.computation());             localSource = new Source(Source.Origin.LOCAL);         }     };      @Test     public void testUpdateSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          holder.update(localSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), not(equalTo(firstInfo)));         assertThat(holder.get(), equalTo(secondInfo));     }      @Test     public void testUpdateDifferentSources() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(secondInfo));          InstanceInfo thirdInfo = builder                 .withStatus(InstanceInfo.Status.DOWN)                 .build();          holder.update(fooSource, thirdInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(thirdInfo));     }      @Test     public void testRemoveSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(0));         assertThat(holder.get(), equalTo(null));         assertThat(holder.get(localSource), equalTo(null));     }      @Test     public void testRemoveNonSnapshotCopy() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(fooSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(fooSource), equalTo(null));     }      @Test     public void testRemoveSnapshotCopyPromoteAnother() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(fooInfo));         assertThat(holder.get(fooSource), equalTo(fooInfo));         assertThat(holder.get(localSource), not(equalTo(localInfo)));     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> eureka2-core : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> netflix : Folder]
							[NT -> eureka2 : Folder]
								[NT -> registry : Folder]
									[NT -> NotifyingInstanceInfoHolderTest.java.merge : .java.merge-File]
										[T -> NotifyingInstanceInfoHolderTest.java : .java-Content "package com.netflix.eureka2.registry;  import com.netflix.eureka2.interests.NotificationsSubject; import com.netflix.eureka2.metric.SerializedTaskInvokerMetrics; import com.netflix.eureka2.registry.instance.InstanceInfo; import com.netflix.eureka2.registry.NotifyingInstanceInfoHolder.NotificationTaskInvoker; import com.netflix.eureka2.testkit.data.builder.SampleInstanceInfo; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExternalResource; import rx.schedulers.Schedulers;  import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.not;  /**  * @author David Liu  */ public class NotifyingInstanceInfoHolderTest {      private NotificationsSubject<InstanceInfo> notificationSubject;     private MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder> storeAccessor;     private NotificationTaskInvoker invoker;     private Source localSource;      @Rule     public final ExternalResource testResource = new ExternalResource() {         @Override         protected void before() throws Throwable {             notificationSubject = NotificationsSubject.create();             storeAccessor = new MultiSourcedDataHolder.HolderStoreAccessor<NotifyingInstanceInfoHolder>() {                 @Override                 public void add(NotifyingInstanceInfoHolder holder) {                 }                  @Override                 public NotifyingInstanceInfoHolder get(String id) {                     return null;                 }                  @Override                 public void remove(String id) {                 }                  @Override                 public boolean contains(String id) {                     return false;                 }             };             invoker = new NotificationTaskInvoker(SerializedTaskInvokerMetrics.dummyMetrics(), Schedulers.computation());             localSource = new Source(Source.Origin.LOCAL);         }     };      @Test     public void testUpdateSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          holder.update(localSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), not(equalTo(firstInfo)));         assertThat(holder.get(), equalTo(secondInfo));     }      @Test     public void testUpdateDifferentSources() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          InstanceInfo secondInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, secondInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(secondInfo));          InstanceInfo thirdInfo = builder                 .withStatus(InstanceInfo.Status.DOWN)                 .build();          holder.update(fooSource, thirdInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(firstInfo));         assertThat(holder.get(), not(equalTo(secondInfo)));          assertThat(holder.get(fooSource), equalTo(thirdInfo));     }      @Test     public void testRemoveSameSource() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo firstInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, firstInfo.getId());         holder.update(localSource, firstInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(firstInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(0));         assertThat(holder.get(), equalTo(null));         assertThat(holder.get(localSource), equalTo(null));     }      @Test     public void testRemoveNonSnapshotCopy() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(fooSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(fooSource), equalTo(null));     }      @Test     public void testRemoveSnapshotCopyPromoteAnother() throws Exception {         InstanceInfo.Builder builder = SampleInstanceInfo.DiscoveryServer.builder();         InstanceInfo localInfo = builder                 .withStatus(InstanceInfo.Status.STARTING)                 .build();          NotifyingInstanceInfoHolder holder = new NotifyingInstanceInfoHolder(storeAccessor, notificationSubject, invoker, localInfo.getId());         holder.update(localSource, localInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(localInfo));          InstanceInfo fooInfo = builder                 .withStatus(InstanceInfo.Status.UP)                 .build();          Source fooSource = new Source(Source.Origin.REPLICATED, "foo");         holder.update(fooSource, fooInfo).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(2));         assertThat(holder.get(), equalTo(localInfo));         assertThat(holder.get(), not(equalTo(fooInfo)));          assertThat(holder.get(fooSource), equalTo(fooInfo));          holder.remove(localSource).toBlocking().firstOrDefault(null);          assertThat(holder.size(), equalTo(1));         assertThat(holder.get(), equalTo(fooInfo));         assertThat(holder.get(fooSource), equalTo(fooInfo));         assertThat(holder.get(localSource), not(equalTo(localInfo)));     } } " compose:StringConcatenation merge: LineBased]
