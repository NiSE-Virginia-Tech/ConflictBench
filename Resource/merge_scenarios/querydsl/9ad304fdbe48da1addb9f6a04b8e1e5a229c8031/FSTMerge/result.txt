Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/querydsl/left/querydsl-sql/src/test/java/com/mysema/query/UnionBase.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/querydsl/left/querydsl-sql/src/test/java/com/mysema/query/UnionBase.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/querydsl/base/querydsl-sql/src/test/java/com/mysema/query/UnionBase.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/querydsl/base/querydsl-sql/src/test/java/com/mysema/query/UnionBase.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/querydsl/right/querydsl-sql/src/test/java/com/mysema/query/UnionBase.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/workspace/querydsl/right/querydsl-sql/src/test/java/com/mysema/query/UnionBase.java
[NT -> left : Feature]
	[NT -> querydsl-sql : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> mysema : Folder]
							[NT -> query : Folder]
								[NT -> UnionBase.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.mysema.query;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Constants.employee{ImportPackage} : ImportDeclaration "import static com.mysema.query.Constants.employee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.CUBRID{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.CUBRID;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.DERBY{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.DERBY;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.TERADATA{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.TERADATA;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertEquals{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertEquals;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertFalse{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertFalse;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertNotNull{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertNotNull;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertTrue{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertTrue;" compose:Replacement merge: Default]
										[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
										[T -> java.sql.SQLException{ImportPackage} : ImportDeclaration "import java.sql.SQLException;" compose:Replacement merge: Default]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> org.junit.Test{ImportPackage} : ImportDeclaration "import org.junit.Test;" compose:Replacement merge: Default]
										[T -> com.mysema.commons.lang.CloseableIterator{ImportPackage} : ImportDeclaration "import com.mysema.commons.lang.CloseableIterator;" compose:Replacement merge: Default]
										[T -> com.mysema.query.sql.domain.Employee{ImportPackage} : ImportDeclaration "import com.mysema.query.sql.domain.Employee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.sql.domain.QEmployee{ImportPackage} : ImportDeclaration "import com.mysema.query.sql.domain.QEmployee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.Expression{ImportPackage} : ImportDeclaration "import com.mysema.query.types.Expression;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.Projections{ImportPackage} : ImportDeclaration "import com.mysema.query.types.Projections;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.SubQueryExpression{ImportPackage} : ImportDeclaration "import com.mysema.query.types.SubQueryExpression;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.query.ListSubQuery{ImportPackage} : ImportDeclaration "import com.mysema.query.types.query.ListSubQuery;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.query.SimpleSubQuery{ImportPackage} : ImportDeclaration "import com.mysema.query.types.query.SimpleSubQuery;" compose:Replacement merge: Default]
										[T -> com.mysema.testutil.ExcludeIn{ImportPackage} : ImportDeclaration "import com.mysema.testutil.ExcludeIn;" compose:Replacement merge: Default]
										[NT -> UnionBase : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> UnionBase : Id "UnionBase" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AbstractBaseTest" compose:Replacement merge: Default]
											[T -> Union({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_All({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_All() {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().unionAll(sq1, sq2).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_Multiple_Columns({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multiple_Columns() throws SQLException {         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.firstname, employee.lastname);         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.lastname, employee.firstname);         List<Tuple> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());         for (Tuple row : list) {             assertNotNull(row.get(0, Object.class));             assertNotNull(row.get(1, Object.class));         }     }" compose:Replacement merge: LineBased]
											[T -> Union_Empty_Result({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_Empty_Result() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).where(employee.firstname.eq("XXX")).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).where(employee.firstname.eq("YYY")).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).list();         assertTrue(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union2({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union2() throws SQLException {         List<Integer> list = query().union(                 sq().from(employee).unique(employee.id.max()),                 sq().from(employee).unique(employee.id.min())).list();         assertFalse(list.isEmpty());      }" compose:Replacement merge: LineBased]
											[T -> Union3({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union3() throws SQLException {         SimpleSubQuery<Tuple> sq3 = sq().from(employee).unique(new Expression[]{employee.id.max()});         SimpleSubQuery<Tuple> sq4 = sq().from(employee).unique(new Expression[]{employee.id.min()});         List<Tuple> list2 = query().union(sq3, sq4).list();         assertFalse(list2.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union4({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn({DERBY})     public void Union4() {         SimpleSubQuery<Tuple> sq1 = sq().from(employee).unique(employee.id, employee.firstname);         SimpleSubQuery<Tuple> sq2 = sq().from(employee).unique(employee.id, employee.firstname);         query().union(employee, sq1, sq2).list(employee.id.count());     }" compose:Replacement merge: LineBased]
											[T -> Union5({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn({DERBY, CUBRID, TERADATA})     public void Union5() {         /* (select e.ID, e.FIRSTNAME, superior.ID as sup_id, superior.FIRSTNAME as sup_name          * from EMPLOYEE e join EMPLOYEE superior on e.SUPERIOR_ID = superior.ID)          * union          * (select e.ID, e.FIRSTNAME, null, null from EMPLOYEE e)          * order by ID asc          */         QEmployee superior = new QEmployee("superior");         ListSubQuery<Tuple> sq1 = sq().from(employee)                 .join(employee.superiorIdKey, superior)                 .list(employee.id, employee.firstname, superior.id.as("sup_id"), superior.firstname.as("sup_name"));         ListSubQuery<Tuple> sq2 = sq().from(employee)                 .list(employee.id, employee.firstname, null, null);         List<Tuple> results = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         for (Tuple result : results) {             System.err.println(Arrays.asList(result));         }     }" compose:Replacement merge: LineBased]
											[T -> Union_With_Order({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn(TERADATA) // The ORDER BY clause must contain only integer constants.     @SuppressWarnings("unchecked")     public void Union_With_Order() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_Multi_Column_Projection_List({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_List() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          List<Tuple> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }" compose:Replacement merge: LineBased]
											[T -> Union_Multi_Column_Projection_Iterate({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_Iterate() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          CloseableIterator<Tuple> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }" compose:Replacement merge: LineBased]
											[T -> Union_Single_Column_Projections_List({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_List() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          List<Integer> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }" compose:Replacement merge: LineBased]
											[T -> Union_Single_Column_Projections_Iterate({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_Iterate() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          CloseableIterator<Integer> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }" compose:Replacement merge: LineBased]
											[T -> Union_FactoryExpression({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_FactoryExpression() {         ListSubQuery<Employee> sq1 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         ListSubQuery<Employee> sq2 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         List<Employee> employees = query().union(sq1, sq2).list();         for (Employee employee : employees) {             assertNotNull(employee);         }     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> querydsl-sql : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> mysema : Folder]
							[NT -> query : Folder]
								[NT -> UnionBase.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.mysema.query;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Constants.employee{ImportPackage} : ImportDeclaration "import static com.mysema.query.Constants.employee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.CUBRID{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.CUBRID;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.DERBY{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.DERBY;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertEquals{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertEquals;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertFalse{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertFalse;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertNotNull{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertNotNull;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertTrue{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertTrue;" compose:Replacement merge: Default]
										[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
										[T -> java.sql.SQLException{ImportPackage} : ImportDeclaration "import java.sql.SQLException;" compose:Replacement merge: Default]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> org.junit.Test{ImportPackage} : ImportDeclaration "import org.junit.Test;" compose:Replacement merge: Default]
										[T -> com.mysema.commons.lang.CloseableIterator{ImportPackage} : ImportDeclaration "import com.mysema.commons.lang.CloseableIterator;" compose:Replacement merge: Default]
										[T -> com.mysema.query.sql.domain.Employee{ImportPackage} : ImportDeclaration "import com.mysema.query.sql.domain.Employee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.sql.domain.QEmployee{ImportPackage} : ImportDeclaration "import com.mysema.query.sql.domain.QEmployee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.Expression{ImportPackage} : ImportDeclaration "import com.mysema.query.types.Expression;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.Projections{ImportPackage} : ImportDeclaration "import com.mysema.query.types.Projections;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.SubQueryExpression{ImportPackage} : ImportDeclaration "import com.mysema.query.types.SubQueryExpression;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.query.ListSubQuery{ImportPackage} : ImportDeclaration "import com.mysema.query.types.query.ListSubQuery;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.query.SimpleSubQuery{ImportPackage} : ImportDeclaration "import com.mysema.query.types.query.SimpleSubQuery;" compose:Replacement merge: Default]
										[T -> com.mysema.testutil.ExcludeIn{ImportPackage} : ImportDeclaration "import com.mysema.testutil.ExcludeIn;" compose:Replacement merge: Default]
										[NT -> UnionBase : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> UnionBase : Id "UnionBase" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AbstractBaseTest" compose:Replacement merge: Default]
											[T -> Union({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_All({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_All() {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().unionAll(sq1, sq2).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_Multiple_Columns({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multiple_Columns() throws SQLException {         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.firstname, employee.lastname);         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.lastname, employee.firstname);         List<Tuple> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());         for (Tuple row : list) {             assertNotNull(row.get(0, Object.class));             assertNotNull(row.get(1, Object.class));         }     }" compose:Replacement merge: LineBased]
											[T -> Union_Empty_Result({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_Empty_Result() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).where(employee.firstname.eq("XXX")).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).where(employee.firstname.eq("YYY")).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).list();         assertTrue(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union2({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union2() throws SQLException {         List<Integer> list = query().union(                 sq().from(employee).unique(employee.id.max()),                 sq().from(employee).unique(employee.id.min())).list();         assertFalse(list.isEmpty());      }" compose:Replacement merge: LineBased]
											[T -> Union3({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union3() throws SQLException {         SimpleSubQuery<Tuple> sq3 = sq().from(employee).unique(new Expression[]{employee.id.max()});         SimpleSubQuery<Tuple> sq4 = sq().from(employee).unique(new Expression[]{employee.id.min()});         List<Tuple> list2 = query().union(sq3, sq4).list();         assertFalse(list2.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union4({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn({DERBY})     public void Union4() {         SimpleSubQuery<Tuple> sq1 = sq().from(employee).unique(employee.id, employee.firstname);         SimpleSubQuery<Tuple> sq2 = sq().from(employee).unique(employee.id, employee.firstname);         query().union(employee, sq1, sq2).list(employee.id.count());     }" compose:Replacement merge: LineBased]
											[T -> Union5({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn({DERBY, CUBRID})     public void Union5() {         /* (select e.ID, e.FIRSTNAME, superior.ID as sup_id, superior.FIRSTNAME as sup_name           * from EMPLOYEE e join EMPLOYEE superior on e.SUPERIOR_ID = superior.ID)           * union           * (select e.ID, e.FIRSTNAME, null, null from EMPLOYEE e)           * order by ID asc          */         QEmployee superior = new QEmployee("superior");         ListSubQuery<Tuple> sq1 = sq().from(employee)                 .join(employee.superiorIdKey, superior)                 .list(employee.id, employee.firstname, superior.id.as("sup_id"), superior.firstname.as("sup_name"));         ListSubQuery<Tuple> sq2 = sq().from(employee)                 .list(employee.id, employee.firstname, null, null);         List<Tuple> results = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         for (Tuple result : results) {             System.err.println(Arrays.asList(result));         }       }" compose:Replacement merge: LineBased]
											[T -> Union_With_Order({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_With_Order() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_Multi_Column_Projection_List({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_List() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          List<Tuple> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }" compose:Replacement merge: LineBased]
											[T -> Union_Multi_Column_Projection_Iterate({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_Iterate() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          CloseableIterator<Tuple> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }" compose:Replacement merge: LineBased]
											[T -> Union_Single_Column_Projections_List({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_List() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          List<Integer> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }" compose:Replacement merge: LineBased]
											[T -> Union_Single_Column_Projections_Iterate({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_Iterate() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          CloseableIterator<Integer> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }" compose:Replacement merge: LineBased]
											[T -> Union_FactoryExpression({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_FactoryExpression() {         ListSubQuery<Employee> sq1 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         ListSubQuery<Employee> sq2 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));                 List<Employee> employees = query().union(sq1, sq2).list();         for (Employee employee : employees) {             assertNotNull(employee);         }     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> querydsl-sql : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> mysema : Folder]
							[NT -> query : Folder]
								[NT -> UnionBase.java : Java-File]
									[NT -> - : CompilationUnit]
										[T -> - : PackageDeclaration "package com.mysema.query;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Constants.employee{ImportPackage} : ImportDeclaration "import static com.mysema.query.Constants.employee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.CUBRID{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.CUBRID;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.DERBY{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.DERBY;" compose:Replacement merge: Default]
										[T -> com.mysema.query.Target.MYSQL{ImportPackage} : ImportDeclaration "import static com.mysema.query.Target.MYSQL;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertEquals{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertEquals;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertFalse{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertFalse;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertNotNull{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertNotNull;" compose:Replacement merge: Default]
										[T -> org.junit.Assert.assertTrue{ImportPackage} : ImportDeclaration "import static org.junit.Assert.assertTrue;" compose:Replacement merge: Default]
										[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
										[T -> java.sql.SQLException{ImportPackage} : ImportDeclaration "import java.sql.SQLException;" compose:Replacement merge: Default]
										[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
										[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
										[T -> org.junit.Test{ImportPackage} : ImportDeclaration "import org.junit.Test;" compose:Replacement merge: Default]
										[T -> com.mysema.commons.lang.CloseableIterator{ImportPackage} : ImportDeclaration "import com.mysema.commons.lang.CloseableIterator;" compose:Replacement merge: Default]
										[T -> com.mysema.query.sql.domain.Employee{ImportPackage} : ImportDeclaration "import com.mysema.query.sql.domain.Employee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.sql.domain.QEmployee{ImportPackage} : ImportDeclaration "import com.mysema.query.sql.domain.QEmployee;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.Expression{ImportPackage} : ImportDeclaration "import com.mysema.query.types.Expression;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.Projections{ImportPackage} : ImportDeclaration "import com.mysema.query.types.Projections;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.SubQueryExpression{ImportPackage} : ImportDeclaration "import com.mysema.query.types.SubQueryExpression;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.query.ListSubQuery{ImportPackage} : ImportDeclaration "import com.mysema.query.types.query.ListSubQuery;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.query.SimpleSubQuery{ImportPackage} : ImportDeclaration "import com.mysema.query.types.query.SimpleSubQuery;" compose:Replacement merge: Default]
										[T -> com.mysema.query.types.template.NumberTemplate{ImportPackage} : ImportDeclaration "import com.mysema.query.types.template.NumberTemplate;" compose:Replacement merge: Default]
										[T -> com.mysema.testutil.ExcludeIn{ImportPackage} : ImportDeclaration "import com.mysema.testutil.ExcludeIn;" compose:Replacement merge: Default]
										[NT -> UnionBase : ClassDeclaration]
											[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> UnionBase : Id "UnionBase" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends AbstractBaseTest" compose:Replacement merge: Default]
											[T -> In_Union({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn(MYSQL)     public void In_Union() {         assertTrue(query().from(employee)             .where(employee.id.in(                 sq().union(sq().unique(NumberTemplate.ONE),                            sq().unique(NumberTemplate.TWO))))             .exists());     }" compose:Replacement merge: LineBased]
											[T -> Union({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_All({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_All() {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().unionAll(sq1, sq2).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_Multiple_Columns({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multiple_Columns() throws SQLException {         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.firstname, employee.lastname);         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.lastname, employee.firstname);         List<Tuple> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());         for (Tuple row : list) {             assertNotNull(row.get(0, Object.class));             assertNotNull(row.get(1, Object.class));         }     }" compose:Replacement merge: LineBased]
											[T -> Union_Empty_Result({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_Empty_Result() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).where(employee.firstname.eq("XXX")).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).where(employee.firstname.eq("YYY")).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).list();         assertTrue(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union2({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union2() throws SQLException {         List<Integer> list = query().union(                 sq().from(employee).unique(employee.id.max()),                 sq().from(employee).unique(employee.id.min())).list();         assertFalse(list.isEmpty());      }" compose:Replacement merge: LineBased]
											[T -> Union3({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union3() throws SQLException {         SimpleSubQuery<Tuple> sq3 = sq().from(employee).unique(new Expression[]{employee.id.max()});         SimpleSubQuery<Tuple> sq4 = sq().from(employee).unique(new Expression[]{employee.id.min()});         List<Tuple> list2 = query().union(sq3, sq4).list();         assertFalse(list2.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union4({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn({DERBY})     public void Union4() {         SimpleSubQuery<Tuple> sq1 = sq().from(employee).unique(employee.id, employee.firstname);         SimpleSubQuery<Tuple> sq2 = sq().from(employee).unique(employee.id, employee.firstname);         query().union(employee, sq1, sq2).list(employee.id.count());     }" compose:Replacement merge: LineBased]
											[T -> Union5({FormalParametersInternal}) : MethodDecl "@Test     @ExcludeIn({DERBY, CUBRID})     public void Union5() {         /* (select e.ID, e.FIRSTNAME, superior.ID as sup_id, superior.FIRSTNAME as sup_name          * from EMPLOYEE e join EMPLOYEE superior on e.SUPERIOR_ID = superior.ID)          * union          * (select e.ID, e.FIRSTNAME, null, null from EMPLOYEE e)          * order by ID asc          */         QEmployee superior = new QEmployee("superior");         ListSubQuery<Tuple> sq1 = sq().from(employee)                 .join(employee.superiorIdKey, superior)                 .list(employee.id, employee.firstname, superior.id.as("sup_id"), superior.firstname.as("sup_name"));         ListSubQuery<Tuple> sq2 = sq().from(employee)                 .list(employee.id, employee.firstname, null, null);         List<Tuple> results = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         for (Tuple result : results) {             System.err.println(Arrays.asList(result));         }      }" compose:Replacement merge: LineBased]
											[T -> Union_With_Order({FormalParametersInternal}) : MethodDecl "@Test     @SuppressWarnings("unchecked")     public void Union_With_Order() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         assertFalse(list.isEmpty());     }" compose:Replacement merge: LineBased]
											[T -> Union_Multi_Column_Projection_List({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_List() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          List<Tuple> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }" compose:Replacement merge: LineBased]
											[T -> Union_Multi_Column_Projection_Iterate({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_Iterate() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          CloseableIterator<Tuple> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }" compose:Replacement merge: LineBased]
											[T -> Union_Single_Column_Projections_List({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_List() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          List<Integer> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }" compose:Replacement merge: LineBased]
											[T -> Union_Single_Column_Projections_Iterate({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_Iterate() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          CloseableIterator<Integer> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }" compose:Replacement merge: LineBased]
											[T -> Union_FactoryExpression({FormalParametersInternal}) : MethodDecl "@SuppressWarnings("unchecked")     @Test     public void Union_FactoryExpression() {         ListSubQuery<Employee> sq1 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         ListSubQuery<Employee> sq2 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         List<Employee> employees = query().union(sq1, sq2).list();         for (Employee employee : employees) {             assertNotNull(employee);         }     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> querydsl-sql : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> mysema : Folder]
							[NT -> query : Folder]
								[NT -> UnionBase.java.merge : .java.merge-File]
									[T -> UnionBase.java : .java-Content "package com.mysema.query;  import static com.mysema.query.Constants.employee; import static com.mysema.query.Target.CUBRID; import static com.mysema.query.Target.DERBY; import static com.mysema.query.Target.TERADATA; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import java.io.IOException; import java.sql.SQLException; import java.util.Arrays; import java.util.List;  import org.junit.Test;  import com.mysema.commons.lang.CloseableIterator; import com.mysema.query.sql.domain.Employee; import com.mysema.query.sql.domain.QEmployee; import com.mysema.query.types.Expression; import com.mysema.query.types.Projections; import com.mysema.query.types.SubQueryExpression; import com.mysema.query.types.query.ListSubQuery; import com.mysema.query.types.query.SimpleSubQuery; import com.mysema.testutil.ExcludeIn;  public class UnionBase extends AbstractBaseTest {      @Test     @SuppressWarnings("unchecked")     public void Union() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());     }      @Test     @SuppressWarnings("unchecked")     public void Union_All() {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().unionAll(sq1, sq2).list();         assertFalse(list.isEmpty());     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multiple_Columns() throws SQLException {         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.firstname, employee.lastname);         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.lastname, employee.firstname);         List<Tuple> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());         for (Tuple row : list) {             assertNotNull(row.get(0, Object.class));             assertNotNull(row.get(1, Object.class));         }     }      @Test     @SuppressWarnings("unchecked")     public void Union_Empty_Result() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).where(employee.firstname.eq("XXX")).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).where(employee.firstname.eq("YYY")).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).list();         assertTrue(list.isEmpty());     }      @Test     @SuppressWarnings("unchecked")     public void Union2() throws SQLException {         List<Integer> list = query().union(                 sq().from(employee).unique(employee.id.max()),                 sq().from(employee).unique(employee.id.min())).list();         assertFalse(list.isEmpty());      }      @Test     @SuppressWarnings("unchecked")     public void Union3() throws SQLException {         SimpleSubQuery<Tuple> sq3 = sq().from(employee).unique(new Expression[]{employee.id.max()});         SimpleSubQuery<Tuple> sq4 = sq().from(employee).unique(new Expression[]{employee.id.min()});         List<Tuple> list2 = query().union(sq3, sq4).list();         assertFalse(list2.isEmpty());     }      @Test     @ExcludeIn({DERBY})     public void Union4() {         SimpleSubQuery<Tuple> sq1 = sq().from(employee).unique(employee.id, employee.firstname);         SimpleSubQuery<Tuple> sq2 = sq().from(employee).unique(employee.id, employee.firstname);         query().union(employee, sq1, sq2).list(employee.id.count());     }      // FIXME for CUBRID     // Teradata: The ORDER BY clause must contain only integer constants.     @Test     @ExcludeIn({DERBY, CUBRID, TERADATA})     public void Union5() {         /* (select e.ID, e.FIRSTNAME, superior.ID as sup_id, superior.FIRSTNAME as sup_name          * from EMPLOYEE e join EMPLOYEE superior on e.SUPERIOR_ID = superior.ID)          * union          * (select e.ID, e.FIRSTNAME, null, null from EMPLOYEE e)          * order by ID asc          */         QEmployee superior = new QEmployee("superior");         ListSubQuery<Tuple> sq1 = sq().from(employee)                 .join(employee.superiorIdKey, superior)                 .list(employee.id, employee.firstname, superior.id.as("sup_id"), superior.firstname.as("sup_name"));         ListSubQuery<Tuple> sq2 = sq().from(employee)                 .list(employee.id, employee.firstname, null, null);         List<Tuple> results = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         for (Tuple result : results) {             System.err.println(Arrays.asList(result));         }     }      @Test     @ExcludeIn(TERADATA) // The ORDER BY clause must contain only integer constants.     @SuppressWarnings("unchecked")     public void Union_With_Order() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         assertFalse(list.isEmpty());     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_List() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          List<Tuple> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_Iterate() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          CloseableIterator<Tuple> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }      @SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_List() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          List<Integer> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }      @SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_Iterate() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          CloseableIterator<Integer> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }      @SuppressWarnings("unchecked")     @Test     public void Union_FactoryExpression() {         ListSubQuery<Employee> sq1 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         ListSubQuery<Employee> sq2 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         List<Employee> employees = query().union(sq1, sq2).list();         for (Employee employee : employees) {             assertNotNull(employee);         }     }   } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> querydsl-sql : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> mysema : Folder]
							[NT -> query : Folder]
								[NT -> UnionBase.java.merge : .java.merge-File]
									[T -> UnionBase.java : .java-Content "package com.mysema.query;  import static com.mysema.query.Constants.employee; import static com.mysema.query.Target.CUBRID; import static com.mysema.query.Target.DERBY; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import java.io.IOException; import java.sql.SQLException; import java.util.Arrays; import java.util.List;  import org.junit.Test;  import com.mysema.commons.lang.CloseableIterator; import com.mysema.query.sql.domain.Employee; import com.mysema.query.sql.domain.QEmployee; import com.mysema.query.types.Expression; import com.mysema.query.types.Projections; import com.mysema.query.types.SubQueryExpression; import com.mysema.query.types.query.ListSubQuery; import com.mysema.query.types.query.SimpleSubQuery; import com.mysema.testutil.ExcludeIn;  public class UnionBase extends AbstractBaseTest {      @Test     @SuppressWarnings("unchecked")     public void Union() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());     }          @Test     @SuppressWarnings("unchecked")     public void Union_All() {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().unionAll(sq1, sq2).list();         assertFalse(list.isEmpty());     }          @SuppressWarnings("unchecked")     @Test     public void Union_Multiple_Columns() throws SQLException {         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.firstname, employee.lastname);         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.lastname, employee.firstname);         List<Tuple> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());         for (Tuple row : list) {             assertNotNull(row.get(0, Object.class));             assertNotNull(row.get(1, Object.class));         }     }          @Test     @SuppressWarnings("unchecked")     public void Union_Empty_Result() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).where(employee.firstname.eq("XXX")).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).where(employee.firstname.eq("YYY")).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).list();         assertTrue(list.isEmpty());     }          @Test     @SuppressWarnings("unchecked")     public void Union2() throws SQLException {         List<Integer> list = query().union(                 sq().from(employee).unique(employee.id.max()),                 sq().from(employee).unique(employee.id.min())).list();         assertFalse(list.isEmpty());      }                                                                                                                                @Test     @SuppressWarnings("unchecked")     public void Union3() throws SQLException {         SimpleSubQuery<Tuple> sq3 = sq().from(employee).unique(new Expression[]{employee.id.max()});         SimpleSubQuery<Tuple> sq4 = sq().from(employee).unique(new Expression[]{employee.id.min()});         List<Tuple> list2 = query().union(sq3, sq4).list();         assertFalse(list2.isEmpty());     }          @Test     @ExcludeIn({DERBY})     public void Union4() {         SimpleSubQuery<Tuple> sq1 = sq().from(employee).unique(employee.id, employee.firstname);         SimpleSubQuery<Tuple> sq2 = sq().from(employee).unique(employee.id, employee.firstname);         query().union(employee, sq1, sq2).list(employee.id.count());     }          // FIXME for CUBRID     @Test     @ExcludeIn({DERBY, CUBRID})     public void Union5() {         /* (select e.ID, e.FIRSTNAME, superior.ID as sup_id, superior.FIRSTNAME as sup_name           * from EMPLOYEE e join EMPLOYEE superior on e.SUPERIOR_ID = superior.ID)           * union           * (select e.ID, e.FIRSTNAME, null, null from EMPLOYEE e)           * order by ID asc          */         QEmployee superior = new QEmployee("superior");         ListSubQuery<Tuple> sq1 = sq().from(employee)                 .join(employee.superiorIdKey, superior)                 .list(employee.id, employee.firstname, superior.id.as("sup_id"), superior.firstname.as("sup_name"));         ListSubQuery<Tuple> sq2 = sq().from(employee)                 .list(employee.id, employee.firstname, null, null);         List<Tuple> results = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         for (Tuple result : results) {             System.err.println(Arrays.asList(result));         }       }          @Test     @SuppressWarnings("unchecked")     public void Union_With_Order() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         assertFalse(list.isEmpty());     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_List() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          List<Tuple> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }          @SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_Iterate() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          CloseableIterator<Tuple> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }              @SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_List() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          List<Integer> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }          @SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_Iterate() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          CloseableIterator<Integer> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }      @SuppressWarnings("unchecked")     @Test     public void Union_FactoryExpression() {         ListSubQuery<Employee> sq1 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         ListSubQuery<Employee> sq2 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));                 List<Employee> employees = query().union(sq1, sq2).list();         for (Employee employee : employees) {             assertNotNull(employee);         }     }           } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> querydsl-sql : Folder]
		[NT -> src : Folder]
			[NT -> test : Folder]
				[NT -> java : Folder]
					[NT -> com : Folder]
						[NT -> mysema : Folder]
							[NT -> query : Folder]
								[NT -> UnionBase.java.merge : .java.merge-File]
									[T -> UnionBase.java : .java-Content "package com.mysema.query;  import static com.mysema.query.Constants.employee; import static com.mysema.query.Target.CUBRID; import static com.mysema.query.Target.DERBY; import static com.mysema.query.Target.MYSQL; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import java.io.IOException; import java.sql.SQLException; import java.util.Arrays; import java.util.List;  import org.junit.Test;  import com.mysema.commons.lang.CloseableIterator; import com.mysema.query.sql.domain.Employee; import com.mysema.query.sql.domain.QEmployee; import com.mysema.query.types.Expression; import com.mysema.query.types.Projections; import com.mysema.query.types.SubQueryExpression; import com.mysema.query.types.query.ListSubQuery; import com.mysema.query.types.query.SimpleSubQuery; import com.mysema.query.types.template.NumberTemplate; import com.mysema.testutil.ExcludeIn;  public class UnionBase extends AbstractBaseTest {      @Test     @ExcludeIn(MYSQL)     public void In_Union() {         assertTrue(query().from(employee)             .where(employee.id.in(                 sq().union(sq().unique(NumberTemplate.ONE),                            sq().unique(NumberTemplate.TWO))))             .exists());     }      @Test     @SuppressWarnings("unchecked")     public void Union() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());     }      @Test     @SuppressWarnings("unchecked")     public void Union_All() {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());         List<Integer> list = query().unionAll(sq1, sq2).list();         assertFalse(list.isEmpty());     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multiple_Columns() throws SQLException {         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.firstname, employee.lastname);         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.lastname, employee.firstname);         List<Tuple> list = query().union(sq1, sq2).list();         assertFalse(list.isEmpty());         for (Tuple row : list) {             assertNotNull(row.get(0, Object.class));             assertNotNull(row.get(1, Object.class));         }     }      @Test     @SuppressWarnings("unchecked")     public void Union_Empty_Result() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).where(employee.firstname.eq("XXX")).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).where(employee.firstname.eq("YYY")).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).list();         assertTrue(list.isEmpty());     }      @Test     @SuppressWarnings("unchecked")     public void Union2() throws SQLException {         List<Integer> list = query().union(                 sq().from(employee).unique(employee.id.max()),                 sq().from(employee).unique(employee.id.min())).list();         assertFalse(list.isEmpty());      }      @Test     @SuppressWarnings("unchecked")     public void Union3() throws SQLException {         SimpleSubQuery<Tuple> sq3 = sq().from(employee).unique(new Expression[]{employee.id.max()});         SimpleSubQuery<Tuple> sq4 = sq().from(employee).unique(new Expression[]{employee.id.min()});         List<Tuple> list2 = query().union(sq3, sq4).list();         assertFalse(list2.isEmpty());     }      @Test     @ExcludeIn({DERBY})     public void Union4() {         SimpleSubQuery<Tuple> sq1 = sq().from(employee).unique(employee.id, employee.firstname);         SimpleSubQuery<Tuple> sq2 = sq().from(employee).unique(employee.id, employee.firstname);         query().union(employee, sq1, sq2).list(employee.id.count());     }       // FIXME for CUBRID     @Test     @ExcludeIn({DERBY, CUBRID})     public void Union5() {         /* (select e.ID, e.FIRSTNAME, superior.ID as sup_id, superior.FIRSTNAME as sup_name          * from EMPLOYEE e join EMPLOYEE superior on e.SUPERIOR_ID = superior.ID)          * union          * (select e.ID, e.FIRSTNAME, null, null from EMPLOYEE e)          * order by ID asc          */         QEmployee superior = new QEmployee("superior");         ListSubQuery<Tuple> sq1 = sq().from(employee)                 .join(employee.superiorIdKey, superior)                 .list(employee.id, employee.firstname, superior.id.as("sup_id"), superior.firstname.as("sup_name"));         ListSubQuery<Tuple> sq2 = sq().from(employee)                 .list(employee.id, employee.firstname, null, null);         List<Tuple> results = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         for (Tuple result : results) {             System.err.println(Arrays.asList(result));         }      }      @Test     @SuppressWarnings("unchecked")     public void Union_With_Order() throws SQLException {         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id);         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id);         List<Integer> list = query().union(sq1, sq2).orderBy(employee.id.asc()).list();         assertFalse(list.isEmpty());     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_List() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          List<Tuple> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }      @SuppressWarnings("unchecked")     @Test     public void Union_Multi_Column_Projection_Iterate() throws IOException{         SubQueryExpression<Tuple> sq1 = sq().from(employee).unique(employee.id.max(), employee.id.max().subtract(1));         SubQueryExpression<Tuple> sq2 = sq().from(employee).unique(employee.id.min(), employee.id.min().subtract(1));          CloseableIterator<Tuple> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }      @SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_List() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          List<Integer> list = query().union(sq1, sq2).list();         assertEquals(2, list.size());         assertTrue(list.get(0) != null);         assertTrue(list.get(1) != null);     }      @SuppressWarnings("unchecked")     @Test     public void Union_Single_Column_Projections_Iterate() throws IOException{         SubQueryExpression<Integer> sq1 = sq().from(employee).unique(employee.id.max());         SubQueryExpression<Integer> sq2 = sq().from(employee).unique(employee.id.min());          CloseableIterator<Integer> iterator = query().union(sq1,sq2).iterate();         try{             assertTrue(iterator.hasNext());             assertTrue(iterator.next() != null);             assertTrue(iterator.next() != null);             assertFalse(iterator.hasNext());         }finally{             iterator.close();         }     }      @SuppressWarnings("unchecked")     @Test     public void Union_FactoryExpression() {         ListSubQuery<Employee> sq1 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         ListSubQuery<Employee> sq2 = sq().from(employee)                 .list(Projections.constructor(Employee.class, employee.id));         List<Employee> employees = query().union(sq1, sq2).list();         for (Employee employee : employees) {             assertNotNull(employee);         }     }   } " compose:StringConcatenation merge: LineBased]
